//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  //use the faster Date.now if available.
  var getTime = (Date.now || function() {
    return new Date().getTime();
  });

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = value == null ? _.identity : lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : getTime();
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = getTime();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = getTime();
      var later = function() {
        var last = getTime() - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /* jshint strict: false */

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else {
        Q = definition();
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you donâ€™t need a security guarantee,
// this is just plain paranoid.
// However, this does have the nice side-effect of reducing the size
// of the code by reducing x.call() to merely x(), eliminating many
// hard-to-minify characters.
// See Mark Millerâ€™s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
// engine that has a deployed base of browsers that support generators.
// However, SM's generators use the Python-inspired semantics of
// outdated ES6 drafts.  We would like to support ES6, but we'd also
// like to make it possible to use generators in deployed browsers, so
// we also support Python-style generators.  At some point we can remove
// this block.
var hasES6Generators;
try {
    /* jshint evil: true, nonew: false */
    new Function("(function* (){ yield 1; })");
    hasES6Generators = true;
} catch (e) {
    hasES6Generators = false;
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = deprecate(function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    }, "valueOf", "inspect");

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become fulfilled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be fulfilled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = deprecate(function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        });
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If itâ€™s a fulfilled promise, the fulfillment value is nearer.
 * If itâ€™s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return isObject(object) &&
        typeof object.promiseDispatch === "function" &&
        typeof object.inspect === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var unhandledReasonsDisplayed = false;
var trackUnhandledRejections = true;
function displayUnhandledReasons() {
    if (
        !unhandledReasonsDisplayed &&
        typeof window !== "undefined" &&
        !window.Touch &&
        window.console
    ) {
        console.warn("[Q] Unhandled rejection reasons (should be empty):",
                     unhandledReasons);
    }

    unhandledReasonsDisplayed = true;
}

function logUnhandledReasons() {
    for (var i = 0; i < unhandledReasons.length; i++) {
        var reason = unhandledReasons[i];
        console.warn("Unhandled rejection reason:", reason);
    }
}

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;
    unhandledReasonsDisplayed = false;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;

        // Show unhandled rejection reasons if Node exits without handling an
        // outstanding rejection.  (Note that Browserify presently produces a
        // `process` global without the `EventEmitter` `on` method.)
        if (typeof process !== "undefined" && process.on) {
            process.on("exit", logUnhandledReasons);
        }
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
    displayUnhandledReasons();
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    if (typeof process !== "undefined" && process.on) {
        process.removeListener("exit", logUnhandledReasons);
    }
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;
            if (hasES6Generators) {
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return result.value;
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return exception.value;
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {String} custom error message (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, message) {
    return Q(object).timeout(ms, message);
};

Promise.prototype.timeout = function (ms, message) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '69' };

// browserify support

if ( typeof module === 'object' ) {

  module.exports = THREE;

}

// polyfills

if ( Math.sign === undefined ) {

  Math.sign = function ( x ) {

    return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;

  };

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

  if ( arguments.length === 3 ) {

    return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

  }

  return this.set( color )

};

THREE.Color.prototype = {

  constructor: THREE.Color,

  r: 1, g: 1, b: 1,

  set: function ( value ) {

    if ( value instanceof THREE.Color ) {

      this.copy( value );

    } else if ( typeof value === 'number' ) {

      this.setHex( value );

    } else if ( typeof value === 'string' ) {

      this.setStyle( value );

    }

    return this;

  },

  setHex: function ( hex ) {

    hex = Math.floor( hex );

    this.r = ( hex >> 16 & 255 ) / 255;
    this.g = ( hex >> 8 & 255 ) / 255;
    this.b = ( hex & 255 ) / 255;

    return this;

  },

  setRGB: function ( r, g, b ) {

    this.r = r;
    this.g = g;
    this.b = b;

    return this;

  },

  setHSL: function ( h, s, l ) {

    // h,s,l ranges are in 0.0 - 1.0

    if ( s === 0 ) {

      this.r = this.g = this.b = l;

    } else {

      var hue2rgb = function ( p, q, t ) {

        if ( t < 0 ) t += 1;
        if ( t > 1 ) t -= 1;
        if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
        if ( t < 1 / 2 ) return q;
        if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
        return p;

      };

      var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
      var q = ( 2 * l ) - p;

      this.r = hue2rgb( q, p, h + 1 / 3 );
      this.g = hue2rgb( q, p, h );
      this.b = hue2rgb( q, p, h - 1 / 3 );

    }

    return this;

  },

  setStyle: function ( style ) {

    // rgb(255,0,0)

    if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

      var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

      this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
      this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
      this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

      return this;

    }

    // rgb(100%,0%,0%)

    if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

      var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

      this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
      this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
      this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

      return this;

    }

    // #ff0000

    if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

      var color = /^\#([0-9a-f]{6})$/i.exec( style );

      this.setHex( parseInt( color[ 1 ], 16 ) );

      return this;

    }

    // #f00

    if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

      var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

      this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

      return this;

    }

    // red

    if ( /^(\w+)$/i.test( style ) ) {

      this.setHex( THREE.ColorKeywords[ style ] );

      return this;

    }


  },

  copy: function ( color ) {

    this.r = color.r;
    this.g = color.g;
    this.b = color.b;

    return this;

  },

  copyGammaToLinear: function ( color ) {

    this.r = color.r * color.r;
    this.g = color.g * color.g;
    this.b = color.b * color.b;

    return this;

  },

  copyLinearToGamma: function ( color ) {

    this.r = Math.sqrt( color.r );
    this.g = Math.sqrt( color.g );
    this.b = Math.sqrt( color.b );

    return this;

  },

  convertGammaToLinear: function () {

    var r = this.r, g = this.g, b = this.b;

    this.r = r * r;
    this.g = g * g;
    this.b = b * b;

    return this;

  },

  convertLinearToGamma: function () {

    this.r = Math.sqrt( this.r );
    this.g = Math.sqrt( this.g );
    this.b = Math.sqrt( this.b );

    return this;

  },

  getHex: function () {

    return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  },

  getHexString: function () {

    return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  },

  getHSL: function ( optionalTarget ) {

    // h,s,l ranges are in 0.0 - 1.0

    var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    var r = this.r, g = this.g, b = this.b;

    var max = Math.max( r, g, b );
    var min = Math.min( r, g, b );

    var hue, saturation;
    var lightness = ( min + max ) / 2.0;

    if ( min === max ) {

      hue = 0;
      saturation = 0;

    } else {

      var delta = max - min;

      saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

      switch ( max ) {

        case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
        case g: hue = ( b - r ) / delta + 2; break;
        case b: hue = ( r - g ) / delta + 4; break;

      }

      hue /= 6;

    }

    hsl.h = hue;
    hsl.s = saturation;
    hsl.l = lightness;

    return hsl;

  },

  getStyle: function () {

    return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  },

  offsetHSL: function ( h, s, l ) {

    var hsl = this.getHSL();

    hsl.h += h; hsl.s += s; hsl.l += l;

    this.setHSL( hsl.h, hsl.s, hsl.l );

    return this;

  },

  add: function ( color ) {

    this.r += color.r;
    this.g += color.g;
    this.b += color.b;

    return this;

  },

  addColors: function ( color1, color2 ) {

    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;

    return this;

  },

  addScalar: function ( s ) {

    this.r += s;
    this.g += s;
    this.b += s;

    return this;

  },

  multiply: function ( color ) {

    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.r *= s;
    this.g *= s;
    this.b *= s;

    return this;

  },

  lerp: function ( color, alpha ) {

    this.r += ( color.r - this.r ) * alpha;
    this.g += ( color.g - this.g ) * alpha;
    this.b += ( color.b - this.b ) * alpha;

    return this;

  },

  equals: function ( c ) {

    return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  },

  fromArray: function ( array ) {

    this.r = array[ 0 ];
    this.g = array[ 1 ];
    this.b = array[ 2 ];

    return this;

  },

  toArray: function () {

    return [ this.r, this.g, this.b ];

  },

  clone: function () {

    return new THREE.Color().setRGB( this.r, this.g, this.b );

  }

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

  constructor: THREE.Quaternion,

  _x: 0,_y: 0, _z: 0, _w: 0,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get w () {

    return this._w;

  },

  set w ( value ) {

    this._w = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, w ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this.onChangeCallback();

    return this;

  },

  copy: function ( quaternion ) {

    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this.onChangeCallback();

    return this;

  },

  setFromEuler: function ( euler, update ) {

    if ( euler instanceof THREE.Euler === false ) {

      throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
    }

    // http://www.mathworks.com/matlabcentral/fileexchange/
    //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //  content/SpinCalc.m

    var c1 = Math.cos( euler._x / 2 );
    var c2 = Math.cos( euler._y / 2 );
    var c3 = Math.cos( euler._z / 2 );
    var s1 = Math.sin( euler._x / 2 );
    var s2 = Math.sin( euler._y / 2 );
    var s3 = Math.sin( euler._z / 2 );

    if ( euler.order === 'XYZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'YXZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'ZXY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'ZYX' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'YZX' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'XZY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromAxisAngle: function ( axis, angle ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos( halfAngle );

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

      trace = m11 + m22 + m33,
      s;

    if ( trace > 0 ) {

      s = 0.5 / Math.sqrt( trace + 1.0 );

      this._w = 0.25 / s;
      this._x = ( m32 - m23 ) * s;
      this._y = ( m13 - m31 ) * s;
      this._z = ( m21 - m12 ) * s;

    } else if ( m11 > m22 && m11 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

      this._w = ( m32 - m23 ) / s;
      this._x = 0.25 * s;
      this._y = ( m12 + m21 ) / s;
      this._z = ( m13 + m31 ) / s;

    } else if ( m22 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

      this._w = ( m13 - m31 ) / s;
      this._x = ( m12 + m21 ) / s;
      this._y = 0.25 * s;
      this._z = ( m23 + m32 ) / s;

    } else {

      s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

      this._w = ( m21 - m12 ) / s;
      this._x = ( m13 + m31 ) / s;
      this._y = ( m23 + m32 ) / s;
      this._z = 0.25 * s;

    }

    this.onChangeCallback();

    return this;

  },

  setFromUnitVectors: function () {

    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;

    var EPS = 0.000001;

    return function ( vFrom, vTo ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {

        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

          v1.set( - vFrom.y, vFrom.x, 0 );

        } else {

          v1.set( 0, - vFrom.z, vFrom.y );

        }

      } else {

        v1.crossVectors( vFrom, vTo );

      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;

      this.normalize();

      return this;

    }

  }(),

  inverse: function () {

    this.conjugate().normalize();

    return this;

  },

  conjugate: function () {

    this._x *= - 1;
    this._y *= - 1;
    this._z *= - 1;

    this.onChangeCallback();

    return this;

  },

  dot: function ( v ) {

    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  },

  lengthSq: function () {

    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  },

  length: function () {

    return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  },

  normalize: function () {

    var l = this.length();

    if ( l === 0 ) {

      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;

    } else {

      l = 1 / l;

      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;

    }

    this.onChangeCallback();

    return this;

  },

  multiply: function ( q, p ) {

    if ( p !== undefined ) {

      console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
      return this.multiplyQuaternions( q, p );

    }

    return this.multiplyQuaternions( this, q );

  },

  multiplyQuaternions: function ( a, b ) {

    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this.onChangeCallback();

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    return vector.applyQuaternion( this );

  },

  slerp: function ( qb, t ) {

    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this._x, y = this._y, z = this._z, w = this._w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if ( cosHalfTheta < 0 ) {

      this._w = - qb._w;
      this._x = - qb._x;
      this._y = - qb._y;
      this._z = - qb._z;

      cosHalfTheta = - cosHalfTheta;

    } else {

      this.copy( qb );

    }

    if ( cosHalfTheta >= 1.0 ) {

      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;

      return this;

    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {

      this._w = 0.5 * ( w + this._w );
      this._x = 0.5 * ( x + this._x );
      this._y = 0.5 * ( y + this._y );
      this._z = 0.5 * ( z + this._z );

      return this;

    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this._w = ( w * ratioA + this._w * ratioB );
    this._x = ( x * ratioA + this._x * ratioB );
    this._y = ( y * ratioA + this._y * ratioB );
    this._z = ( z * ratioA + this._z * ratioB );

    this.onChangeCallback();

    return this;

  },

  equals: function ( quaternion ) {

    return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this._x = array[ offset ];
    this._y = array[ offset + 1 ];
    this._z = array[ offset + 2 ];
    this._w = array[ offset + 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._w;

    return array;

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {},

  clone: function () {

    return new THREE.Quaternion( this._x, this._y, this._z, this._w );

  }

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

  return qm.copy( qa ).slerp( qb, t );

}

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

  this.x = x || 0;
  this.y = y || 0;

};

THREE.Vector2.prototype = {

  constructor: THREE.Vector2,

  set: function ( x, y ) {

    this.x = x;
    this.y = y;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;

  },

  multiply: function ( v ) {

    this.x *= v.x;
    this.y *= v.y;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.x *= s;
    this.y *= s;

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    return this;
  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector2();
        max = new THREE.Vector2();

      }

      min.set( minVal, minVal );
      max.set( maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );
    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;

    return array;

  },

  clone: function () {

    return new THREE.Vector2( this.x, this.y );

  }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;

};

THREE.Vector3.prototype = {

  constructor: THREE.Vector3,

  set: function ( x, y, z ) {

    this.x = x;
    this.y = y;
    this.z = z;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;

    return this;

  },

  multiply: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
      return this.multiplyVectors( v, w );

    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;

    return this;

  },

  multiplyVectors: function ( a, b ) {

    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;

    return this;

  },

  applyEuler: function () {

    var quaternion;

    return function ( euler ) {

      if ( euler instanceof THREE.Euler === false ) {

        console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

      }

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromEuler( euler ) );

      return this;

    };

  }(),

  applyAxisAngle: function () {

    var quaternion;

    return function ( axis, angle ) {

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

      return this;

    };

  }(),

  applyMatrix3: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    return this;

  },

  applyMatrix4: function ( m ) {

    // input: THREE.Matrix4 affine matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    return this;

  },

  applyProjection: function ( m ) {

    // input: THREE.Matrix4 projection matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;
    var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    return this;

  },

  applyQuaternion: function ( q ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector

    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;

  },

  project: function () {

    var matrix;

    return function ( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
      return this.applyProjection( matrix );

    };

  }(),

  unproject: function () {

    var matrix;

    return function ( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
      return this.applyProjection( matrix );

    };

  }(),

  transformDirection: function ( m ) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    this.normalize();

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    return this;

  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector3();
        max = new THREE.Vector3();

      }

      min.set( minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength  ) {

      this.multiplyScalar( l / oldLength );
    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;

    return this;

  },

  cross: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
      return this.crossVectors( v, w );

    }

    var x = this.x, y = this.y, z = this.z;

    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;

    return this;

  },

  crossVectors: function ( a, b ) {

    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;

  },

  projectOnVector: function () {

    var v1, dot;

    return function ( vector ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( vector ).normalize();

      dot = this.dot( v1 );

      return this.copy( v1 ).multiplyScalar( dot );

    };

  }(),

  projectOnPlane: function () {

    var v1;

    return function ( planeNormal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( this ).projectOnVector( planeNormal );

      return this.sub( v1 );

    }

  }(),

  reflect: function () {

    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    var v1;

    return function ( normal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    }

  }(),

  angleTo: function ( v ) {

    var theta = this.dot( v ) / ( this.length() * v.length() );

    // clamp, to handle numerical problems

    return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;

    return dx * dx + dy * dy + dz * dz;

  },

  setEulerFromRotationMatrix: function ( m, order ) {

    console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  },

  setEulerFromQuaternion: function ( q, order ) {

    console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  },

  getPositionFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

    return this.setFromMatrixPosition( m );

  },

  getScaleFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

    return this.setFromMatrixScale( m );
  },

  getColumnFromMatrix: function ( index, matrix ) {

    console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

    return this.setFromMatrixColumn( index, matrix );

  },

  setFromMatrixPosition: function ( m ) {

    this.x = m.elements[ 12 ];
    this.y = m.elements[ 13 ];
    this.z = m.elements[ 14 ];

    return this;

  },

  setFromMatrixScale: function ( m ) {

    var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
    var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
    var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

    this.x = sx;
    this.y = sy;
    this.z = sz;

    return this;
  },

  setFromMatrixColumn: function ( index, matrix ) {

    var offset = index * 4;

    var me = matrix.elements;

    this.x = me[ offset ];
    this.y = me[ offset + 1 ];
    this.z = me[ offset + 2 ];

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;

    return array;

  },

  clone: function () {

    return new THREE.Vector3( this.x, this.y, this.z );

  }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

  constructor: THREE.Vector4,

  set: function ( x, y, z, w ) {

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setW: function ( w ) {

    this.w = w;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      case 3: this.w = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      case 3: return this.w;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = ( v.w !== undefined ) ? v.w : 1;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;

    return this;

  },

  applyMatrix4: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;
    var w = this.w;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;
      this.w *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;

    }

    return this;

  },

  setAxisAngleFromQuaternion: function ( q ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    // q is assumed to be normalized

    this.w = 2 * Math.acos( q.w );

    var s = Math.sqrt( 1 - q.w * q.w );

    if ( s < 0.0001 ) {

       this.x = 1;
       this.y = 0;
       this.z = 0;

    } else {

       this.x = q.x / s;
       this.y = q.y / s;
       this.z = q.z / s;

    }

    return this;

  },

  setAxisAngleFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var angle, x, y, z,   // variables for result
      epsilon = 0.01,   // margin to allow for rounding errors
      epsilon2 = 0.1,   // margin to distinguish between 0 and 180 degrees

      te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    if ( ( Math.abs( m12 - m21 ) < epsilon )
       && ( Math.abs( m13 - m31 ) < epsilon )
       && ( Math.abs( m23 - m32 ) < epsilon ) ) {

      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms

      if ( ( Math.abs( m12 + m21 ) < epsilon2 )
         && ( Math.abs( m13 + m31 ) < epsilon2 )
         && ( Math.abs( m23 + m32 ) < epsilon2 )
         && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

        // this singularity is identity matrix so angle = 0

        this.set( 1, 0, 0, 0 );

        return this; // zero angle, arbitrary axis

      }

      // otherwise this singularity is angle = 180

      angle = Math.PI;

      var xx = ( m11 + 1 ) / 2;
      var yy = ( m22 + 1 ) / 2;
      var zz = ( m33 + 1 ) / 2;
      var xy = ( m12 + m21 ) / 4;
      var xz = ( m13 + m31 ) / 4;
      var yz = ( m23 + m32 ) / 4;

      if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

        if ( xx < epsilon ) {

          x = 0;
          y = 0.707106781;
          z = 0.707106781;

        } else {

          x = Math.sqrt( xx );
          y = xy / x;
          z = xz / x;

        }

      } else if ( yy > zz ) { // m22 is the largest diagonal term

        if ( yy < epsilon ) {

          x = 0.707106781;
          y = 0;
          z = 0.707106781;

        } else {

          y = Math.sqrt( yy );
          x = xy / y;
          z = yz / y;

        }

      } else { // m33 is the largest diagonal term so base result on this

        if ( zz < epsilon ) {

          x = 0.707106781;
          y = 0.707106781;
          z = 0;

        } else {

          z = Math.sqrt( zz );
          x = xz / z;
          y = yz / z;

        }

      }

      this.set( x, y, z, angle );

      return this; // return 180 deg rotation

    }

    // as we have reached here there are no singularities so we can handle normally

    var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
              + ( m13 - m31 ) * ( m13 - m31 )
              + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    if ( Math.abs( s ) < 0.001 ) s = 1;

    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = ( m32 - m23 ) / s;
    this.y = ( m13 - m31 ) / s;
    this.z = ( m21 - m12 ) / s;
    this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    if ( this.w > v.w ) {

      this.w = v.w;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    if ( this.w < v.w ) {

      this.w = v.w;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    if ( this.w < min.w ) {

      this.w = min.w;

    } else if ( this.w > max.w ) {

      this.w = max.w;

    }

    return this;

  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector4();
        max = new THREE.Vector4();

      }

      min.set( minVal, minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;
    this.w = - this.w;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );

    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;
    this.w += ( v.w - this.w ) * alpha;

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];
    this.w = array[ offset + 3 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;
    array[ offset + 3 ] = this.w;

    return array;

  },

  clone: function () {

    return new THREE.Vector4( this.x, this.y, this.z, this.w );

  }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

  constructor: THREE.Euler,

  _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get order () {

    return this._order;

  },

  set order ( value ) {

    this._order = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, order ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this.onChangeCallback();

    return this;

  },

  copy: function ( euler ) {

    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m, order ) {

    var clamp = THREE.Math.clamp;

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    order = order || this._order;

    if ( order === 'XYZ' ) {

      this._y = Math.asin( clamp( m13, - 1, 1 ) );

      if ( Math.abs( m13 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m33 );
        this._z = Math.atan2( - m12, m11 );

      } else {

        this._x = Math.atan2( m32, m22 );
        this._z = 0;

      }

    } else if ( order === 'YXZ' ) {

      this._x = Math.asin( - clamp( m23, - 1, 1 ) );

      if ( Math.abs( m23 ) < 0.99999 ) {

        this._y = Math.atan2( m13, m33 );
        this._z = Math.atan2( m21, m22 );

      } else {

        this._y = Math.atan2( - m31, m11 );
        this._z = 0;

      }

    } else if ( order === 'ZXY' ) {

      this._x = Math.asin( clamp( m32, - 1, 1 ) );

      if ( Math.abs( m32 ) < 0.99999 ) {

        this._y = Math.atan2( - m31, m33 );
        this._z = Math.atan2( - m12, m22 );

      } else {

        this._y = 0;
        this._z = Math.atan2( m21, m11 );

      }

    } else if ( order === 'ZYX' ) {

      this._y = Math.asin( - clamp( m31, - 1, 1 ) );

      if ( Math.abs( m31 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m33 );
        this._z = Math.atan2( m21, m11 );

      } else {

        this._x = 0;
        this._z = Math.atan2( - m12, m22 );

      }

    } else if ( order === 'YZX' ) {

      this._z = Math.asin( clamp( m21, - 1, 1 ) );

      if ( Math.abs( m21 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m22 );
        this._y = Math.atan2( - m31, m11 );

      } else {

        this._x = 0;
        this._y = Math.atan2( m13, m33 );

      }

    } else if ( order === 'XZY' ) {

      this._z = Math.asin( - clamp( m12, - 1, 1 ) );

      if ( Math.abs( m12 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m22 );
        this._y = Math.atan2( m13, m11 );

      } else {

        this._x = Math.atan2( - m23, m33 );
        this._y = 0;

      }

    } else {

      console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

    }

    this._order = order;

    this.onChangeCallback();

    return this;

  },

  setFromQuaternion: function ( q, order, update ) {

    var clamp = THREE.Math.clamp;

    // q is assumed to be normalized

    // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

    var sqx = q.x * q.x;
    var sqy = q.y * q.y;
    var sqz = q.z * q.z;
    var sqw = q.w * q.w;

    order = order || this._order;

    if ( order === 'XYZ' ) {

      this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
      this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ), - 1, 1 ) );
      this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

    } else if ( order ===  'YXZ' ) {

      this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ), - 1, 1 ) );
      this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
      this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

    } else if ( order === 'ZXY' ) {

      this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ), - 1, 1 ) );
      this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
      this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

    } else if ( order === 'ZYX' ) {

      this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
      this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ), - 1, 1 ) );
      this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

    } else if ( order === 'YZX' ) {

      this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
      this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
      this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ), - 1, 1 ) );

    } else if ( order === 'XZY' ) {

      this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
      this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
      this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ), - 1, 1 ) );

    } else {

      console.warn( 'THREE.Euler: .setFromQuaternion() given unsupported order: ' + order )

    }

    this._order = order;

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  reorder: function () {

    // WARNING: this discards revolution information -bhouston

    var q = new THREE.Quaternion();

    return function ( newOrder ) {

      q.setFromEuler( this );
      this.setFromQuaternion( q, newOrder );

    };


  }(),

  equals: function ( euler ) {

    return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  },

  fromArray: function ( array ) {

    this._x = array[ 0 ];
    this._y = array[ 1 ];
    this._z = array[ 2 ];
    if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function () {

    return [ this._x, this._y, this._z, this._order ];

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {},

  clone: function () {

    return new THREE.Euler( this._x, this._y, this._z, this._order );

  }

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

  this.start = ( start !== undefined ) ? start : new THREE.Vector3();
  this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

  constructor: THREE.Line3,

  set: function ( start, end ) {

    this.start.copy( start );
    this.end.copy( end );

    return this;

  },

  copy: function ( line ) {

    this.start.copy( line.start );
    this.end.copy( line.end );

    return this;

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  },

  delta: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.end, this.start );

  },

  distanceSq: function () {

    return this.start.distanceToSquared( this.end );

  },

  distance: function () {

    return this.start.distanceTo( this.end );

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  closestPointToPointParameter: function () {

    var startP = new THREE.Vector3();
    var startEnd = new THREE.Vector3();

    return function ( point, clampToLine ) {

      startP.subVectors( point, this.start );
      startEnd.subVectors( this.end, this.start );

      var startEnd2 = startEnd.dot( startEnd );
      var startEnd_startP = startEnd.dot( startP );

      var t = startEnd_startP / startEnd2;

      if ( clampToLine ) {

        t = THREE.Math.clamp( t, 0, 1 );

      }

      return t;

    };

  }(),

  closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    var t = this.closestPointToPointParameter( point, clampToLine );

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  applyMatrix4: function ( matrix ) {

    this.start.applyMatrix4( matrix );
    this.end.applyMatrix4( matrix );

    return this;

  },

  equals: function ( line ) {

    return line.start.equals( this.start ) && line.end.equals( this.end );

  },

  clone: function () {

    return new THREE.Line3().copy( this );

  }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

  constructor: THREE.Box2,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] )

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector2();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = - Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;
  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;
  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;
  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
         ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector2();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y )
    );

  },

  isIntersectionBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector2();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  },

  clone: function () {

    return new THREE.Box2().copy( this );

  }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

  constructor: THREE.Box3,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] )

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector3();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  setFromObject: function () {

    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and childrens', world transforms

    var v1 = new THREE.Vector3();

    return function ( object ) {

      var scope = this;

      object.updateMatrixWorld( true );

      this.makeEmpty();

      object.traverse( function ( node ) {

        var geometry = node.geometry;

        if ( geometry !== undefined ) {

          if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;

            for ( var i = 0, il = vertices.length; i < il; i ++ ) {

              v1.copy( vertices[ i ] );

              v1.applyMatrix4( node.matrixWorld );

              scope.expandByPoint( v1 );

            }

          } else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

            var positions = geometry.attributes[ 'position' ].array;

            for ( var i = 0, il = positions.length; i < il; i += 3 ) {

              v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

              v1.applyMatrix4( node.matrixWorld );

              scope.expandByPoint( v1 );

            }

          }

        }

      } );

      return this;

    };

  }(),

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = - Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;

  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;

  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;

  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ||
         point.z < this.min.z || point.z > this.max.z ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
       ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
       ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector3();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
      ( point.z - this.min.z ) / ( this.max.z - this.min.z )
    );

  },

  isIntersectionBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ||
         box.max.z < this.min.z || box.min.z > this.max.z ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  getBoundingSphere: function () {

    var v1 = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Sphere();

      result.center = this.center();
      result.radius = this.size( v1 ).length() * 0.5;

      return result;

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  applyMatrix4: function () {

    var points = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];

    return function ( matrix ) {

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
      points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
      points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
      points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
      points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
      points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
      points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
      points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

      this.makeEmpty();
      this.setFromPoints( points );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  },

  clone: function () {

    return new THREE.Box3().copy( this );

  }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function () {

  this.elements = new Float32Array( [

    1, 0, 0,
    0, 1, 0,
    0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix3.prototype = {

  constructor: THREE.Matrix3,

  set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
    te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
    te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0,
      0, 1, 0,
      0, 0, 1

    );

    return this;

  },

  copy: function ( m ) {

    var me = m.elements;

    this.set(

      me[ 0 ], me[ 3 ], me[ 6 ],
      me[ 1 ], me[ 4 ], me[ 7 ],
      me[ 2 ], me[ 5 ], me[ 8 ]

    );

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
    return vector.applyMatrix3( this );

  },

  multiplyVector3Array: function ( a ) {

    console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    return this.applyToVector3Array( a );

  },

  applyToVector3Array: function () {

    var v1 = new THREE.Vector3();

    return function ( array, offset, length ) {

      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

        v1.x = array[ j ];
        v1.y = array[ j + 1 ];
        v1.z = array[ j + 2 ];

        v1.applyMatrix3( this );

        array[ j ]     = v1.x;
        array[ j + 1 ] = v1.y;
        array[ j + 2 ] = v1.z;

      }

      return array;

    };

  }(),

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    return this;

  },

  determinant: function () {

    var te = this.elements;

    var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
      d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
      g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  },

  getInverse: function ( matrix, throwOnInvertible ) {

    // input: THREE.Matrix4
    // ( based on http://code.google.com/p/webgl-mjs/ )

    var me = matrix.elements;
    var te = this.elements;

    te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
    te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
    te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
    te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
    te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
    te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
    te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
    te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
    te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

    var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

    // no inverse

    if ( det === 0 ) {

      var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1.0 / det );

    return this;

  },

  transpose: function () {

    var tmp, m = this.elements;

    tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset     ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];

    array[ offset + 3 ] = te[ 3 ];
    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];

    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];
    array[ offset + 8 ]  = te[ 8 ];

    return array;

  },

  getNormalMatrix: function ( m ) {

    // input: THREE.Matrix4

    this.getInverse( m ).transpose();

    return this;

  },

  transposeIntoArray: function ( r ) {

    var m = this.elements;

    r[ 0 ] = m[ 0 ];
    r[ 1 ] = m[ 3 ];
    r[ 2 ] = m[ 6 ];
    r[ 3 ] = m[ 1 ];
    r[ 4 ] = m[ 4 ];
    r[ 5 ] = m[ 7 ];
    r[ 6 ] = m[ 2 ];
    r[ 7 ] = m[ 5 ];
    r[ 8 ] = m[ 8 ];

    return this;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ],
      te[ 3 ], te[ 4 ], te[ 5 ],
      te[ 6 ], te[ 7 ], te[ 8 ]
    ];

  },

  clone: function () {

    return new THREE.Matrix3().fromArray( this.elements );

  }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

  this.elements = new Float32Array( [

    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix4.prototype = {

  constructor: THREE.Matrix4,

  set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1

    );

    return this;

  },

  copy: function ( m ) {

    this.elements.set( m.elements );

    return this;

  },

  extractPosition: function ( m ) {

    console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
    return this.copyPosition( m );

  },

  copyPosition: function ( m ) {

    var te = this.elements;
    var me = m.elements;

    te[ 12 ] = me[ 12 ];
    te[ 13 ] = me[ 13 ];
    te[ 14 ] = me[ 14 ];

    return this;

  },

  extractRotation: function () {

    var v1 = new THREE.Vector3();

    return function ( m ) {

      var te = this.elements;
      var me = m.elements;

      var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
      var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
      var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

      te[ 0 ] = me[ 0 ] * scaleX;
      te[ 1 ] = me[ 1 ] * scaleX;
      te[ 2 ] = me[ 2 ] * scaleX;

      te[ 4 ] = me[ 4 ] * scaleY;
      te[ 5 ] = me[ 5 ] * scaleY;
      te[ 6 ] = me[ 6 ] * scaleY;

      te[ 8 ] = me[ 8 ] * scaleZ;
      te[ 9 ] = me[ 9 ] * scaleZ;
      te[ 10 ] = me[ 10 ] * scaleZ;

      return this;

    };

  }(),

  makeRotationFromEuler: function ( euler ) {

    if ( euler instanceof THREE.Euler === false ) {

      console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    }

    var te = this.elements;

    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos( x ), b = Math.sin( x );
    var c = Math.cos( y ), d = Math.sin( y );
    var e = Math.cos( z ), f = Math.sin( z );

    if ( euler.order === 'XYZ' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = - c * f;
      te[ 8 ] = d;

      te[ 1 ] = af + be * d;
      te[ 5 ] = ae - bf * d;
      te[ 9 ] = - b * c;

      te[ 2 ] = bf - ae * d;
      te[ 6 ] = be + af * d;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YXZ' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce + df * b;
      te[ 4 ] = de * b - cf;
      te[ 8 ] = a * d;

      te[ 1 ] = a * f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b;

      te[ 2 ] = cf * b - de;
      te[ 6 ] = df + ce * b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZXY' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce - df * b;
      te[ 4 ] = - a * f;
      te[ 8 ] = de + cf * b;

      te[ 1 ] = cf + de * b;
      te[ 5 ] = a * e;
      te[ 9 ] = df - ce * b;

      te[ 2 ] = - a * d;
      te[ 6 ] = b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZYX' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = be * d - af;
      te[ 8 ] = ae * d + bf;

      te[ 1 ] = c * f;
      te[ 5 ] = bf * d + ae;
      te[ 9 ] = af * d - be;

      te[ 2 ] = - d;
      te[ 6 ] = b * c;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YZX' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = bd - ac * f;
      te[ 8 ] = bc * f + ad;

      te[ 1 ] = f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b * e;

      te[ 2 ] = - d * e;
      te[ 6 ] = ad * f + bc;
      te[ 10 ] = ac - bd * f;

    } else if ( euler.order === 'XZY' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = - f;
      te[ 8 ] = d * e;

      te[ 1 ] = ac * f + bd;
      te[ 5 ] = a * e;
      te[ 9 ] = ad * f - bc;

      te[ 2 ] = bc * f - ad;
      te[ 6 ] = b * e;
      te[ 10 ] = bd * f + ac;

    }

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  setRotationFromQuaternion: function ( q ) {

    console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

    return this.makeRotationFromQuaternion( q );

  },

  makeRotationFromQuaternion: function ( q ) {

    var te = this.elements;

    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;

    te[ 0 ] = 1 - ( yy + zz );
    te[ 4 ] = xy - wz;
    te[ 8 ] = xz + wy;

    te[ 1 ] = xy + wz;
    te[ 5 ] = 1 - ( xx + zz );
    te[ 9 ] = yz - wx;

    te[ 2 ] = xz - wy;
    te[ 6 ] = yz + wx;
    te[ 10 ] = 1 - ( xx + yy );

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  lookAt: function () {

    var x = new THREE.Vector3();
    var y = new THREE.Vector3();
    var z = new THREE.Vector3();

    return function ( eye, target, up ) {

      var te = this.elements;

      z.subVectors( eye, target ).normalize();

      if ( z.length() === 0 ) {

        z.z = 1;

      }

      x.crossVectors( up, z ).normalize();

      if ( x.length() === 0 ) {

        z.x += 0.0001;
        x.crossVectors( up, z ).normalize();

      }

      y.crossVectors( z, x );


      te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
      te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
      te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

      return this;

    };

  }(),

  multiply: function ( m, n ) {

    if ( n !== undefined ) {

      console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
      return this.multiplyMatrices( m, n );

    }

    return this.multiplyMatrices( this, m );

  },

  multiplyMatrices: function ( a, b ) {

    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;

    var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    return this;

  },

  multiplyToArray: function ( a, b, r ) {

    var te = this.elements;

    this.multiplyMatrices( a, b );

    r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    return this;

  },

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
    return vector.applyProjection( this );

  },

  multiplyVector4: function ( vector ) {

    console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    return vector.applyMatrix4( this );

  },

  multiplyVector3Array: function ( a ) {

    console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    return this.applyToVector3Array( a );

  },

  applyToVector3Array: function () {

    var v1 = new THREE.Vector3();

    return function ( array, offset, length ) {

      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

        v1.x = array[ j ];
        v1.y = array[ j + 1 ];
        v1.z = array[ j + 2 ];

        v1.applyMatrix4( this );

        array[ j ]     = v1.x;
        array[ j + 1 ] = v1.y;
        array[ j + 2 ] = v1.z;

      }

      return array;

    };

  }(),

  rotateAxis: function ( v ) {

    console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

    v.transformDirection( this );

  },

  crossVector: function ( vector ) {

    console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    return vector.applyMatrix4( this );

  },

  determinant: function () {

    var te = this.elements;

    var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return (
      n41 * (
        + n14 * n23 * n32
         - n13 * n24 * n32
         - n14 * n22 * n33
         + n12 * n24 * n33
         + n13 * n22 * n34
         - n12 * n23 * n34
      ) +
      n42 * (
        + n11 * n23 * n34
         - n11 * n24 * n33
         + n14 * n21 * n33
         - n13 * n21 * n34
         + n13 * n24 * n31
         - n14 * n23 * n31
      ) +
      n43 * (
        + n11 * n24 * n32
         - n11 * n22 * n34
         - n14 * n21 * n32
         + n12 * n21 * n34
         + n14 * n22 * n31
         - n12 * n24 * n31
      ) +
      n44 * (
        - n13 * n22 * n31
         - n11 * n23 * n32
         + n11 * n22 * n33
         + n13 * n21 * n32
         - n12 * n21 * n33
         + n12 * n23 * n31
      )

    );

  },

  transpose: function () {

    var te = this.elements;
    var tmp;

    tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset     ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];
    array[ offset + 3 ] = te[ 3 ];

    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];
    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];

    array[ offset + 8 ]  = te[ 8 ];
    array[ offset + 9 ]  = te[ 9 ];
    array[ offset + 10 ] = te[ 10 ];
    array[ offset + 11 ] = te[ 11 ];

    array[ offset + 12 ] = te[ 12 ];
    array[ offset + 13 ] = te[ 13 ];
    array[ offset + 14 ] = te[ 14 ];
    array[ offset + 15 ] = te[ 15 ];

    return array;

  },

  getPosition: function () {

    var v1 = new THREE.Vector3();

    return function () {

      console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

      var te = this.elements;
      return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

    };

  }(),

  setPosition: function ( v ) {

    var te = this.elements;

    te[ 12 ] = v.x;
    te[ 13 ] = v.y;
    te[ 14 ] = v.z;

    return this;

  },

  getInverse: function ( m, throwOnInvertible ) {

    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements;
    var me = m.elements;

    var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
    var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
    var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
    var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

    te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
    te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
    te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
    te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
    te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
    te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
    te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
    te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
    te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
    te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
    te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
    te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

    var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

    if ( det == 0 ) {

      var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;
    }

    this.multiplyScalar( 1 / det );

    return this;

  },

  translate: function ( v ) {

    console.warn( 'THREE.Matrix4: .translate() has been removed.' );

  },

  rotateX: function ( angle ) {

    console.warn( 'THREE.Matrix4: .rotateX() has been removed.' );

  },

  rotateY: function ( angle ) {

    console.warn( 'THREE.Matrix4: .rotateY() has been removed.' );

  },

  rotateZ: function ( angle ) {

    console.warn( 'THREE.Matrix4: .rotateZ() has been removed.' );

  },

  rotateByAxis: function ( axis, angle ) {

    console.warn( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

  },

  scale: function ( v ) {

    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;

    te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    return this;

  },

  getMaxScaleOnAxis: function () {

    var te = this.elements;

    var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

  },

  makeTranslation: function ( x, y, z ) {

    this.set(

      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationX: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      1, 0,  0, 0,
      0, c, - s, 0,
      0, s,  c, 0,
      0, 0,  0, 1

    );

    return this;

  },

  makeRotationY: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

       c, 0, s, 0,
       0, 1, 0, 0,
      - s, 0, c, 0,
       0, 0, 0, 1

    );

    return this;

  },

  makeRotationZ: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      c, - s, 0, 0,
      s,  c, 0, 0,
      0,  0, 1, 0,
      0,  0, 0, 1

    );

    return this;

  },

  makeRotationAxis: function ( axis, angle ) {

    // Based on http://www.gamedev.net/reference/articles/article1199.asp

    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;

    this.set(

      tx * x + c, tx * y - s * z, tx * z + s * y, 0,
      tx * y + s * z, ty * y + c, ty * z - s * x, 0,
      tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
      0, 0, 0, 1

    );

     return this;

  },

  makeScale: function ( x, y, z ) {

    this.set(

      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1

    );

    return this;

  },

  compose: function ( position, quaternion, scale ) {

    this.makeRotationFromQuaternion( quaternion );
    this.scale( scale );
    this.setPosition( position );

    return this;

  },

  decompose: function () {

    var vector = new THREE.Vector3();
    var matrix = new THREE.Matrix4();

    return function ( position, quaternion, scale ) {

      var te = this.elements;

      var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
      var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
      var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if ( det < 0 ) {
        sx = - sx;
      }

      position.x = te[ 12 ];
      position.y = te[ 13 ];
      position.z = te[ 14 ];

      // scale the rotation part

      matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;

      matrix.elements[ 0 ] *= invSX;
      matrix.elements[ 1 ] *= invSX;
      matrix.elements[ 2 ] *= invSX;

      matrix.elements[ 4 ] *= invSY;
      matrix.elements[ 5 ] *= invSY;
      matrix.elements[ 6 ] *= invSY;

      matrix.elements[ 8 ] *= invSZ;
      matrix.elements[ 9 ] *= invSZ;
      matrix.elements[ 10 ] *= invSZ;

      quaternion.setFromRotationMatrix( matrix );

      scale.x = sx;
      scale.y = sy;
      scale.z = sz;

      return this;

    };

  }(),

  makeFrustum: function ( left, right, bottom, top, near, far ) {

    var te = this.elements;
    var x = 2 * near / ( right - left );
    var y = 2 * near / ( top - bottom );

    var a = ( right + left ) / ( right - left );
    var b = ( top + bottom ) / ( top - bottom );
    var c = - ( far + near ) / ( far - near );
    var d = - 2 * far * near / ( far - near );

    te[ 0 ] = x;  te[ 4 ] = 0;  te[ 8 ] = a;  te[ 12 ] = 0;
    te[ 1 ] = 0;  te[ 5 ] = y;  te[ 9 ] = b;  te[ 13 ] = 0;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = c; te[ 14 ] = d;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = - 1; te[ 15 ] = 0;

    return this;

  },

  makePerspective: function ( fov, aspect, near, far ) {

    var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
    var ymin = - ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

  },

  makeOrthographic: function ( left, right, top, bottom, near, far ) {

    var te = this.elements;
    var w = right - left;
    var h = top - bottom;
    var p = far - near;

    var x = ( right + left ) / w;
    var y = ( top + bottom ) / h;
    var z = ( far + near ) / p;

    te[ 0 ] = 2 / w;  te[ 4 ] = 0;  te[ 8 ] = 0;  te[ 12 ] = - x;
    te[ 1 ] = 0;  te[ 5 ] = 2 / h;  te[ 9 ] = 0;  te[ 13 ] = - y;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = - 2 / p; te[ 14 ] = - z;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = 0; te[ 15 ] = 1;

    return this;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
      te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
      te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
      te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
    ];

  },

  clone: function () {

    return new THREE.Matrix4().fromArray( this.elements );

  }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

  this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
  this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

  constructor: THREE.Ray,

  set: function ( origin, direction ) {

    this.origin.copy( origin );
    this.direction.copy( direction );

    return this;

  },

  copy: function ( ray ) {

    this.origin.copy( ray.origin );
    this.direction.copy( ray.direction );

    return this;

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  },

  recast: function () {

    var v1 = new THREE.Vector3();

    return function ( t ) {

      this.origin.copy( this.at( t, v1 ) );

      return this;

    };

  }(),

  closestPointToPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    result.subVectors( point, this.origin );
    var directionDistance = result.dot( this.direction );

    if ( directionDistance < 0 ) {

      return result.copy( this.origin );

    }

    return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

      // point behind the ray

      if ( directionDistance < 0 ) {

        return this.origin.distanceTo( point );

      }

      v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

      return v1.distanceTo( point );

    };

  }(),

  distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

    // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
    // It returns the min distance between the ray and the segment
    // defined by v0 and v1
    // It can also set two optional targets :
    // - The closest point on the ray
    // - The closest point on the segment

    var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
    var segDir = v1.clone().sub( v0 ).normalize();
    var segExtent = v0.distanceTo( v1 ) * 0.5;
    var diff = this.origin.clone().sub( segCenter );
    var a01 = - this.direction.dot( segDir );
    var b0 = diff.dot( this.direction );
    var b1 = - diff.dot( segDir );
    var c = diff.lengthSq();
    var det = Math.abs( 1 - a01 * a01 );
    var s0, s1, sqrDist, extDet;

    if ( det >= 0 ) {

      // The ray and segment are not parallel.

      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;

      if ( s0 >= 0 ) {

        if ( s1 >= - extDet ) {

          if ( s1 <= extDet ) {

            // region 0
            // Minimum at interior points of ray and segment.

            var invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

          } else {

            // region 1

            s1 = segExtent;
            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        } else {

          // region 5

          s1 = - segExtent;
          s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
          sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

        }

      } else {

        if ( s1 <= - extDet ) {

          // region 4

          s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
          s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
          sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

        } else if ( s1 <= extDet ) {

          // region 3

          s0 = 0;
          s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
          sqrDist = s1 * ( s1 + 2 * b1 ) + c;

        } else {

          // region 2

          s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
          s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
          sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

        }

      }

    } else {

      // Ray and segment are parallel.

      s1 = ( a01 > 0 ) ? - segExtent : segExtent;
      s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
      sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    }

    if ( optionalPointOnRay ) {

      optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

    }

    if ( optionalPointOnSegment ) {

      optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

    }

    return sqrDist;

  },

  isIntersectionSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) <= sphere.radius;

  },

  intersectSphere: function () {

    // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

    var v1 = new THREE.Vector3();

    return function ( sphere, optionalTarget ) {

      v1.subVectors( sphere.center, this.origin );

      var tca = v1.dot( this.direction );

      var d2 = v1.dot( v1 ) - tca * tca;

      var radius2 = sphere.radius * sphere.radius;

      if ( d2 > radius2 ) return null;

      var thc = Math.sqrt( radius2 - d2 );

      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;

      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;

      // test to see if both t0 and t1 are behind the ray - if so, return null
      if ( t0 < 0 && t1 < 0 ) return null;

      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if ( t0 < 0 ) return this.at( t1, optionalTarget );

      // else t0 is in front of the ray, so return the first collision point scaled by t0 
      return this.at( t0, optionalTarget );

    }

  }(),

  isIntersectionPlane: function ( plane ) {

    // check if the ray lies on the plane first

    var distToPoint = plane.distanceToPoint( this.origin );

    if ( distToPoint === 0 ) {

      return true;

    }

    var denominator = plane.normal.dot( this.direction );

    if ( denominator * distToPoint < 0 ) {

      return true;

    }

    // ray origin is behind the plane (and is pointing behind it)

    return false;

  },

  distanceToPlane: function ( plane ) {

    var denominator = plane.normal.dot( this.direction );
    if ( denominator == 0 ) {

      // line is coplanar, return origin
      if ( plane.distanceToPoint( this.origin ) == 0 ) {

        return 0;

      }

      // Null is preferable to undefined since undefined means.... it is undefined

      return null;

    }

    var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    // Return if the ray never intersects the plane

    return t >= 0 ? t :  null;

  },

  intersectPlane: function ( plane, optionalTarget ) {

    var t = this.distanceToPlane( plane );

    if ( t === null ) {

      return null;
    }

    return this.at( t, optionalTarget );

  },

  isIntersectionBox: function () {

    var v = new THREE.Vector3();

    return function ( box ) {

      return this.intersectBox( box, v ) !== null;

    };

  }(),

  intersectBox: function ( box , optionalTarget ) {

    // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

    var tmin,tmax,tymin,tymax,tzmin,tzmax;

    var invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z;

    var origin = this.origin;

    if ( invdirx >= 0 ) {

      tmin = ( box.min.x - origin.x ) * invdirx;
      tmax = ( box.max.x - origin.x ) * invdirx;

    } else {

      tmin = ( box.max.x - origin.x ) * invdirx;
      tmax = ( box.min.x - origin.x ) * invdirx;
    }

    if ( invdiry >= 0 ) {

      tymin = ( box.min.y - origin.y ) * invdiry;
      tymax = ( box.max.y - origin.y ) * invdiry;

    } else {

      tymin = ( box.max.y - origin.y ) * invdiry;
      tymax = ( box.min.y - origin.y ) * invdiry;
    }

    if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    if ( invdirz >= 0 ) {

      tzmin = ( box.min.z - origin.z ) * invdirz;
      tzmax = ( box.max.z - origin.z ) * invdirz;

    } else {

      tzmin = ( box.max.z - origin.z ) * invdirz;
      tzmax = ( box.min.z - origin.z ) * invdirz;
    }

    if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    //return point closest to the ray (positive side)

    if ( tmax < 0 ) return null;

    return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

  },

  intersectTriangle: function () {

    // Compute the offset origin, edges, and normal.
    var diff = new THREE.Vector3();
    var edge1 = new THREE.Vector3();
    var edge2 = new THREE.Vector3();
    var normal = new THREE.Vector3();

    return function ( a, b, c, backfaceCulling, optionalTarget ) {

      // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

      edge1.subVectors( b, a );
      edge2.subVectors( c, a );
      normal.crossVectors( edge1, edge2 );

      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot( normal );
      var sign;

      if ( DdN > 0 ) {

        if ( backfaceCulling ) return null;
        sign = 1;

      } else if ( DdN < 0 ) {

        sign = - 1;
        DdN = - DdN;

      } else {

        return null;

      }

      diff.subVectors( this.origin, a );
      var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

      // b1 < 0, no intersection
      if ( DdQxE2 < 0 ) {

        return null;

      }

      var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

      // b2 < 0, no intersection
      if ( DdE1xQ < 0 ) {

        return null;

      }

      // b1+b2 > 1, no intersection
      if ( DdQxE2 + DdE1xQ > DdN ) {

        return null;

      }

      // Line intersects triangle, check if ray does.
      var QdN = - sign * diff.dot( normal );

      // t < 0, no intersection
      if ( QdN < 0 ) {

        return null;

      }

      // Ray intersects triangle.
      return this.at( QdN / DdN, optionalTarget );

    };

  }(),

  applyMatrix4: function ( matrix4 ) {

    this.direction.add( this.origin ).applyMatrix4( matrix4 );
    this.origin.applyMatrix4( matrix4 );
    this.direction.sub( this.origin );
    this.direction.normalize();

    return this;
  },

  equals: function ( ray ) {

    return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  },

  clone: function () {

    return new THREE.Ray().copy( this );

  }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

  this.center = ( center !== undefined ) ? center : new THREE.Vector3();
  this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

  constructor: THREE.Sphere,

  set: function ( center, radius ) {

    this.center.copy( center );
    this.radius = radius;

    return this;
  },

  setFromPoints: function () {

    var box = new THREE.Box3();

    return function ( points, optionalCenter )  {

      var center = this.center;

      if ( optionalCenter !== undefined ) {

        center.copy( optionalCenter );

      } else {

        box.setFromPoints( points ).center( center );

      }

      var maxRadiusSq = 0;

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

      }

      this.radius = Math.sqrt( maxRadiusSq );

      return this;

    };

  }(),

  copy: function ( sphere ) {

    this.center.copy( sphere.center );
    this.radius = sphere.radius;

    return this;

  },

  empty: function () {

    return ( this.radius <= 0 );

  },

  containsPoint: function ( point ) {

    return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  },

  distanceToPoint: function ( point ) {

    return ( point.distanceTo( this.center ) - this.radius );

  },

  intersectsSphere: function ( sphere ) {

    var radiusSum = this.radius + sphere.radius;

    return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  },

  clampPoint: function ( point, optionalTarget ) {

    var deltaLengthSq = this.center.distanceToSquared( point );

    var result = optionalTarget || new THREE.Vector3();
    result.copy( point );

    if ( deltaLengthSq > ( this.radius * this.radius ) ) {

      result.sub( this.center ).normalize();
      result.multiplyScalar( this.radius ).add( this.center );

    }

    return result;

  },

  getBoundingBox: function ( optionalTarget ) {

    var box = optionalTarget || new THREE.Box3();

    box.set( this.center, this.center );
    box.expandByScalar( this.radius );

    return box;

  },

  applyMatrix4: function ( matrix ) {

    this.center.applyMatrix4( matrix );
    this.radius = this.radius * matrix.getMaxScaleOnAxis();

    return this;

  },

  translate: function ( offset ) {

    this.center.add( offset );

    return this;

  },

  equals: function ( sphere ) {

    return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  },

  clone: function () {

    return new THREE.Sphere().copy( this );

  }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

  this.planes = [

    ( p0 !== undefined ) ? p0 : new THREE.Plane(),
    ( p1 !== undefined ) ? p1 : new THREE.Plane(),
    ( p2 !== undefined ) ? p2 : new THREE.Plane(),
    ( p3 !== undefined ) ? p3 : new THREE.Plane(),
    ( p4 !== undefined ) ? p4 : new THREE.Plane(),
    ( p5 !== undefined ) ? p5 : new THREE.Plane()

  ];

};

THREE.Frustum.prototype = {

  constructor: THREE.Frustum,

  set: function ( p0, p1, p2, p3, p4, p5 ) {

    var planes = this.planes;

    planes[ 0 ].copy( p0 );
    planes[ 1 ].copy( p1 );
    planes[ 2 ].copy( p2 );
    planes[ 3 ].copy( p3 );
    planes[ 4 ].copy( p4 );
    planes[ 5 ].copy( p5 );

    return this;

  },

  copy: function ( frustum ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      planes[ i ].copy( frustum.planes[ i ] );

    }

    return this;

  },

  setFromMatrix: function ( m ) {

    var planes = this.planes;
    var me = m.elements;
    var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    return this;

  },

  intersectsObject: function () {

    var sphere = new THREE.Sphere();

    return function ( object ) {

      var geometry = object.geometry;

      if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

      sphere.copy( geometry.boundingSphere );
      sphere.applyMatrix4( object.matrixWorld );

      return this.intersectsSphere( sphere );

    };

  }(),

  intersectsSphere: function ( sphere ) {

    var planes = this.planes;
    var center = sphere.center;
    var negRadius = - sphere.radius;

    for ( var i = 0; i < 6; i ++ ) {

      var distance = planes[ i ].distanceToPoint( center );

      if ( distance < negRadius ) {

        return false;

      }

    }

    return true;

  },

  intersectsBox: function () {

    var p1 = new THREE.Vector3(),
      p2 = new THREE.Vector3();

    return function ( box ) {

      var planes = this.planes;

      for ( var i = 0; i < 6 ; i ++ ) {

        var plane = planes[ i ];

        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        var d1 = plane.distanceToPoint( p1 );
        var d2 = plane.distanceToPoint( p2 );

        // if both outside plane, no intersection

        if ( d1 < 0 && d2 < 0 ) {

          return false;

        }
      }

      return true;
    };

  }(),


  containsPoint: function ( point ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      if ( planes[ i ].distanceToPoint( point ) < 0 ) {

        return false;

      }

    }

    return true;

  },

  clone: function () {

    return new THREE.Frustum().copy( this );

  }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

  this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
  this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

  constructor: THREE.Plane,

  set: function ( normal, constant ) {

    this.normal.copy( normal );
    this.constant = constant;

    return this;

  },

  setComponents: function ( x, y, z, w ) {

    this.normal.set( x, y, z );
    this.constant = w;

    return this;

  },

  setFromNormalAndCoplanarPoint: function ( normal, point ) {

    this.normal.copy( normal );
    this.constant = - point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

    return this;

  },

  setFromCoplanarPoints: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function ( a, b, c ) {

      var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint( normal, a );

      return this;

    };

  }(),


  copy: function ( plane ) {

    this.normal.copy( plane.normal );
    this.constant = plane.constant;

    return this;

  },

  normalize: function () {

    // Note: will lead to a divide by zero if the plane is invalid.

    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar( inverseNormalLength );
    this.constant *= inverseNormalLength;

    return this;

  },

  negate: function () {

    this.constant *= - 1;
    this.normal.negate();

    return this;

  },

  distanceToPoint: function ( point ) {

    return this.normal.dot( point ) + this.constant;

  },

  distanceToSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) - sphere.radius;

  },

  projectPoint: function ( point, optionalTarget ) {

    return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

  },

  orthoPoint: function ( point, optionalTarget ) {

    var perpendicularMagnitude = this.distanceToPoint( point );

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

  },

  isIntersectionLine: function ( line ) {

    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    var startSign = this.distanceToPoint( line.start );
    var endSign = this.distanceToPoint( line.end );

    return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  },

  intersectLine: function () {

    var v1 = new THREE.Vector3();

    return function ( line, optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      var direction = line.delta( v1 );

      var denominator = this.normal.dot( direction );

      if ( denominator == 0 ) {

        // line is coplanar, return origin
        if ( this.distanceToPoint( line.start ) == 0 ) {

          return result.copy( line.start );

        }

        // Unsure if this is the correct method to handle this case.
        return undefined;

      }

      var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

      if ( t < 0 || t > 1 ) {

        return undefined;

      }

      return result.copy( direction ).multiplyScalar( t ).add( line.start );

    };

  }(),


  coplanarPoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( - this.constant );

  },

  applyMatrix4: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var m1 = new THREE.Matrix3();

    return function ( matrix, optionalNormalMatrix ) {

      // compute new normal based on theory here:
      // http://www.songho.ca/opengl/gl_normaltransform.html
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
      var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

      var newCoplanarPoint = this.coplanarPoint( v2 );
      newCoplanarPoint.applyMatrix4( matrix );

      this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.constant = this.constant - offset.dot( this.normal );

    return this;

  },

  equals: function ( plane ) {

    return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

  },

  clone: function () {

    return new THREE.Plane().copy( this );

  }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

  generateUUID: function () {

    // http://www.broofa.com/Tools/Math.uuid.htm

    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    var uuid = new Array( 36 );
    var rnd = 0, r;

    return function () {

      for ( var i = 0; i < 36; i ++ ) {

        if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

          uuid[ i ] = '-';

        } else if ( i == 14 ) {

          uuid[ i ] = '4';

        } else {

          if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
          r = rnd & 0xf;
          rnd = rnd >> 4;
          uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

        }
      }

      return uuid.join( '' );

    };

  }(),

  // Clamp value to range <a, b>

  clamp: function ( x, a, b ) {

    return ( x < a ) ? a : ( ( x > b ) ? b : x );

  },

  // Clamp value to range <a, inf)

  clampBottom: function ( x, a ) {

    return x < a ? a : x;

  },

  // Linear mapping from range <a1, a2> to range <b1, b2>

  mapLinear: function ( x, a1, a2, b1, b2 ) {

    return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  },

  // http://en.wikipedia.org/wiki/Smoothstep

  smoothstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * ( 3 - 2 * x );

  },

  smootherstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  },

  // Random float from <0, 1> with 16 bits of randomness
  // (standard Math.random() creates repetitive patterns when applied over larger space)

  random16: function () {

    return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

  },

  // Random integer from <low, high> interval

  randInt: function ( low, high ) {

    return low + Math.floor( Math.random() * ( high - low + 1 ) );

  },

  // Random float from <low, high> interval

  randFloat: function ( low, high ) {

    return low + Math.random() * ( high - low );

  },

  // Random float from <-range/2, range/2> interval

  randFloatSpread: function ( range ) {

    return range * ( 0.5 - Math.random() );

  },

  degToRad: function () {

    var degreeToRadiansFactor = Math.PI / 180;

    return function ( degrees ) {

      return degrees * degreeToRadiansFactor;

    };

  }(),

  radToDeg: function () {

    var radianToDegreesFactor = 180 / Math.PI;

    return function ( radians ) {

      return radians * radianToDegreesFactor;

    };

  }(),

  isPowerOfTwo: function ( value ) {

    return ( value & ( value - 1 ) ) === 0 && value !== 0;

  }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

  this.points = points;

  var c = [], v3 = { x: 0, y: 0, z: 0 },
  point, intPoint, weight, w2, w3,
  pa, pb, pc, pd;

  this.initFromArray = function ( a ) {

    this.points = [];

    for ( var i = 0; i < a.length; i ++ ) {

      this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    }

  };

  this.getPoint = function ( k ) {

    point = ( this.points.length - 1 ) * k;
    intPoint = Math.floor( point );
    weight = point - intPoint;

    c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    c[ 1 ] = intPoint;
    c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    pa = this.points[ c[ 0 ] ];
    pb = this.points[ c[ 1 ] ];
    pc = this.points[ c[ 2 ] ];
    pd = this.points[ c[ 3 ] ];

    w2 = weight * weight;
    w3 = weight * w2;

    v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    return v3;

  };

  this.getControlPointsArray = function () {

    var i, p, l = this.points.length,
      coords = [];

    for ( i = 0; i < l; i ++ ) {

      p = this.points[ i ];
      coords[ i ] = [ p.x, p.y, p.z ];

    }

    return coords;

  };

  // approximate length by summing linear segments

  this.getLength = function ( nSubDivisions ) {

    var i, index, nSamples, position,
      point = 0, intPoint = 0, oldIntPoint = 0,
      oldPosition = new THREE.Vector3(),
      tmpVec = new THREE.Vector3(),
      chunkLengths = [],
      totalLength = 0;

    // first point has 0 length

    chunkLengths[ 0 ] = 0;

    if ( ! nSubDivisions ) nSubDivisions = 100;

    nSamples = this.points.length * nSubDivisions;

    oldPosition.copy( this.points[ 0 ] );

    for ( i = 1; i < nSamples; i ++ ) {

      index = i / nSamples;

      position = this.getPoint( index );
      tmpVec.copy( position );

      totalLength += tmpVec.distanceTo( oldPosition );

      oldPosition.copy( position );

      point = ( this.points.length - 1 ) * index;
      intPoint = Math.floor( point );

      if ( intPoint != oldIntPoint ) {

        chunkLengths[ intPoint ] = totalLength;
        oldIntPoint = intPoint;

      }

    }

    // last point ends with total length

    chunkLengths[ chunkLengths.length ] = totalLength;

    return { chunks: chunkLengths, total: totalLength };

  };

  this.reparametrizeByArcLength = function ( samplingCoef ) {

    var i, j,
      index, indexCurrent, indexNext,
      linearDistance, realDistance,
      sampling, position,
      newpoints = [],
      tmpVec = new THREE.Vector3(),
      sl = this.getLength();

    newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    for ( i = 1; i < this.points.length; i ++ ) {

      //tmpVec.copy( this.points[ i - 1 ] );
      //linearDistance = tmpVec.distanceTo( this.points[ i ] );

      realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

      sampling = Math.ceil( samplingCoef * realDistance / sl.total );

      indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
      indexNext = i / ( this.points.length - 1 );

      for ( j = 1; j < sampling - 1; j ++ ) {

        index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

        position = this.getPoint( index );
        newpoints.push( tmpVec.copy( position ).clone() );

      }

      newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    }

    this.points = newpoints;

  };

  // Catmull-Rom

  function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    var v0 = ( p2 - p0 ) * 0.5,
      v1 = ( p3 - p1 ) * 0.5;

    return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  };

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

  this.a = ( a !== undefined ) ? a : new THREE.Vector3();
  this.b = ( b !== undefined ) ? b : new THREE.Vector3();
  this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

  var v0 = new THREE.Vector3();

  return function ( a, b, c, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    result.subVectors( c, b );
    v0.subVectors( a, b );
    result.cross( v0 );

    var resultLengthSq = result.lengthSq();
    if ( resultLengthSq > 0 ) {

      return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    }

    return result.set( 0, 0, 0 );

  };

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

  var v0 = new THREE.Vector3();
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function ( point, a, b, c, optionalTarget ) {

    v0.subVectors( c, a );
    v1.subVectors( b, a );
    v2.subVectors( point, a );

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var denom = ( dot00 * dot11 - dot01 * dot01 );

    var result = optionalTarget || new THREE.Vector3();

    // colinear or singular triangle
    if ( denom == 0 ) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return result.set( - 2, - 1, - 1 );
    }

    var invDenom = 1 / denom;
    var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    // barycoordinates must always sum to 1
    return result.set( 1 - u - v, v, u );

  };

}();

THREE.Triangle.containsPoint = function () {

  var v1 = new THREE.Vector3();

  return function ( point, a, b, c ) {

    var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

    return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

  };

}();

THREE.Triangle.prototype = {

  constructor: THREE.Triangle,

  set: function ( a, b, c ) {

    this.a.copy( a );
    this.b.copy( b );
    this.c.copy( c );

    return this;

  },

  setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    this.a.copy( points[ i0 ] );
    this.b.copy( points[ i1 ] );
    this.c.copy( points[ i2 ] );

    return this;

  },

  copy: function ( triangle ) {

    this.a.copy( triangle.a );
    this.b.copy( triangle.b );
    this.c.copy( triangle.c );

    return this;

  },

  area: function () {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();

    return function () {

      v0.subVectors( this.c, this.b );
      v1.subVectors( this.a, this.b );

      return v0.cross( v1 ).length() * 0.5;

    };

  }(),

  midpoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  },

  normal: function ( optionalTarget ) {

    return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

  },

  plane: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Plane();

    return result.setFromCoplanarPoints( this.a, this.b, this.c );

  },

  barycoordFromPoint: function ( point, optionalTarget ) {

    return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

  },

  containsPoint: function ( point ) {

    return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

  },

  equals: function ( triangle ) {

    return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  },

  clone: function () {

    return new THREE.Triangle().copy( this );

  }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

  this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;

  this.running = false;

};

THREE.Clock.prototype = {

  constructor: THREE.Clock,

  start: function () {

    this.startTime = self.performance !== undefined && self.performance.now !== undefined
           ? self.performance.now()
           : Date.now();

    this.oldTime = this.startTime;
    this.running = true;
  },

  stop: function () {

    this.getElapsedTime();
    this.running = false;

  },

  getElapsedTime: function () {

    this.getDelta();
    return this.elapsedTime;

  },

  getDelta: function () {

    var diff = 0;

    if ( this.autoStart && ! this.running ) {

      this.start();

    }

    if ( this.running ) {

      var newTime = self.performance !== undefined && self.performance.now !== undefined
           ? self.performance.now()
           : Date.now();

      diff = 0.001 * ( newTime - this.oldTime );
      this.oldTime = newTime;

      this.elapsedTime += diff;

    }

    return diff;

  }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

  constructor: THREE.EventDispatcher,

  apply: function ( object ) {

    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

  },

  addEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) this._listeners = {};

    var listeners = this._listeners;

    if ( listeners[ type ] === undefined ) {

      listeners[ type ] = [];

    }

    if ( listeners[ type ].indexOf( listener ) === - 1 ) {

      listeners[ type ].push( listener );

    }

  },

  hasEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return false;

    var listeners = this._listeners;

    if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

      return true;

    }

    return false;

  },

  removeEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ type ];

    if ( listenerArray !== undefined ) {

      var index = listenerArray.indexOf( listener );

      if ( index !== - 1 ) {

        listenerArray.splice( index, 1 );

      }

    }

  },

  dispatchEvent: function ( event ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ event.type ];

    if ( listenerArray !== undefined ) {

      event.target = this;

      var array = [];
      var length = listenerArray.length;

      for ( var i = 0; i < length; i ++ ) {

        array[ i ] = listenerArray[ i ];

      }

      for ( var i = 0; i < length; i ++ ) {

        array[ i ].call( this, event );

      }

    }

  }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

  THREE.Raycaster = function ( origin, direction, near, far ) {

    this.ray = new THREE.Ray( origin, direction );
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
      Sprite: {},
      Mesh: {},
      PointCloud: { threshold: 1 },
      LOD: {},
      Line: {}
    };

  };

  var descSort = function ( a, b ) {

    return a.distance - b.distance;

  };

  var intersectObject = function ( object, raycaster, intersects, recursive ) {

    object.raycast( raycaster, intersects );

    if ( recursive === true ) {

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        intersectObject( children[ i ], raycaster, intersects, true );

      }

    }

  };

  //

  THREE.Raycaster.prototype = {

    constructor: THREE.Raycaster,

    precision: 0.0001,
    linePrecision: 1,

    set: function ( origin, direction ) {

      this.ray.set( origin, direction );
      // direction is assumed to be normalized (for accurate distance calculations)

    },

    intersectObject: function ( object, recursive ) {

      var intersects = [];

      intersectObject( object, this, intersects, recursive );

      intersects.sort( descSort );

      return intersects;

    },

    intersectObjects: function ( objects, recursive ) {

      var intersects = [];

      if ( objects instanceof Array === false ) {

        console.log( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
        return intersects;

      }

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        intersectObject( objects[ i ], this, intersects, recursive );

      }

      intersects.sort( descSort );

      return intersects;

    }

  };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

  Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Object3D';

  this.parent = undefined;
  this.children = [];

  this.up = THREE.Object3D.DefaultUp.clone();

  var scope = this;

  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3( 1, 1, 1 );

  var onRotationChange = function () {
    quaternion.setFromEuler( rotation, false );
  };

  var onQuaternionChange = function () {
    rotation.setFromQuaternion( quaternion, undefined, false );
  };

  rotation.onChange( onRotationChange );
  quaternion.onChange( onQuaternionChange );

  Object.defineProperties( this, {
    position: {
      enumerable: true,
      value: position
    },
    rotation: {
      enumerable: true,
      value: rotation
    },
    quaternion: {
      enumerable: true,
      value: quaternion
    },
    scale: {
      enumerable: true,
      value: scale
    },
  } );

  this.renderDepth = null;

  this.rotationAutoUpdate = true;

  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();

  this.matrixAutoUpdate = true;
  this.matrixWorldNeedsUpdate = false;

  this.visible = true;

  this.castShadow = false;
  this.receiveShadow = false;

  this.frustumCulled = true;

  this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

THREE.Object3D.prototype = {

  constructor: THREE.Object3D,

  get eulerOrder () {

    console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

    return this.rotation.order;

  },

  set eulerOrder ( value ) {

    console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

    this.rotation.order = value;

  },

  get useQuaternion () {

    console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  },

  set useQuaternion ( value ) {

    console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  },

  applyMatrix: function ( matrix ) {

    this.matrix.multiplyMatrices( matrix, this.matrix );

    this.matrix.decompose( this.position, this.quaternion, this.scale );

  },

  setRotationFromAxisAngle: function ( axis, angle ) {

    // assumes axis is normalized

    this.quaternion.setFromAxisAngle( axis, angle );

  },

  setRotationFromEuler: function ( euler ) {

    this.quaternion.setFromEuler( euler, true );

  },

  setRotationFromMatrix: function ( m ) {

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    this.quaternion.setFromRotationMatrix( m );

  },

  setRotationFromQuaternion: function ( q ) {

    // assumes q is normalized

    this.quaternion.copy( q );

  },

  rotateOnAxis: function () {

    // rotate object on axis in object space
    // axis is assumed to be normalized

    var q1 = new THREE.Quaternion();

    return function ( axis, angle ) {

      q1.setFromAxisAngle( axis, angle );

      this.quaternion.multiply( q1 );

      return this;

    }

  }(),

  rotateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  translateOnAxis: function () {

    // translate object by distance along axis in object space
    // axis is assumed to be normalized

    var v1 = new THREE.Vector3();

    return function ( axis, distance ) {

      v1.copy( axis ).applyQuaternion( this.quaternion );

      this.position.add( v1.multiplyScalar( distance ) );

      return this;

    }

  }(),

  translate: function ( distance, axis ) {

    console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
    return this.translateOnAxis( axis, distance );

  },

  translateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  localToWorld: function ( vector ) {

    return vector.applyMatrix4( this.matrixWorld );

  },

  worldToLocal: function () {

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    };

  }(),

  lookAt: function () {

    // This routine does not support objects with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      m1.lookAt( vector, this.position, this.up );

      this.quaternion.setFromRotationMatrix( m1 );

    };

  }(),

  add: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i++ ) {

        this.add( arguments[ i ] );

      }

      return this;

    };

    if ( object === this ) {

      console.error( "THREE.Object3D.add:", object, "can't be added as a child of itself." );
      return this;

    }

    if ( object instanceof THREE.Object3D ) {

      if ( object.parent !== undefined ) {

        object.parent.remove( object );

      }

      object.parent = this;
      object.dispatchEvent( { type: 'added' } );

      this.children.push( object );

    } else {

      console.error( "THREE.Object3D.add:", object, "is not an instance of THREE.Object3D." );

    }

    return this;

  },

  remove: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i++ ) {

        this.remove( arguments[ i ] );

      }

    };

    var index = this.children.indexOf( object );

    if ( index !== - 1 ) {

      object.parent = undefined;

      object.dispatchEvent( { type: 'removed' } );

      this.children.splice( index, 1 );

    }

  },

  getChildByName: function ( name, recursive ) {

    console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
    return this.getObjectByName( name, recursive );

  },

  getObjectById: function ( id, recursive ) {

    if ( this.id === id ) return this;

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      var child = this.children[ i ];
      var object = child.getObjectById( id, recursive );

      if ( object !== undefined ) {

        return object;

      }

    }

    return undefined;

  },

  getObjectByName: function ( name, recursive ) {

    if ( this.name === name ) return this;

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      var child = this.children[ i ];
      var object = child.getObjectByName( name, recursive );

      if ( object !== undefined ) {

        return object;

      }

    }

    return undefined;

  },

  getWorldPosition: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.updateMatrixWorld( true );

    return result.setFromMatrixPosition( this.matrixWorld );

  },

  getWorldQuaternion: function () {

    var position = new THREE.Vector3();
    var scale = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Quaternion();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, result, scale );

      return result;

    }

  }(),

  getWorldRotation: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Euler();

      this.getWorldQuaternion( quaternion );

      return result.setFromQuaternion( quaternion, this.rotation.order, false );

    }

  }(),

  getWorldScale: function () {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, quaternion, result );

      return result;

    }

  }(),

  getWorldDirection: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.getWorldQuaternion( quaternion );

      return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    }

  }(),

  raycast: function () {},

  traverse: function ( callback ) {

    callback( this );

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].traverse( callback );

    }

  },

  traverseVisible: function ( callback ) {

    if ( this.visible === false ) return;

    callback( this );

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].traverseVisible( callback );

    }

  },

  updateMatrix: function () {

    this.matrix.compose( this.position, this.quaternion, this.scale );

    this.matrixWorldNeedsUpdate = true;

  },

  updateMatrixWorld: function ( force ) {

    if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    if ( this.matrixWorldNeedsUpdate === true || force === true ) {

      if ( this.parent === undefined ) {

        this.matrixWorld.copy( this.matrix );

      } else {

        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

      }

      this.matrixWorldNeedsUpdate = false;

      force = true;

    }

    // update children

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].updateMatrixWorld( force );

    }

  },

  toJSON: function () {

    var output = {
      metadata: {
        version: 4.3,
        type: 'Object',
        generator: 'ObjectExporter'
      }
    };

    //

    var geometries = {};

    var parseGeometry = function ( geometry ) {

      if ( output.geometries === undefined ) {

        output.geometries = [];

      }

      if ( geometries[ geometry.uuid ] === undefined ) {

        var json = geometry.toJSON();

        delete json.metadata;

        geometries[ geometry.uuid ] = json;

        output.geometries.push( json );

      }

      return geometry.uuid;

    };

    //

    var materials = {};

    var parseMaterial = function ( material ) {

      if ( output.materials === undefined ) {

        output.materials = [];

      }

      if ( materials[ material.uuid ] === undefined ) {

        var json = material.toJSON();

        delete json.metadata;

        materials[ material.uuid ] = json;

        output.materials.push( json );

      }

      return material.uuid;

    };

    //

    var parseObject = function ( object ) {

      var data = {};

      data.uuid = object.uuid;
      data.type = object.type;

      if ( object.name !== '' ) data.name = object.name;
      if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
      if ( object.visible !== true ) data.visible = object.visible;

      if ( object instanceof THREE.PerspectiveCamera ) {

        data.fov = object.fov;
        data.aspect = object.aspect;
        data.near = object.near;
        data.far = object.far;

      } else if ( object instanceof THREE.OrthographicCamera ) {

        data.left = object.left;
        data.right = object.right;
        data.top = object.top;
        data.bottom = object.bottom;
        data.near = object.near;
        data.far = object.far;

      } else if ( object instanceof THREE.AmbientLight ) {

        data.color = object.color.getHex();

      } else if ( object instanceof THREE.DirectionalLight ) {

        data.color = object.color.getHex();
        data.intensity = object.intensity;

      } else if ( object instanceof THREE.PointLight ) {

        data.color = object.color.getHex();
        data.intensity = object.intensity;
        data.distance = object.distance;

      } else if ( object instanceof THREE.SpotLight ) {

        data.color = object.color.getHex();
        data.intensity = object.intensity;
        data.distance = object.distance;
        data.angle = object.angle;
        data.exponent = object.exponent;

      } else if ( object instanceof THREE.HemisphereLight ) {

        data.color = object.color.getHex();
        data.groundColor = object.groundColor.getHex();

      } else if ( object instanceof THREE.Mesh ) {

        data.geometry = parseGeometry( object.geometry );
        data.material = parseMaterial( object.material );

      } else if ( object instanceof THREE.Line ) {

        data.geometry = parseGeometry( object.geometry );
        data.material = parseMaterial( object.material );

      } else if ( object instanceof THREE.Sprite ) {

        data.material = parseMaterial( object.material );

      }

      data.matrix = object.matrix.toArray();

      if ( object.children.length > 0 ) {

        data.children = [];

        for ( var i = 0; i < object.children.length; i ++ ) {

          data.children.push( parseObject( object.children[ i ] ) );

        }

      }

      return data;

    }

    output.object = parseObject( this );

    return output;

  },

  clone: function ( object, recursive ) {

    if ( object === undefined ) object = new THREE.Object3D();
    if ( recursive === undefined ) recursive = true;

    object.name = this.name;

    object.up.copy( this.up );

    object.position.copy( this.position );
    object.quaternion.copy( this.quaternion );
    object.scale.copy( this.scale );

    object.renderDepth = this.renderDepth;

    object.rotationAutoUpdate = this.rotationAutoUpdate;

    object.matrix.copy( this.matrix );
    object.matrixWorld.copy( this.matrixWorld );

    object.matrixAutoUpdate = this.matrixAutoUpdate;
    object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

    object.visible = this.visible;

    object.castShadow = this.castShadow;
    object.receiveShadow = this.receiveShadow;

    object.frustumCulled = this.frustumCulled;

    object.userData = JSON.parse( JSON.stringify( this.userData ) );

    if ( recursive === true ) {

      for ( var i = 0; i < this.children.length; i ++ ) {

        var child = this.children[ i ];
        object.add( child.clone() );

      }

    }

    return object;

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Projector.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Projector = function () {

  console.warn( 'THREE.Projector has been moved to /examples/renderers/Projector.js.' );

  this.projectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    vector.project( camera );

  };

  this.unprojectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    vector.unproject( camera );

  };

  this.pickingRay = function ( vector, camera ) {

    console.error( 'THREE.Projector: .pickingRay() has been removed.' );

  };

};

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

  this.a = a;
  this.b = b;
  this.c = c;

  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
  this.vertexNormals = normal instanceof Array ? normal : [];

  this.color = color instanceof THREE.Color ? color : new THREE.Color();
  this.vertexColors = color instanceof Array ? color : [];

  this.vertexTangents = [];

  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

  constructor: THREE.Face3,

  clone: function () {

    var face = new THREE.Face3( this.a, this.b, this.c );

    face.normal.copy( this.normal );
    face.color.copy( this.color );

    face.materialIndex = this.materialIndex;

    for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

      face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

    }

    for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

      face.vertexColors[ i ] = this.vertexColors[ i ].clone();

    }

    for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

      face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

    }

    return face;

  }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

  console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
  return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

  this.array = array;
  this.itemSize = itemSize;

  this.needsUpdate = false;

};

THREE.BufferAttribute.prototype = {

  constructor: THREE.BufferAttribute,

  get length () {

    return this.array.length;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

  },

  set: function ( value ) {

    this.array.set( value );

    return this;

  },

  setX: function ( index, x ) {

    this.array[ index * this.itemSize ] = x;

    return this;

  },

  setY: function ( index, y ) {

    this.array[ index * this.itemSize + 1 ] = y;

    return this;

  },

  setZ: function ( index, z ) {

    this.array[ index * this.itemSize + 2 ] = z;

    return this;

  },

  setXY: function ( index, x, y ) {

    index *= this.itemSize;

    this.array[ index     ] = x;
    this.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index *= this.itemSize;

    this.array[ index     ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index *= this.itemSize;

    this.array[ index     ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;
    this.array[ index + 3 ] = w;

    return this;

  },

  clone: function () {

    return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

  }

};

//

THREE.Int8Attribute = function ( data, itemSize ) {

  console.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8Attribute = function ( data, itemSize ) {

  console.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8ClampedAttribute = function ( data, itemSize ) {

  console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );


};

THREE.Int16Attribute = function ( data, itemSize ) {

  console.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint16Attribute = function ( data, itemSize ) {

  console.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );

};

THREE.Int32Attribute = function ( data, itemSize ) {

  console.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint32Attribute = function ( data, itemSize ) {

  console.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float32Attribute = function ( data, itemSize ) {

  console.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float64Attribute = function ( data, itemSize ) {

  console.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
  return new THREE.BufferAttribute( data, itemSize );

};

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'BufferGeometry';

  this.attributes = {};
  this.attributesKeys = [];

  this.drawcalls = [];
  this.offsets = this.drawcalls; // backwards compatibility

  this.boundingBox = null;
  this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

  constructor: THREE.BufferGeometry,

  addAttribute: function ( name, attribute ) {

    if ( attribute instanceof THREE.BufferAttribute === false ) {

      console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

      this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

      return;

    }

    this.attributes[ name ] = attribute;
    this.attributesKeys = Object.keys( this.attributes );

  },

  getAttribute: function ( name ) {

    return this.attributes[ name ];

  },

  addDrawCall: function ( start, count, indexOffset ) {

    this.drawcalls.push( {

      start: start,
      count: count,
      index: indexOffset !== undefined ? indexOffset : 0

    } );

  },

  applyMatrix: function ( matrix ) {

    var position = this.attributes.position;

    if ( position !== undefined ) {

      matrix.applyToVector3Array( position.array );
      position.needsUpdate = true;

    }

    var normal = this.attributes.normal;

    if ( normal !== undefined ) {

      var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

      normalMatrix.applyToVector3Array( normal.array );
      normal.needsUpdate = true;

    }

  },

  center: function () {

    // TODO

  },

  fromGeometry: function ( geometry, settings ) {

    settings = settings || { 'vertexColors': THREE.NoColors };

    var vertices = geometry.vertices;
    var faces = geometry.faces;
    var faceVertexUvs = geometry.faceVertexUvs;
    var vertexColors = settings.vertexColors;
    var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
    var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;

    var positions = new Float32Array( faces.length * 3 * 3 );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

    var normals = new Float32Array( faces.length * 3 * 3 );
    this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

    if ( vertexColors !== THREE.NoColors ) {

      var colors = new Float32Array( faces.length * 3 * 3 );
      this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

    }

    if ( hasFaceVertexUv === true ) {

      var uvs = new Float32Array( faces.length * 3 * 2 );
      this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

    }

    for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {

      var face = faces[ i ];

      var a = vertices[ face.a ];
      var b = vertices[ face.b ];
      var c = vertices[ face.c ];

      positions[ i3     ] = a.x;
      positions[ i3 + 1 ] = a.y;
      positions[ i3 + 2 ] = a.z;

      positions[ i3 + 3 ] = b.x;
      positions[ i3 + 4 ] = b.y;
      positions[ i3 + 5 ] = b.z;

      positions[ i3 + 6 ] = c.x;
      positions[ i3 + 7 ] = c.y;
      positions[ i3 + 8 ] = c.z;

      if ( hasFaceVertexNormals === true ) {

        var na = face.vertexNormals[ 0 ];
        var nb = face.vertexNormals[ 1 ];
        var nc = face.vertexNormals[ 2 ];

        normals[ i3     ] = na.x;
        normals[ i3 + 1 ] = na.y;
        normals[ i3 + 2 ] = na.z;

        normals[ i3 + 3 ] = nb.x;
        normals[ i3 + 4 ] = nb.y;
        normals[ i3 + 5 ] = nb.z;

        normals[ i3 + 6 ] = nc.x;
        normals[ i3 + 7 ] = nc.y;
        normals[ i3 + 8 ] = nc.z;

      } else {

        var n = face.normal;

        normals[ i3     ] = n.x;
        normals[ i3 + 1 ] = n.y;
        normals[ i3 + 2 ] = n.z;

        normals[ i3 + 3 ] = n.x;
        normals[ i3 + 4 ] = n.y;
        normals[ i3 + 5 ] = n.z;

        normals[ i3 + 6 ] = n.x;
        normals[ i3 + 7 ] = n.y;
        normals[ i3 + 8 ] = n.z;

      }

      if ( vertexColors === THREE.FaceColors ) {

        var fc = face.color;

        colors[ i3     ] = fc.r;
        colors[ i3 + 1 ] = fc.g;
        colors[ i3 + 2 ] = fc.b;

        colors[ i3 + 3 ] = fc.r;
        colors[ i3 + 4 ] = fc.g;
        colors[ i3 + 5 ] = fc.b;

        colors[ i3 + 6 ] = fc.r;
        colors[ i3 + 7 ] = fc.g;
        colors[ i3 + 8 ] = fc.b;

      } else if ( vertexColors === THREE.VertexColors ) {

        var vca = face.vertexColors[ 0 ];
        var vcb = face.vertexColors[ 1 ];
        var vcc = face.vertexColors[ 2 ];

        colors[ i3     ] = vca.r;
        colors[ i3 + 1 ] = vca.g;
        colors[ i3 + 2 ] = vca.b;

        colors[ i3 + 3 ] = vcb.r;
        colors[ i3 + 4 ] = vcb.g;
        colors[ i3 + 5 ] = vcb.b;

        colors[ i3 + 6 ] = vcc.r;
        colors[ i3 + 7 ] = vcc.g;
        colors[ i3 + 8 ] = vcc.b;

      }

      if ( hasFaceVertexUv === true ) {

        var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
        var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
        var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

        uvs[ i2     ] = uva.x;
        uvs[ i2 + 1 ] = uva.y;

        uvs[ i2 + 2 ] = uvb.x;
        uvs[ i2 + 3 ] = uvb.y;

        uvs[ i2 + 4 ] = uvc.x;
        uvs[ i2 + 5 ] = uvc.y;

      }

    }

    this.computeBoundingSphere()

    return this;

  },

  computeBoundingBox: function () {

    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingBox === null ) {

        this.boundingBox = new THREE.Box3();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        var bb = this.boundingBox;
        bb.makeEmpty();

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
          bb.expandByPoint( vector );

        }

      }

      if ( positions === undefined || positions.length === 0 ) {

        this.boundingBox.min.set( 0, 0, 0 );
        this.boundingBox.max.set( 0, 0, 0 );

      }

      if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

        console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );

      }

    }

  }(),

  computeBoundingSphere: function () {

    var box = new THREE.Box3();
    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingSphere === null ) {

        this.boundingSphere = new THREE.Sphere();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        box.makeEmpty();

        var center = this.boundingSphere.center;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
          box.expandByPoint( vector );

        }

        box.center( center );

        // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

        var maxRadiusSq = 0;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
          maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

        }

        this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

        if ( isNaN( this.boundingSphere.radius ) ) {

          console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

        }

      }

    }

  }(),

  computeFaceNormals: function () {

    // backwards compatibility

  },

  computeVertexNormals: function () {

    var attributes = this.attributes;

    if ( attributes.position ) {

      var positions = attributes.position.array;

      if ( attributes.normal === undefined ) {

        this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

      } else {

        // reset existing normals to zero

        var normals = attributes.normal.array;

        for ( var i = 0, il = normals.length; i < il; i ++ ) {

          normals[ i ] = 0;

        }

      }

      var normals = attributes.normal.array;

      var vA, vB, vC,

      pA = new THREE.Vector3(),
      pB = new THREE.Vector3(),
      pC = new THREE.Vector3(),

      cb = new THREE.Vector3(),
      ab = new THREE.Vector3();

      // indexed elements

      if ( attributes.index ) {

        var indices = attributes.index.array;

        var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

        for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

          var start = offsets[ j ].start;
          var count = offsets[ j ].count;
          var index = offsets[ j ].index;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            vA = ( index + indices[ i     ] ) * 3;
            vB = ( index + indices[ i + 1 ] ) * 3;
            vC = ( index + indices[ i + 2 ] ) * 3;

            pA.fromArray( positions, vA );
            pB.fromArray( positions, vB );
            pC.fromArray( positions, vC );

            cb.subVectors( pC, pB );
            ab.subVectors( pA, pB );
            cb.cross( ab );

            normals[ vA     ] += cb.x;
            normals[ vA + 1 ] += cb.y;
            normals[ vA + 2 ] += cb.z;

            normals[ vB     ] += cb.x;
            normals[ vB + 1 ] += cb.y;
            normals[ vB + 2 ] += cb.z;

            normals[ vC     ] += cb.x;
            normals[ vC + 1 ] += cb.y;
            normals[ vC + 2 ] += cb.z;

          }

        }

      } else {

        // non-indexed elements (unconnected triangle soup)

        for ( var i = 0, il = positions.length; i < il; i += 9 ) {

          pA.fromArray( positions, i );
          pB.fromArray( positions, i + 3 );
          pC.fromArray( positions, i + 6 );

          cb.subVectors( pC, pB );
          ab.subVectors( pA, pB );
          cb.cross( ab );

          normals[ i     ] = cb.x;
          normals[ i + 1 ] = cb.y;
          normals[ i + 2 ] = cb.z;

          normals[ i + 3 ] = cb.x;
          normals[ i + 4 ] = cb.y;
          normals[ i + 5 ] = cb.z;

          normals[ i + 6 ] = cb.x;
          normals[ i + 7 ] = cb.y;
          normals[ i + 8 ] = cb.z;

        }

      }

      this.normalizeNormals();

      attributes.normal.needsUpdate = true;

    }

  },

  computeTangents: function () {

    // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if ( this.attributes.index === undefined ||
       this.attributes.position === undefined ||
       this.attributes.normal === undefined ||
       this.attributes.uv === undefined ) {

      console.warn( 'Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
      return;

    }

    var indices = this.attributes.index.array;
    var positions = this.attributes.position.array;
    var normals = this.attributes.normal.array;
    var uvs = this.attributes.uv.array;

    var nVertices = positions.length / 3;

    if ( this.attributes.tangent === undefined ) {

      this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

    }

    var tangents = this.attributes.tangent.array;

    var tan1 = [], tan2 = [];

    for ( var k = 0; k < nVertices; k ++ ) {

      tan1[ k ] = new THREE.Vector3();
      tan2[ k ] = new THREE.Vector3();

    }

    var vA = new THREE.Vector3(),
      vB = new THREE.Vector3(),
      vC = new THREE.Vector3(),

      uvA = new THREE.Vector2(),
      uvB = new THREE.Vector2(),
      uvC = new THREE.Vector2(),

      x1, x2, y1, y2, z1, z2,
      s1, s2, t1, t2, r;

    var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

    function handleTriangle( a, b, c ) {

      vA.fromArray( positions, a * 3 );
      vB.fromArray( positions, b * 3 );
      vC.fromArray( positions, c * 3 );

      uvA.fromArray( uvs, a * 2 );
      uvB.fromArray( uvs, b * 2 );
      uvC.fromArray( uvs, c * 2 );

      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;

      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;

      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;

      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;

      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;

      r = 1.0 / ( s1 * t2 - s2 * t1 );

      sdir.set(
        ( t2 * x1 - t1 * x2 ) * r,
        ( t2 * y1 - t1 * y2 ) * r,
        ( t2 * z1 - t1 * z2 ) * r
      );

      tdir.set(
        ( s1 * x2 - s2 * x1 ) * r,
        ( s1 * y2 - s2 * y1 ) * r,
        ( s1 * z2 - s2 * z1 ) * r
      );

      tan1[ a ].add( sdir );
      tan1[ b ].add( sdir );
      tan1[ c ].add( sdir );

      tan2[ a ].add( tdir );
      tan2[ b ].add( tdir );
      tan2[ c ].add( tdir );

    }

    var i, il;
    var j, jl;
    var iA, iB, iC;

    if ( this.drawcalls.length === 0 ) {

      this.addDrawCall( 0, indices.length, 0 );

    }

    var drawcalls = this.drawcalls;

    for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

      var start = drawcalls[ j ].start;
      var count = drawcalls[ j ].count;
      var index = drawcalls[ j ].index;

      for ( i = start, il = start + count; i < il; i += 3 ) {

        iA = index + indices[ i ];
        iB = index + indices[ i + 1 ];
        iC = index + indices[ i + 2 ];

        handleTriangle( iA, iB, iC );

      }

    }

    var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
    var n = new THREE.Vector3(), n2 = new THREE.Vector3();
    var w, t, test;

    function handleVertex( v ) {

      n.fromArray( normals, v * 3 );
      n2.copy( n );

      t = tan1[ v ];

      // Gram-Schmidt orthogonalize

      tmp.copy( t );
      tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

      // Calculate handedness

      tmp2.crossVectors( n2, t );
      test = tmp2.dot( tan2[ v ] );
      w = ( test < 0.0 ) ? - 1.0 : 1.0;

      tangents[ v * 4     ] = tmp.x;
      tangents[ v * 4 + 1 ] = tmp.y;
      tangents[ v * 4 + 2 ] = tmp.z;
      tangents[ v * 4 + 3 ] = w;

    }

    for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

      var start = drawcalls[ j ].start;
      var count = drawcalls[ j ].count;
      var index = drawcalls[ j ].index;

      for ( i = start, il = start + count; i < il; i += 3 ) {

        iA = index + indices[ i ];
        iB = index + indices[ i + 1 ];
        iC = index + indices[ i + 2 ];

        handleVertex( iA );
        handleVertex( iB );
        handleVertex( iC );

      }

    }

  },

  /*
    computeOffsets
    Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
    This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
    WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
    indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.
  */
  computeOffsets: function ( indexBufferSize ) {

    var size = indexBufferSize;
    if ( indexBufferSize === undefined )
      size = 65535; //WebGL limits type of index buffer values to 16-bit.

    var s = Date.now();

    var indices = this.attributes.index.array;
    var vertices = this.attributes.position.array;

    var verticesCount = ( vertices.length / 3 );
    var facesCount = ( indices.length / 3 );

    /*
    console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
    console.log("Faces to process: "+(indices.length/3));
    console.log("Reordering "+verticesCount+" vertices.");
    */

    var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
    var indexPtr = 0;
    var vertexPtr = 0;

    var offsets = [ { start:0, count:0, index:0 } ];
    var offset = offsets[ 0 ];

    var duplicatedVertices = 0;
    var newVerticeMaps = 0;
    var faceVertices = new Int32Array( 6 );
    var vertexMap = new Int32Array( vertices.length );
    var revVertexMap = new Int32Array( vertices.length );
    for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

    /*
      Traverse every face and reorder vertices in the proper offsets of 65k.
      We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
    */
    for ( var findex = 0; findex < facesCount; findex ++ ) {
      newVerticeMaps = 0;

      for ( var vo = 0; vo < 3; vo ++ ) {
        var vid = indices[ findex * 3 + vo ];
        if ( vertexMap[ vid ] == - 1 ) {
          //Unmapped vertice
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = - 1;
          newVerticeMaps ++;
        } else if ( vertexMap[ vid ] < offset.index ) {
          //Reused vertices from previous block (duplicate)
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = - 1;
          duplicatedVertices ++;
        } else {
          //Reused vertice in the current block
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
        }
      }

      var faceMax = vertexPtr + newVerticeMaps;
      if ( faceMax > ( offset.index + size ) ) {
        var new_offset = { start:indexPtr, count:0, index:vertexPtr };
        offsets.push( new_offset );
        offset = new_offset;

        //Re-evaluate reused vertices in light of new offset.
        for ( var v = 0; v < 6; v += 2 ) {
          var new_vid = faceVertices[ v + 1 ];
          if ( new_vid > - 1 && new_vid < offset.index )
            faceVertices[ v + 1 ] = - 1;
        }
      }

      //Reindex the face.
      for ( var v = 0; v < 6; v += 2 ) {
        var vid = faceVertices[ v ];
        var new_vid = faceVertices[ v + 1 ];

        if ( new_vid === - 1 )
          new_vid = vertexPtr ++;

        vertexMap[ vid ] = new_vid;
        revVertexMap[ new_vid ] = vid;
        sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
        offset.count ++;
      }
    }

    /* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
    this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
    this.offsets = offsets;

    /*
    var orderTime = Date.now();
    console.log("Reorder time: "+(orderTime-s)+"ms");
    console.log("Duplicated "+duplicatedVertices+" vertices.");
    console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
    console.log("Draw offsets: "+offsets.length);
    */

    return offsets;
  },

  merge: function () {

    console.log( 'BufferGeometry.merge(): TODO' );

  },

  normalizeNormals: function () {

    var normals = this.attributes.normal.array;

    var x, y, z, n;

    for ( var i = 0, il = normals.length; i < il; i += 3 ) {

      x = normals[ i ];
      y = normals[ i + 1 ];
      z = normals[ i + 2 ];

      n = 1.0 / Math.sqrt( x * x + y * y + z * z );

      normals[ i     ] *= n;
      normals[ i + 1 ] *= n;
      normals[ i + 2 ] *= n;

    }

  },

  /*
    reoderBuffers:
    Reorder attributes based on a new indexBuffer and indexMap.
    indexBuffer - Uint16Array of the new ordered indices.
    indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
    vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
  */
  reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

    /* Create a copy of all attributes for reordering. */
    var sortedAttributes = {};
    for ( var attr in this.attributes ) {
      if ( attr == 'index' )
        continue;
      var sourceArray = this.attributes[ attr ].array;
      sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
    }

    /* Move attribute positions based on the new index map */
    for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
      var vid = indexMap[ new_vid ];
      for ( var attr in this.attributes ) {
        if ( attr == 'index' )
          continue;
        var attrArray = this.attributes[ attr ].array;
        var attrSize = this.attributes[ attr ].itemSize;
        var sortedAttr = sortedAttributes[ attr ];
        for ( var k = 0; k < attrSize; k ++ )
          sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
      }
    }

    /* Carry the new sorted buffers locally */
    this.attributes[ 'index' ].array = indexBuffer;
    for ( var attr in this.attributes ) {
      if ( attr == 'index' )
        continue;
      this.attributes[ attr ].array = sortedAttributes[ attr ];
      this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
    }
  },

  toJSON: function () {

    var output = {
      metadata: {
        version: 4.0,
        type: 'BufferGeometry',
        generator: 'BufferGeometryExporter'
      },
      uuid: this.uuid,
      type: this.type,
      data: {
        attributes: {}
      }
    };

    var attributes = this.attributes;
    var offsets = this.offsets;
    var boundingSphere = this.boundingSphere;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];

      var array = [], typeArray = attribute.array;

      for ( var i = 0, l = typeArray.length; i < l; i ++ ) {

        array[ i ] = typeArray[ i ];

      }

      output.data.attributes[ key ] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: array
      }

    }

    if ( offsets.length > 0 ) {

      output.data.offsets = JSON.parse( JSON.stringify( offsets ) );

    }

    if ( boundingSphere !== null ) {

      output.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      }

    }

    return output;

  },

  clone: function () {

    var geometry = new THREE.BufferGeometry();

    for ( var attr in this.attributes ) {

      var sourceAttr = this.attributes[ attr ];
      geometry.addAttribute( attr, sourceAttr.clone() );

    }

    for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

      var offset = this.offsets[ i ];

      geometry.offsets.push( {

        start: offset.start,
        index: offset.index,
        count: offset.count

      } );

    }

    return geometry;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Geometry';

  this.vertices = [];
  this.colors = [];  // one-to-one vertex colors, used in Points and Line

  this.faces = [];

  this.faceVertexUvs = [ [] ];

  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];

  this.skinWeights = [];
  this.skinIndices = [];

  this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  this.hasTangents = false;

  this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

  // update flags

  this.verticesNeedUpdate = false;
  this.elementsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.tangentsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;

  this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

  constructor: THREE.Geometry,

  applyMatrix: function ( matrix ) {

    var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

      var vertex = this.vertices[ i ];
      vertex.applyMatrix4( matrix );

    }

    for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

      var face = this.faces[ i ];
      face.normal.applyMatrix3( normalMatrix ).normalize();

      for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

        face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

      }

    }

    if ( this.boundingBox instanceof THREE.Box3 ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere instanceof THREE.Sphere ) {

      this.computeBoundingSphere();

    }

  },

  fromBufferGeometry: function ( geometry ) {

    var scope = this;

    var attributes = geometry.attributes;

    var vertices = attributes.position.array;
    var indices = attributes.index !== undefined ? attributes.index.array : undefined;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

    var tempNormals = [];
    var tempUVs = [];

    for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

      scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

      if ( normals !== undefined ) {

        tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

      }

      if ( colors !== undefined ) {

        scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

      }

      if ( uvs !== undefined ) {

        tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

      }

    }

    var addFace = function ( a, b, c ) {

      var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
      var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

      scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );
      scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ], tempUVs[ b ], tempUVs[ c ] ] );

    };

    if ( indices !== undefined ) {

      for ( var i = 0; i < indices.length; i += 3 ) {

        addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

      }

    } else {

      for ( var i = 0; i < vertices.length / 3; i += 3 ) {

        addFace( i, i + 1, i + 2 );

      }

    }
    
    this.computeFaceNormals();

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    return this;

  },

  center: function () {

    this.computeBoundingBox();

    var offset = new THREE.Vector3();

    offset.addVectors( this.boundingBox.min, this.boundingBox.max );
    offset.multiplyScalar( - 0.5 );

    this.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
    this.computeBoundingBox();

    return offset;

  },

  computeFaceNormals: function () {

    var cb = new THREE.Vector3(), ab = new THREE.Vector3();

    for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

      var face = this.faces[ f ];

      var vA = this.vertices[ face.a ];
      var vB = this.vertices[ face.b ];
      var vC = this.vertices[ face.c ];

      cb.subVectors( vC, vB );
      ab.subVectors( vA, vB );
      cb.cross( ab );

      cb.normalize();

      face.normal.copy( cb );

    }

  },

  computeVertexNormals: function ( areaWeighted ) {

    var v, vl, f, fl, face, vertices;

    vertices = new Array( this.vertices.length );

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ] = new THREE.Vector3();

    }

    if ( areaWeighted ) {

      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm

      var vA, vB, vC, vD;
      var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
        db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vA = this.vertices[ face.a ];
        vB = this.vertices[ face.b ];
        vC = this.vertices[ face.c ];

        cb.subVectors( vC, vB );
        ab.subVectors( vA, vB );
        cb.cross( ab );

        vertices[ face.a ].add( cb );
        vertices[ face.b ].add( cb );
        vertices[ face.c ].add( cb );

      }

    } else {

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vertices[ face.a ].add( face.normal );
        vertices[ face.b ].add( face.normal );
        vertices[ face.c ].add( face.normal );

      }

    }

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ].normalize();

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
      face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
      face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

    }

  },

  computeMorphNormals: function () {

    var i, il, f, fl, face;

    // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      if ( ! face.__originalFaceNormal ) {

        face.__originalFaceNormal = face.normal.clone();

      } else {

        face.__originalFaceNormal.copy( face.normal );

      }

      if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

      for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

        if ( ! face.__originalVertexNormals[ i ] ) {

          face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

        } else {

          face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

        }

      }

    }

    // use temp geometry to compute face and vertex normals for each morph

    var tmpGeo = new THREE.Geometry();
    tmpGeo.faces = this.faces;

    for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

      // create on first access

      if ( ! this.morphNormals[ i ] ) {

        this.morphNormals[ i ] = {};
        this.morphNormals[ i ].faceNormals = [];
        this.morphNormals[ i ].vertexNormals = [];

        var dstNormalsFace = this.morphNormals[ i ].faceNormals;
        var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

        var faceNormal, vertexNormals;

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

          faceNormal = new THREE.Vector3();
          vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

          dstNormalsFace.push( faceNormal );
          dstNormalsVertex.push( vertexNormals );

        }

      }

      var morphNormals = this.morphNormals[ i ];

      // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[ i ].vertices;

      // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();

      // store morph normals

      var faceNormal, vertexNormals;

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        faceNormal = morphNormals.faceNormals[ f ];
        vertexNormals = morphNormals.vertexNormals[ f ];

        faceNormal.copy( face.normal );

        vertexNormals.a.copy( face.vertexNormals[ 0 ] );
        vertexNormals.b.copy( face.vertexNormals[ 1 ] );
        vertexNormals.c.copy( face.vertexNormals[ 2 ] );

      }

    }

    // restore original normals

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;

    }

  },

  computeTangents: function () {

    // based on http://www.terathon.com/code/tangent.html
    // tangents go to vertices

    var f, fl, v, vl, i, il, vertexIndex,
      face, uv, vA, vB, vC, uvA, uvB, uvC,
      x1, x2, y1, y2, z1, z2,
      s1, s2, t1, t2, r, t, test,
      tan1 = [], tan2 = [],
      sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
      tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
      n = new THREE.Vector3(), w;

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      tan1[ v ] = new THREE.Vector3();
      tan2[ v ] = new THREE.Vector3();

    }

    function handleTriangle( context, a, b, c, ua, ub, uc ) {

      vA = context.vertices[ a ];
      vB = context.vertices[ b ];
      vC = context.vertices[ c ];

      uvA = uv[ ua ];
      uvB = uv[ ub ];
      uvC = uv[ uc ];

      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;
      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;
      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;

      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;
      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;

      r = 1.0 / ( s1 * t2 - s2 * t1 );
      sdir.set( ( t2 * x1 - t1 * x2 ) * r,
            ( t2 * y1 - t1 * y2 ) * r,
            ( t2 * z1 - t1 * z2 ) * r );
      tdir.set( ( s1 * x2 - s2 * x1 ) * r,
            ( s1 * y2 - s2 * y1 ) * r,
            ( s1 * z2 - s2 * z1 ) * r );

      tan1[ a ].add( sdir );
      tan1[ b ].add( sdir );
      tan1[ c ].add( sdir );

      tan2[ a ].add( tdir );
      tan2[ b ].add( tdir );
      tan2[ c ].add( tdir );

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];
      uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

      handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

    }

    var faceIndex = [ 'a', 'b', 'c', 'd' ];

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

        n.copy( face.vertexNormals[ i ] );

        vertexIndex = face[ faceIndex[ i ] ];

        t = tan1[ vertexIndex ];

        // Gram-Schmidt orthogonalize

        tmp.copy( t );
        tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

        // Calculate handedness

        tmp2.crossVectors( face.vertexNormals[ i ], t );
        test = tmp2.dot( tan2[ vertexIndex ] );
        w = ( test < 0.0 ) ? - 1.0 : 1.0;

        face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

      }

    }

    this.hasTangents = true;

  },

  computeLineDistances: function () {

    var d = 0;
    var vertices = this.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      if ( i > 0 ) {

        d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

      }

      this.lineDistances[ i ] = d;

    }

  },

  computeBoundingBox: function () {

    if ( this.boundingBox === null ) {

      this.boundingBox = new THREE.Box3();

    }

    this.boundingBox.setFromPoints( this.vertices );

  },

  computeBoundingSphere: function () {

    if ( this.boundingSphere === null ) {

      this.boundingSphere = new THREE.Sphere();

    }

    this.boundingSphere.setFromPoints( this.vertices );

  },

  merge: function ( geometry, matrix, materialIndexOffset ) {

    if ( geometry instanceof THREE.Geometry === false ) {

      console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
      return;

    }

    var normalMatrix,
    vertexOffset = this.vertices.length,
    vertices1 = this.vertices,
    vertices2 = geometry.vertices,
    faces1 = this.faces,
    faces2 = geometry.faces,
    uvs1 = this.faceVertexUvs[ 0 ],
    uvs2 = geometry.faceVertexUvs[ 0 ];

    if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

    if ( matrix !== undefined ) {

      normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    }

    // vertices

    for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

      var vertex = vertices2[ i ];

      var vertexCopy = vertex.clone();

      if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

      vertices1.push( vertexCopy );

    }

    // faces

    for ( i = 0, il = faces2.length; i < il; i ++ ) {

      var face = faces2[ i ], faceCopy, normal, color,
      faceVertexNormals = face.vertexNormals,
      faceVertexColors = face.vertexColors;

      faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
      faceCopy.normal.copy( face.normal );

      if ( normalMatrix !== undefined ) {

        faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

      }

      for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

        normal = faceVertexNormals[ j ].clone();

        if ( normalMatrix !== undefined ) {

          normal.applyMatrix3( normalMatrix ).normalize();

        }

        faceCopy.vertexNormals.push( normal );

      }

      faceCopy.color.copy( face.color );

      for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

        color = faceVertexColors[ j ];
        faceCopy.vertexColors.push( color.clone() );

      }

      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

      faces1.push( faceCopy );

    }

    // uvs

    for ( i = 0, il = uvs2.length; i < il; i ++ ) {

      var uv = uvs2[ i ], uvCopy = [];

      if ( uv === undefined ) {

        continue;

      }

      for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

        uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

      }

      uvs1.push( uvCopy );

    }

  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */

  mergeVertices: function () {

    var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
    var unique = [], changes = [];

    var v, key;
    var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
    var precision = Math.pow( 10, precisionPoints );
    var i,il, face;
    var indices, k, j, jl, u;

    for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

      v = this.vertices[ i ];
      key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

      if ( verticesMap[ key ] === undefined ) {

        verticesMap[ key ] = i;
        unique.push( this.vertices[ i ] );
        changes[ i ] = unique.length - 1;

      } else {

        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[ i ] = changes[ verticesMap[ key ] ];

      }

    };


    // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.
    var faceIndicesToRemove = [];

    for ( i = 0, il = this.faces.length; i < il; i ++ ) {

      face = this.faces[ i ];

      face.a = changes[ face.a ];
      face.b = changes[ face.b ];
      face.c = changes[ face.c ];

      indices = [ face.a, face.b, face.c ];

      var dupIndex = - 1;

      // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved
      for ( var n = 0; n < 3; n ++ ) {
        if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

          dupIndex = n;
          faceIndicesToRemove.push( i );
          break;

        }
      }

    }

    for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
      var idx = faceIndicesToRemove[ i ];

      this.faces.splice( idx, 1 );

      for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

        this.faceVertexUvs[ j ].splice( idx, 1 );

      }

    }

    // Use unique set of vertices

    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;

  },

  toJSON: function () {

    var output = {
      metadata: {
        version: 4.0,
        type: 'BufferGeometry',
        generator: 'BufferGeometryExporter'
      },
      uuid: this.uuid,
      type: this.type
    };

    if ( this.name !== "" ) output.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];

      }

      return output;

    }

    var vertices = [];

    for ( var i = 0; i < this.vertices.length; i ++ ) {

      var vertex = this.vertices[ i ];
      vertices.push( vertex.x, vertex.y, vertex.z );

    }

    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};

    for ( var i = 0; i < this.faces.length; i ++ ) {

      var face = this.faces[ i ];

      var hasMaterial = false; // face.materialIndex !== undefined;
      var hasFaceUv = false; // deprecated
      var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;

      var faceType = 0;

      faceType = setBit( faceType, 0, 0 );
      faceType = setBit( faceType, 1, hasMaterial );
      faceType = setBit( faceType, 2, hasFaceUv );
      faceType = setBit( faceType, 3, hasFaceVertexUv );
      faceType = setBit( faceType, 4, hasFaceNormal );
      faceType = setBit( faceType, 5, hasFaceVertexNormal );
      faceType = setBit( faceType, 6, hasFaceColor );
      faceType = setBit( faceType, 7, hasFaceVertexColor );

      faces.push( faceType );
      faces.push( face.a, face.b, face.c );


      /*
      if ( hasMaterial ) {

        faces.push( face.materialIndex );

      }
      */

      if ( hasFaceVertexUv ) {

        var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

        faces.push(
          getUvIndex( faceVertexUvs[ 0 ] ),
          getUvIndex( faceVertexUvs[ 1 ] ),
          getUvIndex( faceVertexUvs[ 2 ] )
        );

      }

      if ( hasFaceNormal ) {

        faces.push( getNormalIndex( face.normal ) );

      }

      if ( hasFaceVertexNormal ) {

        var vertexNormals = face.vertexNormals;

        faces.push(
          getNormalIndex( vertexNormals[ 0 ] ),
          getNormalIndex( vertexNormals[ 1 ] ),
          getNormalIndex( vertexNormals[ 2 ] )
        );

      }

      if ( hasFaceColor ) {

        faces.push( getColorIndex( face.color ) );

      }

      if ( hasFaceVertexColor ) {

        var vertexColors = face.vertexColors;

        faces.push(
          getColorIndex( vertexColors[ 0 ] ),
          getColorIndex( vertexColors[ 1 ] ),
          getColorIndex( vertexColors[ 2 ] )
        );

      }

    }

    function setBit( value, position, enabled ) {

      return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

    }

    function getNormalIndex( normal ) {

      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if ( normalsHash[ hash ] !== undefined ) {

        return normalsHash[ hash ];

      }

      normalsHash[ hash ] = normals.length / 3;
      normals.push( normal.x, normal.y, normal.z );

      return normalsHash[ hash ];

    }

    function getColorIndex( color ) {

      var hash = color.r.toString() + color.g.toString() + color.b.toString();

      if ( colorsHash[ hash ] !== undefined ) {

        return colorsHash[ hash ];

      }

      colorsHash[ hash ] = colors.length;
      colors.push( color.getHex() );

      return colorsHash[ hash ];

    }

    function getUvIndex( uv ) {

      var hash = uv.x.toString() + uv.y.toString();

      if ( uvsHash[ hash ] !== undefined ) {

        return uvsHash[ hash ];

      }

      uvsHash[ hash ] = uvs.length / 2;
      uvs.push( uv.x, uv.y );

      return uvsHash[ hash ];

    }

    output.data = {};

    output.data.vertices = vertices;
    output.data.normals = normals;
    if ( colors.length > 0 ) output.data.colors = colors;
    if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
    output.data.faces = faces;

    //

    return output;

  },

  clone: function () {

    var geometry = new THREE.Geometry();

    var vertices = this.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      geometry.vertices.push( vertices[ i ].clone() );

    }

    var faces = this.faces;

    for ( var i = 0, il = faces.length; i < il; i ++ ) {

      geometry.faces.push( faces[ i ].clone() );

    }

    var uvs = this.faceVertexUvs[ 0 ];

    for ( var i = 0, il = uvs.length; i < il; i ++ ) {

      var uv = uvs[ i ], uvCopy = [];

      for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

        uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

      }

      geometry.faceVertexUvs[ 0 ].push( uvCopy );

    }

    return geometry;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

  THREE.Object3D.call( this );

  this.type = 'Camera';

  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.getWorldDirection = function () {

  var quaternion = new THREE.Quaternion();

  return function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.getWorldQuaternion( quaternion );

    return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  }

}();

THREE.Camera.prototype.lookAt = function () {

  // This routine does not support cameras with rotated and/or translated parent(s)

  var m1 = new THREE.Matrix4();

  return function ( vector ) {

    m1.lookAt( this.position, vector, this.up );

    this.quaternion.setFromRotationMatrix( m1 );

  };

}();

THREE.Camera.prototype.clone = function ( camera ) {

  if ( camera === undefined ) camera = new THREE.Camera();

  THREE.Object3D.prototype.clone.call( this, camera );

  camera.matrixWorldInverse.copy( this.matrixWorldInverse );
  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;
};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *  - renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

  THREE.Object3D.call( this );

  this.type = 'CubeCamera';

  var fov = 90, aspect = 1;

  var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPX.up.set( 0, - 1, 0 );
  cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
  this.add( cameraPX );

  var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNX.up.set( 0, - 1, 0 );
  cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
  this.add( cameraNX );

  var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPY.up.set( 0, 0, 1 );
  cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
  this.add( cameraPY );

  var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNY.up.set( 0, 0, - 1 );
  cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
  this.add( cameraNY );

  var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPZ.up.set( 0, - 1, 0 );
  cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
  this.add( cameraPZ );

  var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNZ.up.set( 0, - 1, 0 );
  cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
  this.add( cameraNZ );

  this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

  this.updateCubeMap = function ( renderer, scene ) {

    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.generateMipmaps;

    renderTarget.generateMipmaps = false;

    renderTarget.activeCubeFace = 0;
    renderer.render( scene, cameraPX, renderTarget );

    renderTarget.activeCubeFace = 1;
    renderer.render( scene, cameraNX, renderTarget );

    renderTarget.activeCubeFace = 2;
    renderer.render( scene, cameraPY, renderTarget );

    renderTarget.activeCubeFace = 3;
    renderer.render( scene, cameraNY, renderTarget );

    renderTarget.activeCubeFace = 4;
    renderer.render( scene, cameraPZ, renderTarget );

    renderTarget.generateMipmaps = generateMipmaps;

    renderTarget.activeCubeFace = 5;
    renderer.render( scene, cameraNZ, renderTarget );

  };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

  THREE.Camera.call( this );

  this.type = 'OrthographicCamera';

  this.zoom = 1;

  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;

  this.near = ( near !== undefined ) ? near : 0.1;
  this.far = ( far !== undefined ) ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

  var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  var cx = ( this.right + this.left ) / 2;
  var cy = ( this.top + this.bottom ) / 2;

  this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

  var camera = new THREE.OrthographicCamera();

  THREE.Camera.prototype.clone.call( this, camera );

  camera.zoom = this.zoom;

  camera.left = this.left;
  camera.right = this.right;
  camera.top = this.top;
  camera.bottom = this.bottom;

  camera.near = this.near;
  camera.far = this.far;

  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;
};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

  THREE.Camera.call( this );

  this.type = 'PerspectiveCamera';

  this.zoom = 1;

  this.fov = fov !== undefined ? fov : 50;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

  if ( frameHeight === undefined ) frameHeight = 24;

  this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
  this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

  this.fullWidth = fullWidth;
  this.fullHeight = fullHeight;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;

  this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

  var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

  if ( this.fullWidth ) {

    var aspect = this.fullWidth / this.fullHeight;
    var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
    var bottom = - top;
    var left = aspect * bottom;
    var right = aspect * top;
    var width = Math.abs( right - left );
    var height = Math.abs( top - bottom );

    this.projectionMatrix.makeFrustum(
      left + this.x * width / this.fullWidth,
      left + ( this.x + this.width ) * width / this.fullWidth,
      top - ( this.y + this.height ) * height / this.fullHeight,
      top - this.y * height / this.fullHeight,
      this.near,
      this.far
    );

  } else {

    this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

  }

};

THREE.PerspectiveCamera.prototype.clone = function () {

  var camera = new THREE.PerspectiveCamera();

  THREE.Camera.prototype.clone.call( this, camera );

  camera.zoom = this.zoom;

  camera.fov = this.fov;
  camera.aspect = this.aspect;
  camera.near = this.near;
  camera.far = this.far;

  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

  THREE.Object3D.call( this );

  this.type = 'Light';
  
  this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

THREE.Light.prototype.clone = function ( light ) {

  if ( light === undefined ) light = new THREE.Light();

  THREE.Object3D.prototype.clone.call( this, light );

  light.color.copy( this.color );

  return light;

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

  THREE.Light.call( this, color );

  this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

THREE.AmbientLight.prototype.clone = function () {

  var light = new THREE.AmbientLight();

  THREE.Light.prototype.clone.call( this, light );

  return light;

};

// File:src/lights/AreaLight.js

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity ) {

  THREE.Light.call( this, color );

  this.type = 'AreaLight';

  this.normal = new THREE.Vector3( 0, - 1, 0 );
  this.right = new THREE.Vector3( 1, 0, 0 );

  this.intensity = ( intensity !== undefined ) ? intensity : 1;

  this.width = 1.0;
  this.height = 1.0;

  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );


// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

  THREE.Light.call( this, color );

  this.type = 'DirectionalLight';

  this.position.set( 0, 1, 0 );
  this.target = new THREE.Object3D();

  this.intensity = ( intensity !== undefined ) ? intensity : 1;

  this.castShadow = false;
  this.onlyShadow = false;

  //

  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;

  this.shadowCameraLeft = - 500;
  this.shadowCameraRight = 500;
  this.shadowCameraTop = 500;
  this.shadowCameraBottom = - 500;

  this.shadowCameraVisible = false;

  this.shadowBias = 0;
  this.shadowDarkness = 0.5;

  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;

  //

  this.shadowCascade = false;

  this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
  this.shadowCascadeCount = 2;

  this.shadowCascadeBias = [ 0, 0, 0 ];
  this.shadowCascadeWidth = [ 512, 512, 512 ];
  this.shadowCascadeHeight = [ 512, 512, 512 ];

  this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
  this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

  this.shadowCascadeArray = [];

  //

  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

THREE.DirectionalLight.prototype.clone = function () {

  var light = new THREE.DirectionalLight();

  THREE.Light.prototype.clone.call( this, light );

  light.target = this.target.clone();

  light.intensity = this.intensity;

  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;

  //

  light.shadowCameraNear = this.shadowCameraNear;
  light.shadowCameraFar = this.shadowCameraFar;

  light.shadowCameraLeft = this.shadowCameraLeft;
  light.shadowCameraRight = this.shadowCameraRight;
  light.shadowCameraTop = this.shadowCameraTop;
  light.shadowCameraBottom = this.shadowCameraBottom;

  light.shadowCameraVisible = this.shadowCameraVisible;

  light.shadowBias = this.shadowBias;
  light.shadowDarkness = this.shadowDarkness;

  light.shadowMapWidth = this.shadowMapWidth;
  light.shadowMapHeight = this.shadowMapHeight;

  //

  light.shadowCascade = this.shadowCascade;

  light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
  light.shadowCascadeCount = this.shadowCascadeCount;

  light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
  light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
  light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

  light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
  light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );

  return light;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

  THREE.Light.call( this, skyColor );

  this.type = 'HemisphereLight';

  this.position.set( 0, 100, 0 );

  this.groundColor = new THREE.Color( groundColor );
  this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

THREE.HemisphereLight.prototype.clone = function () {

  var light = new THREE.HemisphereLight();

  THREE.Light.prototype.clone.call( this, light );

  light.groundColor.copy( this.groundColor );
  light.intensity = this.intensity;

  return light;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance ) {

  THREE.Light.call( this, color );

  this.type = 'PointLight';

  this.intensity = ( intensity !== undefined ) ? intensity : 1;
  this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

THREE.PointLight.prototype.clone = function () {

  var light = new THREE.PointLight();

  THREE.Light.prototype.clone.call( this, light );

  light.intensity = this.intensity;
  light.distance = this.distance;

  return light;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent ) {

  THREE.Light.call( this, color );

  this.type = 'SpotLight';

  this.position.set( 0, 1, 0 );
  this.target = new THREE.Object3D();

  this.intensity = ( intensity !== undefined ) ? intensity : 1;
  this.distance = ( distance !== undefined ) ? distance : 0;
  this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  this.exponent = ( exponent !== undefined ) ? exponent : 10;

  this.castShadow = false;
  this.onlyShadow = false;

  //

  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;

  this.shadowCameraVisible = false;

  this.shadowBias = 0;
  this.shadowDarkness = 0.5;

  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;

  //

  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

THREE.SpotLight.prototype.clone = function () {

  var light = new THREE.SpotLight();

  THREE.Light.prototype.clone.call( this, light );

  light.target = this.target.clone();

  light.intensity = this.intensity;
  light.distance = this.distance;
  light.angle = this.angle;
  light.exponent = this.exponent;

  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;

  //

  light.shadowCameraNear = this.shadowCameraNear;
  light.shadowCameraFar = this.shadowCameraFar;
  light.shadowCameraFov = this.shadowCameraFov;

  light.shadowCameraVisible = this.shadowCameraVisible;

  light.shadowBias = this.shadowBias;
  light.shadowDarkness = this.shadowDarkness;

  light.shadowMapWidth = this.shadowMapWidth;
  light.shadowMapHeight = this.shadowMapHeight;

  return light;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = function () {

  this.files = {};

};

THREE.Cache.prototype = {

  constructor: THREE.Cache,

  add: function ( key, file ) {

    // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[ key ] = file;

  },

  get: function ( key ) {

    // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[ key ];

  },

  remove: function ( key ) {

    delete this.files[ key ];

  },

  clear: function () {

    this.files = {}

  }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

  this.showStatus = showStatus;
  this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

  this.imageLoader = new THREE.ImageLoader();

  this.onLoadStart = function () {};
  this.onLoadProgress = function () {};
  this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

  constructor: THREE.Loader,

  crossOrigin: undefined,

  addStatusElement: function () {

    var e = document.createElement( 'div' );

    e.style.position = 'absolute';
    e.style.right = '0px';
    e.style.top = '0px';
    e.style.fontSize = '0.8em';
    e.style.textAlign = 'left';
    e.style.background = 'rgba(0,0,0,0.25)';
    e.style.color = '#fff';
    e.style.width = '120px';
    e.style.padding = '0.5em 0.5em 0.5em 0.5em';
    e.style.zIndex = 1000;

    e.innerHTML = 'Loading ...';

    return e;

  },

  updateProgress: function ( progress ) {

    var message = 'Loaded ';

    if ( progress.total ) {

      message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


    } else {

      message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

    }

    this.statusDomElement.innerHTML = message;

  },

  extractUrlBase: function ( url ) {

    var parts = url.split( '/' );

    if ( parts.length === 1 ) return './';

    parts.pop();

    return parts.join( '/' ) + '/';

  },

  initMaterials: function ( materials, texturePath ) {

    var array = [];

    for ( var i = 0; i < materials.length; ++ i ) {

      array[ i ] = this.createMaterial( materials[ i ], texturePath );

    }

    return array;

  },

  needsTangents: function ( materials ) {

    for ( var i = 0, il = materials.length; i < il; i ++ ) {

      var m = materials[ i ];

      if ( m instanceof THREE.ShaderMaterial ) return true;

    }

    return false;

  },

  createMaterial: function ( m, texturePath ) {

    var scope = this;

    function nearest_pow2( n ) {

      var l = Math.log( n ) / Math.LN2;
      return Math.pow( 2, Math.round(  l ) );

    }

    function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

      var fullPath = texturePath + sourceFile;

      var texture;

      var loader = THREE.Loader.Handlers.get( fullPath );

      if ( loader !== null ) {

        texture = loader.load( fullPath );

      } else {

        texture = new THREE.Texture();

        loader = scope.imageLoader;
        loader.crossOrigin = scope.crossOrigin;
        loader.load( fullPath, function ( image ) {

          if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
             THREE.Math.isPowerOfTwo( image.height ) === false ) {

            var width = nearest_pow2( image.width );
            var height = nearest_pow2( image.height );

            var canvas = document.createElement( 'canvas' );
            canvas.width = width;
            canvas.height = height;

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, width, height );

            texture.image = canvas;

          } else {

            texture.image = image;

          }

          texture.needsUpdate = true;

        } );

      }

      texture.sourceFile = sourceFile;

      if ( repeat ) {

        texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

        if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
        if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

      }

      if ( offset ) {

        texture.offset.set( offset[ 0 ], offset[ 1 ] );

      }

      if ( wrap ) {

        var wrapMap = {
          'repeat': THREE.RepeatWrapping,
          'mirror': THREE.MirroredRepeatWrapping
        }

        if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
        if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

      }

      if ( anisotropy ) {

        texture.anisotropy = anisotropy;

      }

      where[ name ] = texture;

    }

    function rgb2hex( rgb ) {

      return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

    }

    // defaults

    var mtype = 'MeshLambertMaterial';
    var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

    // parameters from model file

    if ( m.shading ) {

      var shading = m.shading.toLowerCase();

      if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
      else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

    }

    if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

      mpars.blending = THREE[ m.blending ];

    }

    if ( m.transparent !== undefined || m.opacity < 1.0 ) {

      mpars.transparent = m.transparent;

    }

    if ( m.depthTest !== undefined ) {

      mpars.depthTest = m.depthTest;

    }

    if ( m.depthWrite !== undefined ) {

      mpars.depthWrite = m.depthWrite;

    }

    if ( m.visible !== undefined ) {

      mpars.visible = m.visible;

    }

    if ( m.flipSided !== undefined ) {

      mpars.side = THREE.BackSide;

    }

    if ( m.doubleSided !== undefined ) {

      mpars.side = THREE.DoubleSide;

    }

    if ( m.wireframe !== undefined ) {

      mpars.wireframe = m.wireframe;

    }

    if ( m.vertexColors !== undefined ) {

      if ( m.vertexColors === 'face' ) {

        mpars.vertexColors = THREE.FaceColors;

      } else if ( m.vertexColors ) {

        mpars.vertexColors = THREE.VertexColors;

      }

    }

    // colors

    if ( m.colorDiffuse ) {

      mpars.color = rgb2hex( m.colorDiffuse );

    } else if ( m.DbgColor ) {

      mpars.color = m.DbgColor;

    }

    if ( m.colorSpecular ) {

      mpars.specular = rgb2hex( m.colorSpecular );

    }

    if ( m.colorAmbient ) {

      mpars.ambient = rgb2hex( m.colorAmbient );

    }

    if ( m.colorEmissive ) {

      mpars.emissive = rgb2hex( m.colorEmissive );

    }

    // modifiers

    if ( m.transparency ) {

      mpars.opacity = m.transparency;

    }

    if ( m.specularCoef ) {

      mpars.shininess = m.specularCoef;

    }

    // textures

    if ( m.mapDiffuse && texturePath ) {

      create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

    }

    if ( m.mapLight && texturePath ) {

      create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

    }

    if ( m.mapBump && texturePath ) {

      create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

    }

    if ( m.mapNormal && texturePath ) {

      create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

    }

    if ( m.mapSpecular && texturePath ) {

      create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

    }

    if ( m.mapAlpha && texturePath ) {

      create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

    }

    //

    if ( m.mapBumpScale ) {

      mpars.bumpScale = m.mapBumpScale;

    }

    // special case for normal mapped material

    if ( m.mapNormal ) {

      var shader = THREE.ShaderLib[ 'normalmap' ];
      var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

      uniforms[ 'tNormal' ].value = mpars.normalMap;

      if ( m.mapNormalFactor ) {

        uniforms[ 'uNormalScale' ].value.set( m.mapNormalFactor, m.mapNormalFactor );

      }

      if ( mpars.map ) {

        uniforms[ 'tDiffuse' ].value = mpars.map;
        uniforms[ 'enableDiffuse' ].value = true;

      }

      if ( mpars.specularMap ) {

        uniforms[ 'tSpecular' ].value = mpars.specularMap;
        uniforms[ 'enableSpecular' ].value = true;

      }

      if ( mpars.lightMap ) {

        uniforms[ 'tAO' ].value = mpars.lightMap;
        uniforms[ 'enableAO' ].value = true;

      }

      // for the moment don't handle displacement texture

      uniforms[ 'diffuse' ].value.setHex( mpars.color );
      uniforms[ 'specular' ].value.setHex( mpars.specular );
      uniforms[ 'ambient' ].value.setHex( mpars.ambient );

      uniforms[ 'shininess' ].value = mpars.shininess;

      if ( mpars.opacity !== undefined ) {

        uniforms[ 'opacity' ].value = mpars.opacity;

      }

      var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
      var material = new THREE.ShaderMaterial( parameters );

      if ( mpars.transparent ) {

        material.transparent = true;

      }

    } else {

      var material = new THREE[ mtype ]( mpars );

    }

    if ( m.DbgName !== undefined ) material.name = m.DbgName;

    return material;

  }

};

THREE.Loader.Handlers = {

  handlers: [],

  add: function ( regex, loader ) {

    this.handlers.push( regex, loader );

  },

  get: function ( file ) {

    for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

      var regex = this.handlers[ i ];
      var loader  = this.handlers[ i + 1 ];

      if ( regex.test( file ) ) {

        return loader;

      }

    }

    return null;

  }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

  this.cache = new THREE.Cache();
  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

  constructor: THREE.XHRLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var cached = scope.cache.get( url );

    if ( cached !== undefined ) {

      if ( onLoad ) onLoad( cached );
      return;

    }

    var request = new XMLHttpRequest();
    request.open( 'GET', url, true );

    request.addEventListener( 'load', function ( event ) {

      scope.cache.add( url, this.response );

      if ( onLoad ) onLoad( this.response );

      scope.manager.itemEnd( url );

    }, false );

    if ( onProgress !== undefined ) {

      request.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    if ( onError !== undefined ) {

      request.addEventListener( 'error', function ( event ) {

        onError( event );

      }, false );

    }

    if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
    if ( this.responseType !== undefined ) request.responseType = this.responseType;

    request.send( null );

    scope.manager.itemStart( url );

  },

  setResponseType: function ( value ) {

    this.responseType = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

  this.cache = new THREE.Cache();
  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

  constructor: THREE.ImageLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var cached = scope.cache.get( url );

    if ( cached !== undefined ) {

      onLoad( cached );
      return;

    }

    var image = document.createElement( 'img' );

    if ( onLoad !== undefined ) {

      image.addEventListener( 'load', function ( event ) {

        scope.cache.add( url, this );

        onLoad( this );
        scope.manager.itemEnd( url );

      }, false );

    }

    if ( onProgress !== undefined ) {

      image.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    if ( onError !== undefined ) {

      image.addEventListener( 'error', function ( event ) {

        onError( event );

      }, false );

    }

    if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

    image.src = url;

    scope.manager.itemStart( url );

    return image;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

}

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

  THREE.Loader.call( this, showStatus );

  this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

  var scope = this;

  // todo: unify load API to for easier SceneLoader use

  texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

  this.onLoadStart();
  this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

  var xhr = new XMLHttpRequest();

  var length = 0;

  xhr.onreadystatechange = function () {

    if ( xhr.readyState === xhr.DONE ) {

      if ( xhr.status === 200 || xhr.status === 0 ) {

        if ( xhr.responseText ) {

          var json = JSON.parse( xhr.responseText );

          if ( json.metadata !== undefined && json.metadata.type === 'scene' ) {

            console.error( 'THREE.JSONLoader: "' + url + '" seems to be a Scene. Use THREE.SceneLoader instead.' );
            return;

          }

          var result = context.parse( json, texturePath );
          callback( result.geometry, result.materials );

        } else {

          console.error( 'THREE.JSONLoader: "' + url + '" seems to be unreachable or the file is empty.' );

        }

        // in context of more complex asset initialization
        // do not block on single failed file
        // maybe should go even one more level up

        context.onLoadComplete();

      } else {

        console.error( 'THREE.JSONLoader: Couldn\'t load "' + url + '" (' + xhr.status + ')' );

      }

    } else if ( xhr.readyState === xhr.LOADING ) {

      if ( callbackProgress ) {

        if ( length === 0 ) {

          length = xhr.getResponseHeader( 'Content-Length' );

        }

        callbackProgress( { total: length, loaded: xhr.responseText.length } );

      }

    } else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

      if ( callbackProgress !== undefined ) {

        length = xhr.getResponseHeader( 'Content-Length' );

      }

    }

  };

  xhr.open( 'GET', url, true );
  xhr.withCredentials = this.withCredentials;
  xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

  var scope = this,
  geometry = new THREE.Geometry(),
  scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

  parseModel( scale );

  parseSkin();
  parseMorphing( scale );

  geometry.computeFaceNormals();
  geometry.computeBoundingSphere();

  function parseModel( scale ) {

    function isBitSet( value, position ) {

      return value & ( 1 << position );

    }

    var i, j, fi,

    offset, zLength,

    colorIndex, normalIndex, uvIndex, materialIndex,

    type,
    isQuad,
    hasMaterial,
    hasFaceVertexUv,
    hasFaceNormal, hasFaceVertexNormal,
    hasFaceColor, hasFaceVertexColor,

    vertex, face, faceA, faceB, color, hex, normal,

    uvLayer, uv, u, v,

    faces = json.faces,
    vertices = json.vertices,
    normals = json.normals,
    colors = json.colors,

    nUvLayers = 0;

    if ( json.uvs !== undefined ) {

      // disregard empty arrays

      for ( i = 0; i < json.uvs.length; i ++ ) {

        if ( json.uvs[ i ].length ) nUvLayers ++;

      }

      for ( i = 0; i < nUvLayers; i ++ ) {

        geometry.faceVertexUvs[ i ] = [];

      }

    }

    offset = 0;
    zLength = vertices.length;

    while ( offset < zLength ) {

      vertex = new THREE.Vector3();

      vertex.x = vertices[ offset ++ ] * scale;
      vertex.y = vertices[ offset ++ ] * scale;
      vertex.z = vertices[ offset ++ ] * scale;

      geometry.vertices.push( vertex );

    }

    offset = 0;
    zLength = faces.length;

    while ( offset < zLength ) {

      type = faces[ offset ++ ];


      isQuad              = isBitSet( type, 0 );
      hasMaterial         = isBitSet( type, 1 );
      hasFaceVertexUv     = isBitSet( type, 3 );
      hasFaceNormal       = isBitSet( type, 4 );
      hasFaceVertexNormal = isBitSet( type, 5 );
      hasFaceColor       = isBitSet( type, 6 );
      hasFaceVertexColor  = isBitSet( type, 7 );

      // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

      if ( isQuad ) {

        faceA = new THREE.Face3();
        faceA.a = faces[ offset ];
        faceA.b = faces[ offset + 1 ];
        faceA.c = faces[ offset + 3 ];

        faceB = new THREE.Face3();
        faceB.a = faces[ offset + 1 ];
        faceB.b = faces[ offset + 2 ];
        faceB.c = faces[ offset + 3 ];

        offset += 4;

        if ( hasMaterial ) {

          materialIndex = faces[ offset ++ ];
          faceA.materialIndex = materialIndex;
          faceB.materialIndex = materialIndex;

        }

        // to get face <=> uv index correspondence

        fi = geometry.faces.length;

        if ( hasFaceVertexUv ) {

          for ( i = 0; i < nUvLayers; i ++ ) {

            uvLayer = json.uvs[ i ];

            geometry.faceVertexUvs[ i ][ fi ] = [];
            geometry.faceVertexUvs[ i ][ fi + 1 ] = []

            for ( j = 0; j < 4; j ++ ) {

              uvIndex = faces[ offset ++ ];

              u = uvLayer[ uvIndex * 2 ];
              v = uvLayer[ uvIndex * 2 + 1 ];

              uv = new THREE.Vector2( u, v );

              if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
              if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

            }

          }

        }

        if ( hasFaceNormal ) {

          normalIndex = faces[ offset ++ ] * 3;

          faceA.normal.set(
            normals[ normalIndex ++ ],
            normals[ normalIndex ++ ],
            normals[ normalIndex ]
          );

          faceB.normal.copy( faceA.normal );

        }

        if ( hasFaceVertexNormal ) {

          for ( i = 0; i < 4; i ++ ) {

            normalIndex = faces[ offset ++ ] * 3;

            normal = new THREE.Vector3(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );


            if ( i !== 2 ) faceA.vertexNormals.push( normal );
            if ( i !== 0 ) faceB.vertexNormals.push( normal );

          }

        }


        if ( hasFaceColor ) {

          colorIndex = faces[ offset ++ ];
          hex = colors[ colorIndex ];

          faceA.color.setHex( hex );
          faceB.color.setHex( hex );

        }


        if ( hasFaceVertexColor ) {

          for ( i = 0; i < 4; i ++ ) {

            colorIndex = faces[ offset ++ ];
            hex = colors[ colorIndex ];

            if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
            if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

          }

        }

        geometry.faces.push( faceA );
        geometry.faces.push( faceB );

      } else {

        face = new THREE.Face3();
        face.a = faces[ offset ++ ];
        face.b = faces[ offset ++ ];
        face.c = faces[ offset ++ ];

        if ( hasMaterial ) {

          materialIndex = faces[ offset ++ ];
          face.materialIndex = materialIndex;

        }

        // to get face <=> uv index correspondence

        fi = geometry.faces.length;

        if ( hasFaceVertexUv ) {

          for ( i = 0; i < nUvLayers; i ++ ) {

            uvLayer = json.uvs[ i ];

            geometry.faceVertexUvs[ i ][ fi ] = [];

            for ( j = 0; j < 3; j ++ ) {

              uvIndex = faces[ offset ++ ];

              u = uvLayer[ uvIndex * 2 ];
              v = uvLayer[ uvIndex * 2 + 1 ];

              uv = new THREE.Vector2( u, v );

              geometry.faceVertexUvs[ i ][ fi ].push( uv );

            }

          }

        }

        if ( hasFaceNormal ) {

          normalIndex = faces[ offset ++ ] * 3;

          face.normal.set(
            normals[ normalIndex ++ ],
            normals[ normalIndex ++ ],
            normals[ normalIndex ]
          );

        }

        if ( hasFaceVertexNormal ) {

          for ( i = 0; i < 3; i ++ ) {

            normalIndex = faces[ offset ++ ] * 3;

            normal = new THREE.Vector3(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );

            face.vertexNormals.push( normal );

          }

        }


        if ( hasFaceColor ) {

          colorIndex = faces[ offset ++ ];
          face.color.setHex( colors[ colorIndex ] );

        }


        if ( hasFaceVertexColor ) {

          for ( i = 0; i < 3; i ++ ) {

            colorIndex = faces[ offset ++ ];
            face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

          }

        }

        geometry.faces.push( face );

      }

    }

  };

  function parseSkin() {
    var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

    if ( json.skinWeights ) {

      for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

        var x =                               json.skinWeights[ i     ];
        var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
        var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
        var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

        geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

      }

    }

    if ( json.skinIndices ) {

      for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

        var a =                               json.skinIndices[ i     ];
        var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
        var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
        var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

        geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

      }

    }

    geometry.bones = json.bones;

    if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

        console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
          geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

    }


    // could change this to json.animations[0] or remove completely

    geometry.animation = json.animation;
    geometry.animations = json.animations;

  };

  function parseMorphing( scale ) {

    if ( json.morphTargets !== undefined ) {

      var i, l, v, vl, dstVertices, srcVertices;

      for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

        geometry.morphTargets[ i ] = {};
        geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
        geometry.morphTargets[ i ].vertices = [];

        dstVertices = geometry.morphTargets[ i ].vertices;
        srcVertices = json.morphTargets [ i ].vertices;

        for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

          var vertex = new THREE.Vector3();
          vertex.x = srcVertices[ v ] * scale;
          vertex.y = srcVertices[ v + 1 ] * scale;
          vertex.z = srcVertices[ v + 2 ] * scale;

          dstVertices.push( vertex );

        }

      }

    }

    if ( json.morphColors !== undefined ) {

      var i, l, c, cl, dstColors, srcColors, color;

      for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

        geometry.morphColors[ i ] = {};
        geometry.morphColors[ i ].name = json.morphColors[ i ].name;
        geometry.morphColors[ i ].colors = [];

        dstColors = geometry.morphColors[ i ].colors;
        srcColors = json.morphColors [ i ].colors;

        for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

          color = new THREE.Color( 0xffaa00 );
          color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
          dstColors.push( color );

        }

      }

    }

  };

  if ( json.materials === undefined || json.materials.length === 0 ) {

    return { geometry: geometry };

  } else {

    var materials = this.initMaterials( json.materials, texturePath );

    if ( this.needsTangents( materials ) ) {

      geometry.computeTangents();

    }

    return { geometry: geometry, materials: materials };

  }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

  var scope = this;

  var loaded = 0, total = 0;

  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function ( url ) {

    total ++;

  };

  this.itemEnd = function ( url ) {

    loaded ++;

    if ( scope.onProgress !== undefined ) {

      scope.onProgress( url, loaded, total );

    }

    if ( loaded === total && scope.onLoad !== undefined ) {

      scope.onLoad();

    }

  };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

  constructor: THREE.BufferGeometryLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader();
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var geometry = new THREE.BufferGeometry();

    var attributes = json.attributes;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];
      var typedArray = new self[ attribute.type ]( attribute.array );

      geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

    }

    var offsets = json.offsets;

    if ( offsets !== undefined ) {

      geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

    }

    var boundingSphere = json.boundingSphere;

    if ( boundingSphere !== undefined ) {

      var center = new THREE.Vector3();

      if ( boundingSphere.center !== undefined ) {

        center.fromArray( boundingSphere.center );

      }

      geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

    }

    return geometry;

  }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

  constructor: THREE.MaterialLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader();
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var material = new THREE[ json.type ];

    if ( json.color !== undefined ) material.color.setHex( json.color );
    if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
    if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    if ( json.shininess !== undefined ) material.shininess = json.shininess;
    if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;   
    if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    if ( json.shading !== undefined ) material.shading = json.shading;
    if ( json.blending !== undefined ) material.blending = json.blending;
    if ( json.side !== undefined ) material.side = json.side;
    if ( json.opacity !== undefined ) material.opacity = json.opacity;
    if ( json.transparent !== undefined ) material.transparent = json.transparent;
    if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

    if ( json.materials !== undefined ) {

      for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

        material.materials.push( this.parse( json.materials[ i ] ) );

      }

    }

    return material;

  }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

  constructor: THREE.ObjectLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var geometries = this.parseGeometries( json.geometries );
    var materials = this.parseMaterials( json.materials );
    var object = this.parseObject( json.object, geometries, materials );

    return object;

  },

  parseGeometries: function ( json ) {

    var geometries = {};

    if ( json !== undefined ) {

      var geometryLoader = new THREE.JSONLoader();
      var bufferGeometryLoader = new THREE.BufferGeometryLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var geometry;
        var data = json[ i ];

        switch ( data.type ) {

          case 'PlaneGeometry':

            geometry = new THREE.PlaneGeometry(
              data.width,
              data.height,
              data.widthSegments,
              data.heightSegments
            );

            break;

          case 'BoxGeometry':
          case 'CubeGeometry': // backwards compatible

            geometry = new THREE.BoxGeometry(
              data.width,
              data.height,
              data.depth,
              data.widthSegments,
              data.heightSegments,
              data.depthSegments
            );

            break;

          case 'CircleGeometry':

            geometry = new THREE.CircleGeometry(
              data.radius,
              data.segments
            );

            break;

          case 'CylinderGeometry':

            geometry = new THREE.CylinderGeometry(
              data.radiusTop,
              data.radiusBottom,
              data.height,
              data.radialSegments,
              data.heightSegments,
              data.openEnded
            );

            break;

          case 'SphereGeometry':

            geometry = new THREE.SphereGeometry(
              data.radius,
              data.widthSegments,
              data.heightSegments,
              data.phiStart,
              data.phiLength,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'IcosahedronGeometry':

            geometry = new THREE.IcosahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'TorusGeometry':

            geometry = new THREE.TorusGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.arc
            );

            break;

          case 'TorusKnotGeometry':

            geometry = new THREE.TorusKnotGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.p,
              data.q,
              data.heightScale
            );

            break;

          case 'BufferGeometry':

            geometry = bufferGeometryLoader.parse( data.data );

            break;

          case 'Geometry':

            geometry = geometryLoader.parse( data.data ).geometry;

            break;

        }

        geometry.uuid = data.uuid;

        if ( data.name !== undefined ) geometry.name = data.name;

        geometries[ data.uuid ] = geometry;

      }

    }

    return geometries;

  },

  parseMaterials: function ( json ) {

    var materials = {};

    if ( json !== undefined ) {

      var loader = new THREE.MaterialLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var data = json[ i ];
        var material = loader.parse( data );

        material.uuid = data.uuid;

        if ( data.name !== undefined ) material.name = data.name;

        materials[ data.uuid ] = material;

      }

    }

    return materials;

  },

  parseObject: function () {

    var matrix = new THREE.Matrix4();

    return function ( data, geometries, materials ) {

      var object;

      switch ( data.type ) {

        case 'Scene':

          object = new THREE.Scene();

          break;

        case 'PerspectiveCamera':

          object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

          break;

        case 'OrthographicCamera':

          object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

          break;

        case 'AmbientLight':

          object = new THREE.AmbientLight( data.color );

          break;

        case 'DirectionalLight':

          object = new THREE.DirectionalLight( data.color, data.intensity );

          break;

        case 'PointLight':

          object = new THREE.PointLight( data.color, data.intensity, data.distance );

          break;

        case 'SpotLight':

          object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

          break;

        case 'HemisphereLight':

          object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

          break;

        case 'Mesh':

          var geometry = geometries[ data.geometry ];
          var material = materials[ data.material ];

          if ( geometry === undefined ) {

            console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

          }

          if ( material === undefined ) {

            console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

          }

          object = new THREE.Mesh( geometry, material );

          break;

        case 'Line':

          var geometry = geometries[ data.geometry ];
          var material = materials[ data.material ];

          if ( geometry === undefined ) {

            console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

          }

          if ( material === undefined ) {

            console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

          }

          object = new THREE.Line( geometry, material );

          break;

        case 'Sprite':

          var material = materials[ data.material ];

          if ( material === undefined ) {

            console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

          }

          object = new THREE.Sprite( material );

          break;

        case 'Group':

          object = new THREE.Group();

          break;

        default:

          object = new THREE.Object3D();

      }

      object.uuid = data.uuid;

      if ( data.name !== undefined ) object.name = data.name;
      if ( data.matrix !== undefined ) {

        matrix.fromArray( data.matrix );
        matrix.decompose( object.position, object.quaternion, object.scale );

      } else {

        if ( data.position !== undefined ) object.position.fromArray( data.position );
        if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
        if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

      }

      if ( data.visible !== undefined ) object.visible = data.visible;
      if ( data.userData !== undefined ) object.userData = data.userData;

      if ( data.children !== undefined ) {

        for ( var child in data.children ) {

          object.add( this.parseObject( data.children[ child ], geometries, materials ) );

        }

      }

      return object;

    }

  }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

  constructor: THREE.TextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.ImageLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( image ) {

      var texture = new THREE.Texture( image );
      texture.needsUpdate = true;

      if ( onLoad !== undefined ) {

        onLoad( texture );

      }

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function () {

  // override in sub classes
  this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

  constructor: THREE.CompressedTextureLoader,

  load: function ( url, onLoad, onError ) {

    var scope = this;

    var images = [];

    var texture = new THREE.CompressedTexture();
    texture.image = images;

    var loader = new THREE.XHRLoader();
    loader.setResponseType( 'arraybuffer' );

    if ( url instanceof Array ) {

      var loaded = 0;

      var loadTexture = function ( i ) {

        loader.load( url[ i ], function ( buffer ) {

          var texDatas = scope._parser( buffer, true );

          images[ i ] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };

          loaded += 1;

          if ( loaded === 6 ) {

            if (texDatas.mipmapCount == 1)
              texture.minFilter = THREE.LinearFilter;

            texture.format = texDatas.format;
            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

          }

        } );

      };

      for ( var i = 0, il = url.length; i < il; ++ i ) {

        loadTexture( i );

      }

    } else {

      // compressed cubemap texture stored in a single DDS file

      loader.load( url, function ( buffer ) {

        var texDatas = scope._parser( buffer, true );

        if ( texDatas.isCubemap ) {

          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for ( var f = 0; f < faces; f ++ ) {

            images[ f ] = { mipmaps : [] };

            for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

              images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
              images[ f ].format = texDatas.format;
              images[ f ].width = texDatas.width;
              images[ f ].height = texDatas.height;

            }

          }

        } else {

          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;

        }

        if ( texDatas.mipmapCount === 1 ) {

          texture.minFilter = THREE.LinearFilter;

        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;

        if ( onLoad ) onLoad( texture );

      } );

    }

    return texture;

  }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

  Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Material';

  this.side = THREE.FrontSide;

  this.opacity = 1;
  this.transparent = false;

  this.blending = THREE.NormalBlending;

  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;

  this.depthTest = true;
  this.depthWrite = true;

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;

  this.alphaTest = 0;

  this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  this.visible = true;

  this.needsUpdate = true;

};

THREE.Material.prototype = {

  constructor: THREE.Material,

  setValues: function ( values ) {

    if ( values === undefined ) return;

    for ( var key in values ) {

      var newValue = values[ key ];

      if ( newValue === undefined ) {

        console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
        continue;

      }

      if ( key in this ) {

        var currentValue = this[ key ];

        if ( currentValue instanceof THREE.Color ) {

          currentValue.set( newValue );

        } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

          currentValue.copy( newValue );

        } else if ( key == 'overdraw' ) {

          // ensure overdraw is backwards-compatable with legacy boolean type
          this[ key ] = Number( newValue );

        } else {

          this[ key ] = newValue;

        }

      }

    }

  },

  toJSON: function () {

    var output = {
      metadata: {
        version: 4.2,
        type: 'material',
        generator: 'MaterialExporter'
      },
      uuid: this.uuid,
      type: this.type
    };

    if ( this.name !== "" ) output.name = this.name;

    if ( this instanceof THREE.MeshBasicMaterial ) {

      output.color = this.color.getHex();
      if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
      if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
      if ( this.side !== THREE.FrontSide ) output.side = this.side;

    } else if ( this instanceof THREE.MeshLambertMaterial ) {

      output.color = this.color.getHex();
      output.ambient = this.ambient.getHex();
      output.emissive = this.emissive.getHex();
      if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
      if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
      if ( this.side !== THREE.FrontSide ) output.side = this.side;

    } else if ( this instanceof THREE.MeshPhongMaterial ) {

      output.color = this.color.getHex();
      output.ambient = this.ambient.getHex();
      output.emissive = this.emissive.getHex();
      output.specular = this.specular.getHex();
      output.shininess = this.shininess;
      if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
      if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
      if ( this.side !== THREE.FrontSide ) output.side = this.side;

    } else if ( this instanceof THREE.MeshNormalMaterial ) {

      if ( this.shading !== THREE.FlatShading ) output.shading = this.shading;
      if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
      if ( this.side !== THREE.FrontSide ) output.side = this.side;

    } else if ( this instanceof THREE.MeshDepthMaterial ) {

      if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
      if ( this.side !== THREE.FrontSide ) output.side = this.side;

    } else if ( this instanceof THREE.ShaderMaterial ) {

      output.uniforms = this.uniforms;
      output.vertexShader = this.vertexShader;
      output.fragmentShader = this.fragmentShader;

    } else if ( this instanceof THREE.SpriteMaterial ) {

      output.color = this.color.getHex();

    }

    if ( this.opacity < 1 ) output.opacity = this.opacity;
    if ( this.transparent !== false ) output.transparent = this.transparent;
    if ( this.wireframe !== false ) output.wireframe = this.wireframe;

    return output;

  },

  clone: function ( material ) {

    if ( material === undefined ) material = new THREE.Material();

    material.name = this.name;

    material.side = this.side;

    material.opacity = this.opacity;
    material.transparent = this.transparent;

    material.blending = this.blending;

    material.blendSrc = this.blendSrc;
    material.blendDst = this.blendDst;
    material.blendEquation = this.blendEquation;

    material.depthTest = this.depthTest;
    material.depthWrite = this.depthWrite;

    material.polygonOffset = this.polygonOffset;
    material.polygonOffsetFactor = this.polygonOffsetFactor;
    material.polygonOffsetUnits = this.polygonOffsetUnits;

    material.alphaTest = this.alphaTest;

    material.overdraw = this.overdraw;

    material.visible = this.visible;

    return material;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineBasicMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

  var material = new THREE.LineBasicMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.linewidth = this.linewidth;
  material.linecap = this.linecap;
  material.linejoin = this.linejoin;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineDashedMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;

  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;

  this.vertexColors = false;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

  var material = new THREE.LineDashedMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.linewidth = this.linewidth;

  material.scale = this.scale;
  material.dashSize = this.dashSize;
  material.gapSize = this.gapSize;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshBasicMaterial';

  this.color = new THREE.Color( 0xffffff ); // emissive

  this.map = null;

  this.lightMap = null;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

  var material = new THREE.MeshBasicMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.map = this.map;

  material.lightMap = this.lightMap;

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;

  return material;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshLambertMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.ambient = new THREE.Color( 0xffffff );
  this.emissive = new THREE.Color( 0x000000 );

  this.wrapAround = false;
  this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

  this.map = null;

  this.lightMap = null;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

  var material = new THREE.MeshLambertMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.ambient.copy( this.ambient );
  material.emissive.copy( this.emissive );

  material.wrapAround = this.wrapAround;
  material.wrapRGB.copy( this.wrapRGB );

  material.map = this.map;

  material.lightMap = this.lightMap;

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshPhongMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.ambient = new THREE.Color( 0xffffff );
  this.emissive = new THREE.Color( 0x000000 );
  this.specular = new THREE.Color( 0x111111 );
  this.shininess = 30;

  this.metal = false;

  this.wrapAround = false;
  this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

  this.map = null;

  this.lightMap = null;

  this.bumpMap = null;
  this.bumpScale = 1;

  this.normalMap = null;
  this.normalScale = new THREE.Vector2( 1, 1 );

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

  var material = new THREE.MeshPhongMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.ambient.copy( this.ambient );
  material.emissive.copy( this.emissive );
  material.specular.copy( this.specular );
  material.shininess = this.shininess;

  material.metal = this.metal;

  material.wrapAround = this.wrapAround;
  material.wrapRGB.copy( this.wrapRGB );

  material.map = this.map;

  material.lightMap = this.lightMap;

  material.bumpMap = this.bumpMap;
  material.bumpScale = this.bumpScale;

  material.normalMap = this.normalMap;
  material.normalScale.copy( this.normalScale );

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshDepthMaterial';

  this.morphTargets = false;
  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

  var material = new THREE.MeshDepthMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  return material;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

  THREE.Material.call( this, parameters );

  this.type = 'MeshNormalMaterial';

  this.shading = THREE.FlatShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

  var material = new THREE.MeshNormalMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  return material;

};

// File:src/materials/MeshFaceMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

  this.uuid = THREE.Math.generateUUID();

  this.type = 'MeshFaceMaterial';
  
  this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype = {

  constructor: THREE.MeshFaceMaterial,

  toJSON: function () {

    var output = {
      metadata: {
        version: 4.2,
        type: 'material',
        generator: 'MaterialExporter'
      },
      uuid: this.uuid,
      type: this.type,
      materials: []
    };

    for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

      output.materials.push( this.materials[ i ].toJSON() );

    }

    return output;

  },

  clone: function () {

    var material = new THREE.MeshFaceMaterial();

    for ( var i = 0; i < this.materials.length; i ++ ) {

      material.materials.push( this.materials[ i ].clone() );

    }

    return material;

  }

};

// File:src/materials/PointCloudMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointCloudMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'PointCloudMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.map = null;

  this.size = 1;
  this.sizeAttenuation = true;

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.PointCloudMaterial.prototype.clone = function () {

  var material = new THREE.PointCloudMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.map = this.map;

  material.size = this.size;
  material.sizeAttenuation = this.sizeAttenuation;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = function ( parameters ) {

  console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
  return new THREE.PointCloudMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

  console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
  return new THREE.PointCloudMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'ShaderMaterial';

  this.defines = {};
  this.uniforms = {};
  this.attributes = null;

  this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

  this.shading = THREE.SmoothShading;

  this.linewidth = 1;

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets
  this.morphNormals = false; // set to use morph normals

  // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues = {
    'color': [ 1, 1, 1 ],
    'uv': [ 0, 0 ],
    'uv2': [ 0, 0 ]
  };

  this.index0AttributeName = undefined;

  this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

  var material = new THREE.ShaderMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.fragmentShader = this.fragmentShader;
  material.vertexShader = this.vertexShader;

  material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

  material.attributes = this.attributes;
  material.defines = this.defines;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  material.fog = this.fog;

  material.lights = this.lights;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;

  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

  THREE.ShaderMaterial.call( this, parameters );

  this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

THREE.RawShaderMaterial.prototype.clone = function () {

  var material = new THREE.RawShaderMaterial();

  THREE.ShaderMaterial.prototype.clone.call( this, material );

  return material;

};

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  uvOffset: new THREE.Vector2(),
 *  uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'SpriteMaterial';

  this.color = new THREE.Color( 0xffffff );
  this.map = null;

  this.rotation = 0;

  this.fog = false;

  // set parameters

  this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

  var material = new THREE.SpriteMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.map = this.map;

  material.rotation = this.rotation;

  material.fog = this.fog;

  return material;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';

  this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
  this.mipmaps = [];

  this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  this.format = format !== undefined ? format : THREE.RGBAFormat;
  this.type = type !== undefined ? type : THREE.UnsignedByteType;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  this._needsUpdate = false;
  this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping();

THREE.Texture.prototype = {

  constructor: THREE.Texture,

  get needsUpdate () {

    return this._needsUpdate;

  },

  set needsUpdate ( value ) {

    if ( value === true ) this.update();

    this._needsUpdate = value;

  },

  clone: function ( texture ) {

    if ( texture === undefined ) texture = new THREE.Texture();

    texture.image = this.image;
    texture.mipmaps = this.mipmaps.slice( 0 );

    texture.mapping = this.mapping;

    texture.wrapS = this.wrapS;
    texture.wrapT = this.wrapT;

    texture.magFilter = this.magFilter;
    texture.minFilter = this.minFilter;

    texture.anisotropy = this.anisotropy;

    texture.format = this.format;
    texture.type = this.type;

    texture.offset.copy( this.offset );
    texture.repeat.copy( this.repeat );

    texture.generateMipmaps = this.generateMipmaps;
    texture.premultiplyAlpha = this.premultiplyAlpha;
    texture.flipY = this.flipY;
    texture.unpackAlignment = this.unpackAlignment;

    return texture;

  },

  update: function () {

    this.dispatchEvent( { type: 'update' } );

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.images = images;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CubeTexture.clone = function ( texture ) {

  if ( texture === undefined ) texture = new THREE.CubeTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  texture.images = this.images;

  return texture;

};

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { width: width, height: height };
  this.mipmaps = mipmaps;

  // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false;

  // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

  var texture = new THREE.CompressedTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  return texture;

};

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

  var texture = new THREE.DataTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  return texture;

};

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.generateMipmaps = false;

  var scope = this;

  var update = function () {

    requestAnimationFrame( update );

    if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

      scope.needsUpdate = true;

    }

  };

  update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

  THREE.Object3D.call( this );

  this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );

// File:src/objects/PointCloud.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PointCloud = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'PointCloud';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

  this.sortParticles = false;

};

THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );

THREE.PointCloud.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();

  return function ( raycaster, intersects ) {

    var object = this;
    var geometry = object.geometry;
    var threshold = raycaster.params.PointCloud.threshold;

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    if ( geometry.boundingBox !== null ) {

      if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

        return;

      }

    }

    var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    var position = new THREE.Vector3();

    var testPoint = function ( point, index ) {

      var rayPointDistance = ray.distanceToPoint( point );

      if ( rayPointDistance < localThreshold ) {

        var intersectPoint = ray.closestPointToPoint( point );
        intersectPoint.applyMatrix4( object.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectPoint );

        intersects.push( {

          distance: distance,
          distanceToRay: rayPointDistance,
          point: intersectPoint.clone(),
          index: index,
          face: null,
          object: object

        } );

      }

    };

    if ( geometry instanceof THREE.BufferGeometry ) {

      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          var offset = {
            start: 0,
            count: indices.length,
            index: 0
          };

          offsets = [ offset ];

        }

        for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

          var start = offsets[ oi ].start;
          var count = offsets[ oi ].count;
          var index = offsets[ oi ].index;

          for ( var i = start, il = start + count; i < il; i ++ ) {

            var a = index + indices[ i ];

            position.fromArray( positions, a * 3 );

            testPoint( position, a );

          }

        }

      } else {

        var pointCount = positions.length / 3;

        for ( var i = 0; i < pointCount; i ++ ) {

          position.set(
            positions[ 3 * i ],
            positions[ 3 * i + 1 ],
            positions[ 3 * i + 2 ]
          );

          testPoint( position, i );

        }

      }

    } else {

      var vertices = this.geometry.vertices;

      for ( var i = 0; i < vertices.length; i ++ ) {

        testPoint( vertices[ i ], i );

      }

    }

  };

}() );

THREE.PointCloud.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

  object.sortParticles = this.sortParticles;

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

// Backwards compatibility

THREE.ParticleSystem = function ( geometry, material ) {

  console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
  return new THREE.PointCloud( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

  THREE.Object3D.call( this );

  this.type = 'Line';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

  this.mode = ( mode !== undefined ) ? mode : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  return function ( raycaster, intersects ) {

    var precision = raycaster.linePrecision;
    var precisionSq = precision * precision;

    var geometry = this.geometry;

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    // Checking boundingSphere distance to ray

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( this.matrixWorld );

    if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

      return;

    }

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    /* if ( geometry instanceof THREE.BufferGeometry ) {

    } else */ if ( geometry instanceof THREE.Geometry ) {

      var vertices = geometry.vertices;
      var nbVertices = vertices.length;
      var interSegment = new THREE.Vector3();
      var interRay = new THREE.Vector3();
      var step = this.mode === THREE.LineStrip ? 1 : 2;

      for ( var i = 0; i < nbVertices - 1; i = i + step ) {

        var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

        if ( distSq > precisionSq ) continue;

        var distance = ray.origin.distanceTo( interRay );

        if ( distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4( this.matrixWorld ),
          face: null,
          faceIndex: null,
          object: this

        } );

      }

    }

  };

}() );

THREE.Line.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'Mesh';
  
  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

  this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

  if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

    this.morphTargetBase = - 1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};

    for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

      this.morphTargetInfluences.push( 0 );
      this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

    }

  }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

  if ( this.morphTargetDictionary[ name ] !== undefined ) {

    return this.morphTargetDictionary[ name ];

  }

  console.log( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

  return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  var vA = new THREE.Vector3();
  var vB = new THREE.Vector3();
  var vC = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    var geometry = this.geometry;

    // Checking boundingSphere distance to ray

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( this.matrixWorld );

    if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

      return;

    }

    // Check boundingBox before continuing

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    if ( geometry.boundingBox !== null ) {

      if ( ray.isIntersectionBox( geometry.boundingBox ) === false )  {

        return;

      }

    }

    if ( geometry instanceof THREE.BufferGeometry ) {

      var material = this.material;

      if ( material === undefined ) return;

      var attributes = geometry.attributes;

      var a, b, c;
      var precision = raycaster.precision;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var positions = attributes.position.array;
        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          offsets = [ { start: 0, count: indices.length, index: 0 } ];

        }

        for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

          var start = offsets[ oi ].start;
          var count = offsets[ oi ].count;
          var index = offsets[ oi ].index;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            a = index + indices[ i ];
            b = index + indices[ i + 1 ];
            c = index + indices[ i + 2 ];

            vA.fromArray( positions, a * 3 );
            vB.fromArray( positions, b * 3 );
            vC.fromArray( positions, c * 3 );

            if ( material.side === THREE.BackSide ) {

              var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

            } else {

              var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

            }

            if ( intersectionPoint === null ) continue;

            intersectionPoint.applyMatrix4( this.matrixWorld );

            var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

            if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

            intersects.push( {

              distance: distance,
              point: intersectionPoint,
              face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
              faceIndex: null,
              object: this

            } );

          }

        }

      } else {

        var positions = attributes.position.array;

        for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

          a = i;
          b = i + 1;
          c = i + 2;

          vA.fromArray( positions, j );
          vB.fromArray( positions, j + 3 );
          vC.fromArray( positions, j + 6 );

          if ( material.side === THREE.BackSide ) {

            var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

          } else {

            var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

          }

          if ( intersectionPoint === null ) continue;

          intersectionPoint.applyMatrix4( this.matrixWorld );

          var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

          if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

          intersects.push( {

            distance: distance,
            point: intersectionPoint,
            face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
            faceIndex: null,
            object: this

          } );

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
      var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

      var a, b, c, d;
      var precision = raycaster.precision;

      var vertices = geometry.vertices;

      for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

        var face = geometry.faces[ f ];

        var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

        if ( material === undefined ) continue;

        a = vertices[ face.a ];
        b = vertices[ face.b ];
        c = vertices[ face.c ];

        if ( material.morphTargets === true ) {

          var morphTargets = geometry.morphTargets;
          var morphInfluences = this.morphTargetInfluences;

          vA.set( 0, 0, 0 );
          vB.set( 0, 0, 0 );
          vC.set( 0, 0, 0 );

          for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

            var influence = morphInfluences[ t ];

            if ( influence === 0 ) continue;

            var targets = morphTargets[ t ].vertices;

            vA.x += ( targets[ face.a ].x - a.x ) * influence;
            vA.y += ( targets[ face.a ].y - a.y ) * influence;
            vA.z += ( targets[ face.a ].z - a.z ) * influence;

            vB.x += ( targets[ face.b ].x - b.x ) * influence;
            vB.y += ( targets[ face.b ].y - b.y ) * influence;
            vB.z += ( targets[ face.b ].z - b.z ) * influence;

            vC.x += ( targets[ face.c ].x - c.x ) * influence;
            vC.y += ( targets[ face.c ].y - c.y ) * influence;
            vC.z += ( targets[ face.c ].z - c.z ) * influence;

          }

          vA.add( a );
          vB.add( b );
          vC.add( c );

          a = vA;
          b = vB;
          c = vC;

        }

        if ( material.side === THREE.BackSide ) {

          var intersectionPoint = ray.intersectTriangle( c, b, a, true );

        } else {

          var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

        }

        if ( intersectionPoint === null ) continue;

        intersectionPoint.applyMatrix4( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

        if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          point: intersectionPoint,
          face: face,
          faceIndex: f,
          object: this

        } );

      }

    }

  };

}() );

THREE.Mesh.prototype.clone = function ( object, recursive ) {

  if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

  THREE.Object3D.prototype.clone.call( this, object, recursive );

  return object;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( belongsToSkin ) {

  THREE.Object3D.call( this );

  this.skin = belongsToSkin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );


// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

  this.identityMatrix = new THREE.Matrix4();

  // copy the bone array

  bones = bones || [];

  this.bones = bones.slice( 0 );

  // create a bone texture or an array of floats

  if ( this.useVertexTexture ) {

    // layout (1 matrix = 4 pixels)
    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    //  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
    //       16x16 pixel texture max   64 bones (16 * 16 / 4)
    //       32x32 pixel texture max  256 bones (32 * 32 / 4)
    //       64x64 pixel texture max 1024 bones (64 * 64 / 4)

    var size;

    if ( this.bones.length > 256 )
      size = 64;
    else if ( this.bones.length > 64 )
      size = 32;
    else if ( this.bones.length > 16 )
      size = 16;
    else
      size = 8;

    this.boneTextureWidth = size;
    this.boneTextureHeight = size;

    this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
    this.boneTexture.minFilter = THREE.NearestFilter;
    this.boneTexture.magFilter = THREE.NearestFilter;
    this.boneTexture.generateMipmaps = false;
    this.boneTexture.flipY = false;

  } else {

    this.boneMatrices = new Float32Array( 16 * this.bones.length );

  }

  // use the supplied bone inverses or calculate the inverses

  if ( boneInverses === undefined ) {

    this.calculateInverses();

  } else {

    if ( this.bones.length === boneInverses.length ) {

      this.boneInverses = boneInverses.slice( 0 );

    } else {

      console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

      this.boneInverses = [];

      for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        this.boneInverses.push( new THREE.Matrix4() );

      }

    }

  }

};

THREE.Skeleton.prototype.calculateInverses = function () {

  this.boneInverses = [];

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    var inverse = new THREE.Matrix4();

    if ( this.bones[ b ] ) {

      inverse.getInverse( this.bones[ b ].matrixWorld );

    }

    this.boneInverses.push( inverse );

  }

};

THREE.Skeleton.prototype.pose = function () {

  var bone;

  // recover the bind-time world matrices

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    }

  }

  // compute the local matrices, positions, rotations and scales

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      if ( bone.parent ) {

        bone.matrix.getInverse( bone.parent.matrixWorld );
        bone.matrix.multiply( bone.matrixWorld );

      } else {

        bone.matrix.copy( bone.matrixWorld );

      }

      bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    }

  }

};

THREE.Skeleton.prototype.update = ( function () {

  var offsetMatrix = new THREE.Matrix4();
  
  return function () {

    // flatten bone matrices to array

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

      // compute the offset between the current and the original transform

      var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

      offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
      offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

    }

    if ( this.useVertexTexture ) {

      this.boneTexture.needsUpdate = true;

    }
    
  };

} )();


// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'SkinnedMesh';

  this.bindMode = "attached";
  this.bindMatrix = new THREE.Matrix4();
  this.bindMatrixInverse = new THREE.Matrix4();

  // init bones

  // TODO: remove bone creation as there is no reason (other than
  // convenience) for THREE.SkinnedMesh to do this.

  var bones = [];

  if ( this.geometry && this.geometry.bones !== undefined ) {

    var bone, gbone, p, q, s;

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

      gbone = this.geometry.bones[ b ];

      p = gbone.pos;
      q = gbone.rotq;
      s = gbone.scl;

      bone = new THREE.Bone( this );
      bones.push( bone );

      bone.name = gbone.name;
      bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
      bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

      if ( s !== undefined ) {

        bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

      } else {

        bone.scale.set( 1, 1, 1 );

      }

    }

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

      gbone = this.geometry.bones[ b ];

      if ( gbone.parent !== - 1 ) {

        bones[ gbone.parent ].add( bones[ b ] );

      } else {

        this.add( bones[ b ] );

      }

    }

  }

  this.normalizeSkinWeights();

  this.updateMatrixWorld( true );
  this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

  this.skeleton = skeleton;

  if ( bindMatrix === undefined ) {

    this.updateMatrixWorld( true );

    bindMatrix = this.matrixWorld;

  }

  this.bindMatrix.copy( bindMatrix );
  this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

  this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

  if ( this.geometry instanceof THREE.Geometry ) {

    for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

      var sw = this.geometry.skinWeights[ i ];

      var scale = 1.0 / sw.lengthManhattan();

      if ( scale !== Infinity ) {

        sw.multiplyScalar( scale );

      } else {

        sw.set( 1 ); // this will be normalized by the shader anyway

      }

    }

  } else {

    // skinning weights assumed to be normalized for THREE.BufferGeometry

  }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

  THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

  if ( this.bindMode === "attached" ) {

    this.bindMatrixInverse.getInverse( this.matrixWorld );

  } else if ( this.bindMode === "detached" ) {

    this.bindMatrixInverse.getInverse( this.bindMatrix );

  } else {

    console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

  }

};

THREE.SkinnedMesh.prototype.clone = function( object ) {

  if ( object === undefined ) {

    object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

  }

  THREE.Mesh.prototype.clone.call( this, object );

  return object;

};


// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'MorphAnimMesh';

  // API

  this.duration = 1000; // milliseconds
  this.mirroredLoop = false;
  this.time = 0;

  // internals

  this.lastKeyframe = 0;
  this.currentKeyframe = 0;

  this.direction = 1;
  this.directionBackwards = false;

  this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

  this.startKeyframe = start;
  this.endKeyframe = end;

  this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

  this.direction = 1;
  this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

  this.direction = - 1;
  this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

  var geometry = this.geometry;

  if ( ! geometry.animations ) geometry.animations = {};

  var firstAnimation, animations = geometry.animations;

  var pattern = /([a-z]+)_?(\d+)/;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var parts = morph.name.match( pattern );

    if ( parts && parts.length > 1 ) {

      var label = parts[ 1 ];
      var num = parts[ 2 ];

      if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

      var animation = animations[ label ];

      if ( i < animation.start ) animation.start = i;
      if ( i > animation.end ) animation.end = i;

      if ( ! firstAnimation ) firstAnimation = label;

    }

  }

  geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

  if ( ! this.geometry.animations ) this.geometry.animations = {};

  this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

  var animation = this.geometry.animations[ label ];

  if ( animation ) {

    this.setFrameRange( animation.start, animation.end );
    this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
    this.time = 0;

  } else {

    console.warn( 'animation[' + label + '] undefined' );

  }

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

  var frameTime = this.duration / this.length;

  this.time += this.direction * delta;

  if ( this.mirroredLoop ) {

    if ( this.time > this.duration || this.time < 0 ) {

      this.direction *= - 1;

      if ( this.time > this.duration ) {

        this.time = this.duration;
        this.directionBackwards = true;

      }

      if ( this.time < 0 ) {

        this.time = 0;
        this.directionBackwards = false;

      }

    }

  } else {

    this.time = this.time % this.duration;

    if ( this.time < 0 ) this.time += this.duration;

  }

  var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

  if ( keyframe !== this.currentKeyframe ) {

    this.morphTargetInfluences[ this.lastKeyframe ] = 0;
    this.morphTargetInfluences[ this.currentKeyframe ] = 1;

    this.morphTargetInfluences[ keyframe ] = 0;

    this.lastKeyframe = this.currentKeyframe;
    this.currentKeyframe = keyframe;

  }

  var mix = ( this.time % frameTime ) / frameTime;

  if ( this.directionBackwards ) {

    mix = 1 - mix;

  }

  this.morphTargetInfluences[ this.currentKeyframe ] = mix;
  this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

  var influences = this.morphTargetInfluences;

  for ( var i = 0, l = influences.length; i < l; i ++ ) {

    influences[ i ] = 0;

  }

  if ( a > -1 ) influences[ a ] = 1 - t;
  if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

  object.duration = this.duration;
  object.mirroredLoop = this.mirroredLoop;
  object.time = this.time;

  object.lastKeyframe = this.lastKeyframe;
  object.currentKeyframe = this.currentKeyframe;

  object.direction = this.direction;
  object.directionBackwards = this.directionBackwards;

  THREE.Mesh.prototype.clone.call( this, object );

  return object;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

  THREE.Object3D.call( this );

  this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object, distance ) {

  if ( distance === undefined ) distance = 0;

  distance = Math.abs( distance );

  for ( var l = 0; l < this.objects.length; l ++ ) {

    if ( distance < this.objects[ l ].distance ) {

      break;

    }

  }

  this.objects.splice( l, 0, { distance: distance, object: object } );
  this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

  for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

    if ( distance < this.objects[ i ].distance ) {

      break;

    }

  }

  return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  };

}() );

THREE.LOD.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function ( camera ) {

    if ( this.objects.length > 1 ) {

      v1.setFromMatrixPosition( camera.matrixWorld );
      v2.setFromMatrixPosition( this.matrixWorld );

      var distance = v1.distanceTo( v2 );

      this.objects[ 0 ].object.visible = true;

      for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

        if ( distance >= this.objects[ i ].distance ) {

          this.objects[ i - 1 ].object.visible = false;
          this.objects[ i     ].object.visible = true;

        } else {

          break;

        }

      }

      for ( ; i < l; i ++ ) {

        this.objects[ i ].object.visible = false;

      }

    }

  };

}();

THREE.LOD.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.LOD();

  THREE.Object3D.prototype.clone.call( this, object );

  for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
    var x = this.objects[ i ].object.clone();
    x.visible = i === 0;
    object.addLevel( x, this.objects[ i ].distance );
  }

  return object;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

  var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
  var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
  var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  return function ( material ) {

    THREE.Object3D.call( this );

    this.type = 'Sprite';

    this.geometry = geometry;
    this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

  };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

THREE.Sprite.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distance = raycaster.ray.distanceToPoint( matrixPosition );

    if ( distance > this.scale.x ) {

      return;

    }

    intersects.push( {

      distance: distance,
      point: this.position,
      face: null,
      object: this

    } );

  };

}() );

THREE.Sprite.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.Sprite( this.material );

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

  THREE.Object3D.call( this );

  this.lensFlares = [];

  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = undefined;

  if( texture !== undefined ) {

    this.add( texture, size, distance, blending, color );

  }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

  if ( size === undefined ) size = - 1;
  if ( distance === undefined ) distance = 0;
  if ( opacity === undefined ) opacity = 1;
  if ( color === undefined ) color = new THREE.Color( 0xffffff );
  if ( blending === undefined ) blending = THREE.NormalBlending;

  distance = Math.min( distance, Math.max( 0, distance ) );

  this.lensFlares.push( {
    texture: texture,       // THREE.Texture
    size: size,         // size in pixels (-1 = use texture.width)
    distance: distance,     // distance (0-1) from light source (0=at light source)
    x: 0, y: 0, z: 0,     // screen position (-1 => 1) z = 0 is ontop z = 1 is back
    scale: 1,           // scale
    rotation: 1,        // rotation
    opacity: opacity,     // opacity
    color: color,       // color
    blending: blending      // blending
  } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

  var f, fl = this.lensFlares.length;
  var flare;
  var vecX = - this.positionScreen.x * 2;
  var vecY = - this.positionScreen.y * 2;

  for( f = 0; f < fl; f ++ ) {

    flare = this.lensFlares[ f ];

    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;

    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

  }

};


// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

  THREE.Object3D.call( this );

  this.type = 'Scene';

  this.fog = null;
  this.overrideMaterial = null;

  this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.Scene();

  THREE.Object3D.prototype.clone.call( this, object );

  if ( this.fog !== null ) object.fog = this.fog.clone();
  if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

  object.autoUpdate = this.autoUpdate;
  object.matrixAutoUpdate = this.matrixAutoUpdate;

  return object;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

  this.name = '';

  this.color = new THREE.Color( color );

  this.near = ( near !== undefined ) ? near : 1;
  this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

  return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

  this.name = '';

  this.color = new THREE.Color( color );
  this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

  return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n  if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n  vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n  vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n vec3 dirVector = normalize( lDirection.xyz );\n\n float dotProduct = dot( transformedNormal, dirVector );\n vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n  #ifdef DOUBLE_SIDED\n\n   vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n   #ifdef WRAP_AROUND\n\n      vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n   #endif\n\n  #endif\n\n  #ifdef WRAP_AROUND\n\n    vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n    directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n   #ifdef DOUBLE_SIDED\n\n     directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n   #endif\n\n  #endif\n\n  vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n #endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n    vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n   vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n    float lDistance = 1.0;\n    if ( pointLightDistance[ i ] > 0.0 )\n      lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n    lVector = normalize( lVector );\n   float dotProduct = dot( transformedNormal, lVector );\n\n   vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n    #ifdef DOUBLE_SIDED\n\n     vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n     #ifdef WRAP_AROUND\n\n        vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n     #endif\n\n    #endif\n\n    #ifdef WRAP_AROUND\n\n      vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n      pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n     #ifdef DOUBLE_SIDED\n\n       pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n     #endif\n\n    #endif\n\n    vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n    #ifdef DOUBLE_SIDED\n\n     vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n   #endif\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n   vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n    vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n    float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n   if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n      spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n     float lDistance = 1.0;\n      if ( spotLightDistance[ i ] > 0.0 )\n       lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n     lVector = normalize( lVector );\n\n     float dotProduct = dot( transformedNormal, lVector );\n     vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n     #ifdef DOUBLE_SIDED\n\n       vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n        #ifdef WRAP_AROUND\n\n          vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n        #endif\n\n      #endif\n\n      #ifdef WRAP_AROUND\n\n        vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n       spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n        #ifdef DOUBLE_SIDED\n\n         spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n        #endif\n\n      #endif\n\n      vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n     #ifdef DOUBLE_SIDED\n\n       vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n      #endif\n\n    }\n\n }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n   vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n    vec3 lVector = normalize( lDirection.xyz );\n\n   float dotProduct = dot( transformedNormal, lVector );\n\n   float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n   float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n    vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n   #ifdef DOUBLE_SIDED\n\n     vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n    #endif\n\n  }\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n  uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

THREE.ShaderChunk[ 'default_vertex'] = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n mvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n  mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n  varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n  mat4 skinMatrix = mat4( 0.0 );\n  skinMatrix += skinWeight.x * boneMatX;\n  skinMatrix += skinWeight.y * boneMatY;\n  skinMatrix += skinWeight.z * boneMatZ;\n  skinMatrix += skinWeight.w * boneMatW;\n  skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n  #ifdef USE_MORPHNORMALS\n\n vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n #else\n\n vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n    varying float vFragDepth;\n\n #endif\n\n  uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl

THREE.ShaderChunk[ 'lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n vec3 pointDiffuse = vec3( 0.0 );\n  vec3 pointSpecular = vec3( 0.0 );\n\n for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n   vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n   vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n   float lDistance = 1.0;\n    if ( pointLightDistance[ i ] > 0.0 )\n      lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n    lVector = normalize( lVector );\n\n       // diffuse\n\n    float dotProduct = dot( normal, lVector );\n\n    #ifdef WRAP_AROUND\n\n      float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n      float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n      vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n   #else\n\n     float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n    #endif\n\n    pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n        // specular\n\n   vec3 pointHalfVector = normalize( lVector + viewPosition );\n   float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n    float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n    float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n    vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n   pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  vec3 spotDiffuse = vec3( 0.0 );\n vec3 spotSpecular = vec3( 0.0 );\n\n  for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n    vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n    vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n   float lDistance = 1.0;\n    if ( spotLightDistance[ i ] > 0.0 )\n     lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n   lVector = normalize( lVector );\n\n   float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n    if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n      spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n         // diffuse\n\n      float dotProduct = dot( normal, lVector );\n\n      #ifdef WRAP_AROUND\n\n        float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n       float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n       vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n      #else\n\n       float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n     #endif\n\n      spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n          // specular\n\n     vec3 spotHalfVector = normalize( lVector + viewPosition );\n      float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n      float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n      float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n      vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n      spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n    }\n\n }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n vec3 dirDiffuse = vec3( 0.0 );\n  vec3 dirSpecular = vec3( 0.0 );\n\n for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n   vec3 dirVector = normalize( lDirection.xyz );\n\n       // diffuse\n\n    float dotProduct = dot( normal, dirVector );\n\n    #ifdef WRAP_AROUND\n\n      float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n      float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n      vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n   #else\n\n     float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n    #endif\n\n    dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n    // specular\n\n   vec3 dirHalfVector = normalize( dirVector + viewPosition );\n   float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n    float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n    /*\n    // fresnel term from skin shader\n    const float F0 = 0.128;\n\n   float base = 1.0 - dot( viewPosition, dirHalfVector );\n    float exponential = pow( base, 5.0 );\n\n   float fresnel = exponential + F0 * ( 1.0 - exponential );\n   */\n\n    /*\n    // fresnel term from fresnel shader\n   const float mFresnelBias = 0.08;\n    const float mFresnelScale = 0.3;\n    const float mFresnelPower = 5.0;\n\n    float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n   */\n\n    float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n    //    dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n    vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n   dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  vec3 hemiDiffuse = vec3( 0.0 );\n vec3 hemiSpecular = vec3( 0.0 );\n\n  for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n   vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n    vec3 lVector = normalize( lDirection.xyz );\n\n   // diffuse\n\n    float dotProduct = dot( normal, lVector );\n    float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n   vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n   hemiDiffuse += diffuse * hemiColor;\n\n   // specular (sky light)\n\n   vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n   float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n    float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n    // specular (ground light)\n\n    vec3 lVectorGround = -lVector;\n\n    vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n    float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n    float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n    float dotProductGround = dot( normal, lVectorGround );\n\n    float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n    vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n    vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n    hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n  }\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n  totalDiffuse += dirDiffuse;\n totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  totalDiffuse += hemiDiffuse;\n  totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n  totalDiffuse += pointDiffuse;\n totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  totalDiffuse += spotDiffuse;\n  totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n  gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n\n  #ifdef FOG_EXP2\n\n   uniform float fogDensity;\n\n #else\n\n   uniform float fogNear;\n    uniform float fogFar;\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n vec3 morphedNormal = vec3( 0.0 );\n\n morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n  morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n  morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n  morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n  morphedNormal += normal;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n uniform float reflectivity;\n uniform samplerCube envMap;\n uniform float flipEnvMap;\n uniform int combine;\n\n  #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n    uniform bool useRefract;\n    uniform float refractionRatio;\n\n  #else\n\n   varying vec3 vReflect;\n\n  #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n  gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n     // Per-Pixel Tangent Space Normal Mapping\n     // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n    vec3 q0 = dFdx( eye_pos.xyz );\n    vec3 q1 = dFdy( eye_pos.xyz );\n    vec2 st0 = dFdx( vUv.st );\n    vec2 st1 = dFdy( vUv.st );\n\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n   vec3 N = normalize( surf_norm );\n\n    vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n    mapN.xy = normalScale * mapN.xy;\n    mat3 tsn = mat3( S, T, N );\n   return normalize( tsn * mapN );\n\n }\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n  varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n varying vec2 vUv2;\n  uniform sampler2D lightMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n  for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n   vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n  }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n vWorldPosition = worldPosition.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n  vec4 texelColor = texture2D( map, vUv );\n\n  #ifdef GAMMA_INPUT\n\n    texelColor.xyz *= texelColor.xyz;\n\n #endif\n\n  gl_FragColor = gl_FragColor * texelColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl

THREE.ShaderChunk[ 'lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n  vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n  #ifdef GAMMA_INPUT\n\n    vColor = color * color;\n\n #else\n\n   vColor = color;\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n  #ifdef USE_MORPHTARGETS\n\n vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n  #else\n\n vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n #endif\n\n  vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n  skinned += boneMatY * skinVertex * skinWeight.y;\n  skinned += boneMatZ * skinVertex * skinWeight.z;\n  skinned += boneMatW * skinVertex * skinWeight.w;\n  skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n varying vec3 vReflect;\n\n  uniform float refractionRatio;\n  uniform bool useRefract;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "#ifdef GAMMA_OUTPUT\n\n gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n uniform vec3 wrapRGB;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl

THREE.ShaderChunk[ 'map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n  varying vec2 vUv;\n uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n  vec3 reflectVec;\n\n  #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n    vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n   // http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n    // Transforming Normal Vectors with the Inverse Transformation\n\n    vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n   if ( useRefract ) {\n\n     reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n   } else { \n\n     reflectVec = reflect( cameraToVertex, worldNormal );\n\n    }\n\n #else\n\n   reflectVec = vReflect;\n\n  #endif\n\n  #ifdef DOUBLE_SIDED\n\n   float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n    vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n  #else\n\n   vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n #endif\n\n  #ifdef GAMMA_INPUT\n\n    cubeColor.xyz *= cubeColor.xyz;\n\n #endif\n\n  if ( combine == 1 ) {\n\n   gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n } else if ( combine == 2 ) {\n\n    gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n  } else {\n\n    gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n  }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n  gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n    vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n    gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n  #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n  #ifndef USE_MORPHNORMALS\n\n  uniform float morphTargetInfluences[ 8 ];\n\n #else\n\n uniform float morphTargetInfluences[ 4 ];\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n\n#else\n\n  specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n #else\n\n   float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n  #endif\n\n  #ifdef FOG_EXP2\n\n   const float LOG2 = 1.442695;\n    float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n   fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n #else\n\n   float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n #endif\n  \n  gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n  uniform float bumpScale;\n\n      // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n     //  http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n      // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n    vec2 dSTdx = dFdx( vUv );\n   vec2 dSTdy = dFdy( vUv );\n\n   float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n    float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n    float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n    return vec2( dBx, dBy );\n\n  }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n    vec3 vSigmaX = dFdx( surf_pos );\n    vec3 vSigmaY = dFdy( surf_pos );\n    vec3 vN = surf_norm;    // normalized\n\n   vec3 R1 = cross( vSigmaY, vN );\n   vec3 R2 = cross( vN, vSigmaX );\n\n   float fDet = dot( vSigmaX, R1 );\n\n    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n    return normalize( abs( fDet ) * surf_norm - vGrad );\n\n  }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n objectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n  objectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n  objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n  uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n  mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl

THREE.ShaderChunk[ 'map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n  gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n varying vec4 vShadowCoord[ MAX_SHADOWS ];\n uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n  gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n vec3 morphed = vec3( 0.0 );\n morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n  morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n  morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n  morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n  #ifndef USE_MORPHNORMALS\n\n  morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n  morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n  morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n  morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n  #endif\n\n  morphed += position;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n  vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n worldNormal = normalize( worldNormal );\n\n vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  if ( useRefract ) {\n\n   vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n } else {\n\n    vReflect = reflect( cameraToVertex, worldNormal );\n\n  }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n  #ifdef SHADOWMAP_DEBUG\n\n    vec3 frustumColors[3];\n    frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n   frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n   frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n #endif\n\n  #ifdef SHADOWMAP_CASCADE\n\n    int inFrustumCount = 0;\n\n #endif\n\n  float fDepth;\n vec3 shadowColor = vec3( 1.0 );\n\n for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n   vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n       // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n\n       // don't shadow pixels outside of light frustum\n       // use just first frustum (for cascades)\n        // don't shadow pixels behind far plane of light frustum\n\n    #ifdef SHADOWMAP_CASCADE\n\n      inFrustumCount += int( inFrustum );\n     bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n   #else\n\n     bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n    #endif\n\n    bool frustumTest = all( frustumTestVec );\n\n   if ( frustumTest ) {\n\n      shadowCoord.z += shadowBias[ i ];\n\n     #if defined( SHADOWMAP_TYPE_PCF )\n\n           // Percentage-close filtering\n           // (9 pixel kernel)\n           // http://fabiensanglard.net/shadowmappingPCF/\n\n        float shadow = 0.0;\n\n   /*\n            // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n            // must enroll loop manually\n\n        for ( float y = -1.25; y <= 1.25; y += 1.25 )\n         for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n           vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n               //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n           float fDepth = unpackDepth( rgbaDepth );\n\n            if ( fDepth < shadowCoord.z )\n             shadow += 1.0;\n\n        }\n\n       shadow /= 9.0;\n\n    */\n\n        const float shadowDelta = 1.0 / 9.0;\n\n        float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n        float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n        float dx0 = -1.25 * xPixelOffset;\n       float dy0 = -1.25 * yPixelOffset;\n       float dx1 = 1.25 * xPixelOffset;\n        float dy1 = 1.25 * yPixelOffset;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n        if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n     #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            // Percentage-close filtering\n           // (9 pixel kernel)\n           // http://fabiensanglard.net/shadowmappingPCF/\n\n        float shadow = 0.0;\n\n       float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n        float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n        float dx0 = -1.0 * xPixelOffset;\n        float dy0 = -1.0 * yPixelOffset;\n        float dx1 = 1.0 * xPixelOffset;\n       float dy1 = 1.0 * yPixelOffset;\n\n       mat3 shadowKernel;\n        mat3 depthKernel;\n\n       depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n        depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n        depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n        depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n        depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n       depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n        depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n        depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n        depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n        vec3 shadowZ = vec3( shadowCoord.z );\n       shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n       shadowKernel[0] *= vec3(0.25);\n\n        shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n       shadowKernel[1] *= vec3(0.25);\n\n        shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n       shadowKernel[2] *= vec3(0.25);\n\n        vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n       shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n       shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n       vec4 shadowValues;\n        shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n        shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n        shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n        shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n        shadow = dot( shadowValues, vec4( 1.0 ) );\n\n        shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n     #else\n\n       vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n       float fDepth = unpackDepth( rgbaDepth );\n\n        if ( fDepth < shadowCoord.z )\n\n   // spot with multiple shadows is darker\n\n         shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n    // spot with multiple shadows has the same color as single shadow spot\n\n    //          shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n      #endif\n\n    }\n\n\n   #ifdef SHADOWMAP_DEBUG\n\n      #ifdef SHADOWMAP_CASCADE\n\n        if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n     #else\n\n       if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n      #endif\n\n    #endif\n\n  }\n\n #ifdef GAMMA_OUTPUT\n\n   shadowColor *= shadowColor;\n\n #endif\n\n  gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n #ifdef USE_SKINNING\n\n   vec4 worldPosition = modelMatrix * skinned;\n\n #endif\n\n  #if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n    vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n  #endif\n\n  #if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n uniform sampler2D shadowMap[ MAX_SHADOWS ];\n uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n  uniform float shadowDarkness[ MAX_SHADOWS ];\n  uniform float shadowBias[ MAX_SHADOWS ];\n\n  varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n float unpackDepth( const in vec4 rgba_depth ) {\n\n   const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n    float depth = dot( rgba_depth, bit_shift );\n   return depth;\n\n }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n uniform mat4 bindMatrix;\n  uniform mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n   uniform sampler2D boneTexture;\n    uniform int boneTextureWidth;\n   uniform int boneTextureHeight;\n\n    mat4 getBoneMatrix( const in float i ) {\n\n      float j = i * 4.0;\n      float x = mod( j, float( boneTextureWidth ) );\n      float y = floor( j / float( boneTextureWidth ) );\n\n     float dx = 1.0 / float( boneTextureWidth );\n     float dy = 1.0 / float( boneTextureHeight );\n\n      y = dy * ( y + 0.5 );\n\n     vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n      vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n      vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n      vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n      mat4 bone = mat4( v1, v2, v3, v4 );\n\n     return bone;\n\n    }\n\n #else\n\n   uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n   mat4 getBoneMatrix( const in float i ) {\n\n      mat4 bone = boneGlobalMatrices[ int(i) ];\n     return bone;\n\n    }\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n uniform float logDepthBufFC;\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    #extension GL_EXT_frag_depth : enable\n   varying float vFragDepth;\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n  gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

  merge: function ( uniforms ) {

    var merged = {};

    for ( var u = 0; u < uniforms.length; u ++ ) {

      var tmp = this.clone( uniforms[ u ] );

      for ( var p in tmp ) {

        merged[ p ] = tmp[ p ];

      }

    }

    return merged;

  },

  clone: function ( uniforms_src ) {

    var uniforms_dst = {};

    for ( var u in uniforms_src ) {

      uniforms_dst[ u ] = {};

      for ( var p in uniforms_src[ u ] ) {

        var parameter_src = uniforms_src[ u ][ p ];

        if ( parameter_src instanceof THREE.Color ||
           parameter_src instanceof THREE.Vector2 ||
           parameter_src instanceof THREE.Vector3 ||
           parameter_src instanceof THREE.Vector4 ||
           parameter_src instanceof THREE.Matrix4 ||
           parameter_src instanceof THREE.Texture ) {

          uniforms_dst[ u ][ p ] = parameter_src.clone();

        } else if ( parameter_src instanceof Array ) {

          uniforms_dst[ u ][ p ] = parameter_src.slice();

        } else {

          uniforms_dst[ u ][ p ] = parameter_src;

        }

      }

    }

    return uniforms_dst;

  }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

  common: {

    "diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },

    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

    "lightMap" : { type: "t", value: null },
    "specularMap" : { type: "t", value: null },
    "alphaMap" : { type: "t", value: null },

    "envMap" : { type: "t", value: null },
    "flipEnvMap" : { type: "f", value: - 1 },
    "useRefract" : { type: "i", value: 0 },
    "reflectivity" : { type: "f", value: 1.0 },
    "refractionRatio" : { type: "f", value: 0.98 },
    "combine" : { type: "i", value: 0 },

    "morphTargetInfluences" : { type: "f", value: 0 }

  },

  bump: {

    "bumpMap" : { type: "t", value: null },
    "bumpScale" : { type: "f", value: 1 }

  },

  normalmap: {

    "normalMap" : { type: "t", value: null },
    "normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
  },

  fog : {

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  lights: {

    "ambientLightColor" : { type: "fv", value: [] },

    "directionalLightDirection" : { type: "fv", value: [] },
    "directionalLightColor" : { type: "fv", value: [] },

    "hemisphereLightDirection" : { type: "fv", value: [] },
    "hemisphereLightSkyColor" : { type: "fv", value: [] },
    "hemisphereLightGroundColor" : { type: "fv", value: [] },

    "pointLightColor" : { type: "fv", value: [] },
    "pointLightPosition" : { type: "fv", value: [] },
    "pointLightDistance" : { type: "fv1", value: [] },

    "spotLightColor" : { type: "fv", value: [] },
    "spotLightPosition" : { type: "fv", value: [] },
    "spotLightDirection" : { type: "fv", value: [] },
    "spotLightDistance" : { type: "fv1", value: [] },
    "spotLightAngleCos" : { type: "fv1", value: [] },
    "spotLightExponent" : { type: "fv1", value: [] }

  },

  particle: {

    "psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },
    "size" : { type: "f", value: 1.0 },
    "scale" : { type: "f", value: 1.0 },
    "map" : { type: "t", value: null },

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  shadowmap: {

    "shadowMap": { type: "tv", value: [] },
    "shadowMapSize": { type: "v2v", value: [] },

    "shadowBias" : { type: "fv1", value: [] },
    "shadowDarkness": { type: "fv1", value: [] },

    "shadowMatrix" : { type: "m4v", value: [] }

  }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

  'basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      THREE.ShaderChunk[ "map_pars_vertex" ],
      THREE.ShaderChunk[ "lightmap_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "map_vertex" ],
        THREE.ShaderChunk[ "lightmap_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],

      " #ifdef USE_ENVMAP",

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      " #endif",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "lightmap_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      "}"

    ].join("\n")

  },

  'lambert': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
        "wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
      }

    ] ),

    vertexShader: [

      "#define LAMBERT",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "map_pars_vertex" ],
      THREE.ShaderChunk[ "lightmap_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "map_vertex" ],
        THREE.ShaderChunk[ "lightmap_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_lambert_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform float opacity;",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( vec3( 1.0 ), opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],

      " #ifdef DOUBLE_SIDED",

          //"float isFront = float( gl_FrontFacing );",
          //"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

      "   if ( gl_FrontFacing )",
      "     gl_FragColor.xyz *= vLightFront;",
      "   else",
      "     gl_FragColor.xyz *= vLightBack;",

      " #else",

      "   gl_FragColor.xyz *= vLightFront;",

      " #endif",

        THREE.ShaderChunk[ "lightmap_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      "}"

    ].join("\n")

  },

  'phong': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "bump" ],
      THREE.UniformsLib[ "normalmap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
        "specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
        "shininess": { type: "f", value: 30 },
        "wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
      }

    ] ),

    vertexShader: [

      "#define PHONG",

      "varying vec3 vViewPosition;",
      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "map_pars_vertex" ],
      THREE.ShaderChunk[ "lightmap_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "map_vertex" ],
        THREE.ShaderChunk[ "lightmap_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      " vNormal = normalize( transformedNormal );",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      " vViewPosition = -mvPosition.xyz;",

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_phong_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "#define PHONG",

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      "uniform vec3 ambient;",
      "uniform vec3 emissive;",
      "uniform vec3 specular;",
      "uniform float shininess;",

      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
      THREE.ShaderChunk[ "normalmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( vec3( 1.0 ), opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],

        THREE.ShaderChunk[ "lights_phong_fragment" ],

        THREE.ShaderChunk[ "lightmap_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      "}"

    ].join("\n")

  },

  'particle_basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "particle" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      "uniform float size;",
      "uniform float scale;",

      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

      " #ifdef USE_SIZEATTENUATION",
      "   gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
      " #else",
      "   gl_PointSize = size;",
      " #endif",

      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],
        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 psColor;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "map_particle_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( psColor, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_particle_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],
        THREE.ShaderChunk[ "fog_fragment" ],

      "}"

    ].join("\n")

  },

  'dashed': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],

      {
        "scale"    : { type: "f", value: 1 },
        "dashSize" : { type: "f", value: 1 },
        "totalSize": { type: "f", value: 2 }
      }

    ] ),

    vertexShader: [

      "uniform float scale;",
      "attribute float lineDistance;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vLineDistance = scale * lineDistance;",

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      "uniform float dashSize;",
      "uniform float totalSize;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " if ( mod( vLineDistance, totalSize ) > dashSize ) {",

      "   discard;",

      " }",

      " gl_FragColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "fog_fragment" ],

      "}"

    ].join("\n")

  },

  'depth': {

    uniforms: {

      "mNear": { type: "f", value: 1.0 },
      "mFar" : { type: "f", value: 2000.0 },
      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform float mNear;",
      "uniform float mFar;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   float depth = gl_FragDepthEXT / gl_FragCoord.w;",

      " #else",

      "   float depth = gl_FragCoord.z / gl_FragCoord.w;",

      " #endif",

      " float color = 1.0 - smoothstep( mNear, mFar, depth );",
      " gl_FragColor = vec4( vec3( color ), opacity );",

      "}"

    ].join("\n")

  },

  'normal': {

    uniforms: {

      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vNormal = normalize( normalMatrix * normal );",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform float opacity;",
      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join("\n")

  },

  /* -------------------------------------------------------------------------
  //  Normal map shader
  //    - Blinn-Phong
  //    - normal + diffuse + specular + AO + displacement + reflection + shadow maps
  //    - point and directional lights (use with "lights: true" material option)
   ------------------------------------------------------------------------- */

  'normalmap' : {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {

      "enableAO"          : { type: "i", value: 0 },
      "enableDiffuse"     : { type: "i", value: 0 },
      "enableSpecular"    : { type: "i", value: 0 },
      "enableReflection"  : { type: "i", value: 0 },
      "enableDisplacement": { type: "i", value: 0 },

      "tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
      "tDiffuse"     : { type: "t", value: null },
      "tCube"        : { type: "t", value: null },
      "tNormal"      : { type: "t", value: null },
      "tSpecular"    : { type: "t", value: null },
      "tAO"          : { type: "t", value: null },

      "uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

      "uDisplacementBias": { type: "f", value: 0.0 },
      "uDisplacementScale": { type: "f", value: 1.0 },

      "diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
      "specular": { type: "c", value: new THREE.Color( 0x111111 ) },
      "ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
      "shininess": { type: "f", value: 30 },
      "opacity": { type: "f", value: 1 },

      "useRefract": { type: "i", value: 0 },
      "refractionRatio": { type: "f", value: 0.98 },
      "reflectivity": { type: "f", value: 0.5 },

      "uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
      "uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

      "wrapRGB" : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

      }

    ] ),

    fragmentShader: [

      "uniform vec3 ambient;",
      "uniform vec3 diffuse;",
      "uniform vec3 specular;",
      "uniform float shininess;",
      "uniform float opacity;",

      "uniform bool enableDiffuse;",
      "uniform bool enableSpecular;",
      "uniform bool enableAO;",
      "uniform bool enableReflection;",

      "uniform sampler2D tDiffuse;",
      "uniform sampler2D tNormal;",
      "uniform sampler2D tSpecular;",
      "uniform sampler2D tAO;",

      "uniform samplerCube tCube;",

      "uniform vec2 uNormalScale;",

      "uniform bool useRefract;",
      "uniform float refractionRatio;",
      "uniform float reflectivity;",

      "varying vec3 vTangent;",
      "varying vec3 vBinormal;",
      "varying vec3 vNormal;",
      "varying vec2 vUv;",

      "uniform vec3 ambientLightColor;",

      "#if MAX_DIR_LIGHTS > 0",

      " uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
      " uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

      "#endif",

      "#if MAX_HEMI_LIGHTS > 0",

      " uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
      " uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
      " uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

      "#endif",

      "#if MAX_POINT_LIGHTS > 0",

      " uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
      " uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
      " uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

      "#endif",

      "#if MAX_SPOT_LIGHTS > 0",

      " uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
      " uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
      " uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
      " uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
      " uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
      " uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

      "#endif",

      "#ifdef WRAP_AROUND",

      " uniform vec3 wrapRGB;",

      "#endif",

      "varying vec3 vWorldPosition;",
      "varying vec3 vViewPosition;",

      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",
        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " gl_FragColor = vec4( vec3( 1.0 ), opacity );",

      " vec3 specularTex = vec3( 1.0 );",

      " vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
      " normalTex.xy *= uNormalScale;",
      " normalTex = normalize( normalTex );",

      " if( enableDiffuse ) {",

      "   #ifdef GAMMA_INPUT",

      "     vec4 texelColor = texture2D( tDiffuse, vUv );",
      "     texelColor.xyz *= texelColor.xyz;",

      "     gl_FragColor = gl_FragColor * texelColor;",

      "   #else",

      "     gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

      "   #endif",

      " }",

      " if( enableAO ) {",

      "   #ifdef GAMMA_INPUT",

      "     vec4 aoColor = texture2D( tAO, vUv );",
      "     aoColor.xyz *= aoColor.xyz;",

      "     gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

      "   #else",

      "     gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

      "   #endif",

      " }",
      
      THREE.ShaderChunk[ "alphatest_fragment" ],

      " if( enableSpecular )",
      "   specularTex = texture2D( tSpecular, vUv ).xyz;",

      " mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
      " vec3 finalNormal = tsb * normalTex;",

      " #ifdef FLIP_SIDED",

      "   finalNormal = -finalNormal;",

      " #endif",

      " vec3 normal = normalize( finalNormal );",
      " vec3 viewPosition = normalize( vViewPosition );",

        // point lights

      " #if MAX_POINT_LIGHTS > 0",

      "   vec3 pointDiffuse = vec3( 0.0 );",
      "   vec3 pointSpecular = vec3( 0.0 );",

      "   for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

      "     vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
      "     vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

      "     float pointDistance = 1.0;",
      "     if ( pointLightDistance[ i ] > 0.0 )",
      "       pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

      "     pointVector = normalize( pointVector );",

            // diffuse

      "     #ifdef WRAP_AROUND",

      "       float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
      "       float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

      "       vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

      "     #else",

      "       float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

      "     #endif",

      "     pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",

            // specular

      "     vec3 pointHalfVector = normalize( pointVector + viewPosition );",
      "     float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
      "     float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

      "     float specularNormalization = ( shininess + 2.0 ) / 8.0;",

      "     vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );",
      "     pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

      "   }",

      " #endif",

        // spot lights

      " #if MAX_SPOT_LIGHTS > 0",

      "   vec3 spotDiffuse = vec3( 0.0 );",
      "   vec3 spotSpecular = vec3( 0.0 );",

      "   for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

      "     vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
      "     vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

      "     float spotDistance = 1.0;",
      "     if ( spotLightDistance[ i ] > 0.0 )",
      "       spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

      "     spotVector = normalize( spotVector );",

      "     float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

      "     if ( spotEffect > spotLightAngleCos[ i ] ) {",

      "       spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );",

              // diffuse

      "       #ifdef WRAP_AROUND",

      "         float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
      "         float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

      "         vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

      "       #else",

      "         float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

      "       #endif",

      "       spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",

              // specular

      "       vec3 spotHalfVector = normalize( spotVector + viewPosition );",
      "       float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
      "       float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

      "       float specularNormalization = ( shininess + 2.0 ) / 8.0;",

      "       vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );",
      "       spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

      "     }",

      "   }",

      " #endif",

        // directional lights

      " #if MAX_DIR_LIGHTS > 0",

      "   vec3 dirDiffuse = vec3( 0.0 );",
      "   vec3 dirSpecular = vec3( 0.0 );",

      "   for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

      "     vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
      "     vec3 dirVector = normalize( lDirection.xyz );",

            // diffuse

      "     #ifdef WRAP_AROUND",

      "       float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
      "       float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

      "       vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

      "     #else",

      "       float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

      "     #endif",

      "     dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",

            // specular

      "     vec3 dirHalfVector = normalize( dirVector + viewPosition );",
      "     float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
      "     float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

      "     float specularNormalization = ( shininess + 2.0 ) / 8.0;",

      "     vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
      "     dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

      "   }",

      " #endif",

        // hemisphere lights

      " #if MAX_HEMI_LIGHTS > 0",

      "   vec3 hemiDiffuse = vec3( 0.0 );",
      "   vec3 hemiSpecular = vec3( 0.0 );" ,

      "   for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

      "     vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
      "     vec3 lVector = normalize( lDirection.xyz );",

            // diffuse

      "     float dotProduct = dot( normal, lVector );",
      "     float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

      "     vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

      "     hemiDiffuse += diffuse * hemiColor;",

            // specular (sky light)


      "     vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
      "     float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
      "     float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );",

            // specular (ground light)

      "     vec3 lVectorGround = -lVector;",

      "     vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
      "     float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
      "     float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );",

      "     float dotProductGround = dot( normal, lVectorGround );",

      "     float specularNormalization = ( shininess + 2.0 ) / 8.0;",

      "     vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
      "     vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
      "     hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

      "   }",

      " #endif",

        // all lights contribution summation

      " vec3 totalDiffuse = vec3( 0.0 );",
      " vec3 totalSpecular = vec3( 0.0 );",

      " #if MAX_DIR_LIGHTS > 0",

      "   totalDiffuse += dirDiffuse;",
      "   totalSpecular += dirSpecular;",

      " #endif",

      " #if MAX_HEMI_LIGHTS > 0",

      "   totalDiffuse += hemiDiffuse;",
      "   totalSpecular += hemiSpecular;",

      " #endif",

      " #if MAX_POINT_LIGHTS > 0",

      "   totalDiffuse += pointDiffuse;",
      "   totalSpecular += pointSpecular;",

      " #endif",

      " #if MAX_SPOT_LIGHTS > 0",

      "   totalDiffuse += spotDiffuse;",
      "   totalSpecular += spotSpecular;",

      " #endif",

      " #ifdef METAL",

      "   gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

      " #else",

      "   gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

      " #endif",

      " if ( enableReflection ) {",

      "   vec3 vReflect;",
      "   vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

      "   if ( useRefract ) {",

      "     vReflect = refract( cameraToVertex, normal, refractionRatio );",

      "   } else {",

      "     vReflect = reflect( cameraToVertex, normal );",

      "   }",

      "   vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

      "   #ifdef GAMMA_INPUT",

      "     cubeColor.xyz *= cubeColor.xyz;",

      "   #endif",

      "   gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",

      " }",

        THREE.ShaderChunk[ "shadowmap_fragment" ],
        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
        THREE.ShaderChunk[ "fog_fragment" ],

      "}"

    ].join("\n"),

    vertexShader: [

      "attribute vec4 tangent;",

      "uniform vec2 uOffset;",
      "uniform vec2 uRepeat;",

      "uniform bool enableDisplacement;",

      "#ifdef VERTEX_TEXTURES",

      " uniform sampler2D tDisplacement;",
      " uniform float uDisplacementScale;",
      " uniform float uDisplacementBias;",

      "#endif",

      "varying vec3 vTangent;",
      "varying vec3 vBinormal;",
      "varying vec3 vNormal;",
      "varying vec2 vUv;",

      "varying vec3 vWorldPosition;",
      "varying vec3 vViewPosition;",

      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],

        // normal, tangent and binormal vectors

      " #ifdef USE_SKINNING",

      "   vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

      "   vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
      "   vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

      " #else",

      "   vNormal = normalize( normalMatrix * normal );",
      "   vTangent = normalize( normalMatrix * tangent.xyz );",

      " #endif",

      " vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

      " vUv = uv * uRepeat + uOffset;",

        // displacement mapping

      " vec3 displacedPosition;",

      " #ifdef VERTEX_TEXTURES",

      "   if ( enableDisplacement ) {",

      "     vec3 dv = texture2D( tDisplacement, uv ).xyz;",
      "     float df = uDisplacementScale * dv.x + uDisplacementBias;",
      "     displacedPosition = position + normalize( normal ) * df;",

      "   } else {",

      "     #ifdef USE_SKINNING",

      "       vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

      "       vec4 skinned = vec4( 0.0 );",
      "       skinned += boneMatX * skinVertex * skinWeight.x;",
      "       skinned += boneMatY * skinVertex * skinWeight.y;",
      "       skinned += boneMatZ * skinVertex * skinWeight.z;",
      "       skinned += boneMatW * skinVertex * skinWeight.w;",
      "       skinned  = bindMatrixInverse * skinned;",

      "       displacedPosition = skinned.xyz;",

      "     #else",

      "       displacedPosition = position;",

      "     #endif",

      "   }",

      " #else",

      "   #ifdef USE_SKINNING",

      "     vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

      "     vec4 skinned = vec4( 0.0 );",
      "     skinned += boneMatX * skinVertex * skinWeight.x;",
      "     skinned += boneMatY * skinVertex * skinWeight.y;",
      "     skinned += boneMatZ * skinVertex * skinWeight.z;",
      "     skinned += boneMatW * skinVertex * skinWeight.w;",
      "     skinned  = bindMatrixInverse * skinned;",

      "     displacedPosition = skinned.xyz;",

      "   #else",

      "     displacedPosition = position;",

      "   #endif",

      " #endif",

        //

      " vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
      " vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        //

      " vWorldPosition = worldPosition.xyz;",
      " vViewPosition = -mvPosition.xyz;",

        // shadows

      " #ifdef USE_SHADOWMAP",

      "   for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

      "     vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

      "   }",

      " #endif",

      "}"

    ].join("\n")

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'cube': {

    uniforms: { "tCube": { type: "t", value: null },
          "tFlip": { type: "f", value: - 1 } },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
      " vWorldPosition = worldPosition.xyz;",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform samplerCube tCube;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join("\n")

  },

  /* Depth encoding into RGBA texture
   *
   * based on SpiderGL shadow map example
   * http://spidergl.org/example.php?id=6
   *
   * originally from
   * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
   *
   * see also
   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
   */

  'depthRGBA': {

    uniforms: {},

    vertexShader: [

      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "vec4 pack_depth( const in float depth ) {",

      " const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
      " const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
      " vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "  vec4 res = fract( depth * bit_shift );",
      " res -= res.xxyz * bit_mask;",
      " return res;",

      "}",

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

      " #else",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

      " #endif",

        //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
        //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
        //"gl_FragData[ 0 ] = pack_depth( z );",
        //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

      "}"

    ].join("\n")

  }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

  console.log( 'THREE.WebGLRenderer', THREE.REVISION );

  parameters = parameters || {};

  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
  _context = parameters.context !== undefined ? parameters.context : null,

  _precision = parameters.precision !== undefined ? parameters.precision : 'highp',

  _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  _depth = parameters.depth !== undefined ? parameters.depth : true,
  _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
  _logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

  _clearColor = new THREE.Color( 0x000000 ),
  _clearAlpha = 0;

  var lights = [];

  var _webglObjects = {};
  var _webglObjectsImmediate = [];

  var opaqueObjects = [];
  var transparentObjects = [];

  var sprites = [];
  var lensFlares = [];

  // public properties

  this.domElement = _canvas;
  this.context = null;
  this.devicePixelRatio = parameters.devicePixelRatio !== undefined
         ? parameters.devicePixelRatio
         : self.devicePixelRatio !== undefined
           ? self.devicePixelRatio
           : 1;

  // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;

  // scene graph

  this.sortObjects = true;

  // physically based shading

  this.gammaInput = false;
  this.gammaOutput = false;

  // shadow map

  this.shadowMapEnabled = false;
  this.shadowMapType = THREE.PCFShadowMap;
  this.shadowMapCullFace = THREE.CullFaceFront;
  this.shadowMapDebug = false;
  this.shadowMapCascade = false;

  // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;

  // flags

  this.autoScaleCubemaps = true;

  // info

  this.info = {

    memory: {

      programs: 0,
      geometries: 0,
      textures: 0

    },

    render: {

      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0

    }

  };

  // internal properties

  var _this = this,

  _programs = [],

  // internal state cache

  _currentProgram = null,
  _currentFramebuffer = null,
  _currentMaterialId = - 1,
  _currentGeometryGroupHash = - 1,
  _currentCamera = null,

  _usedTextureUnits = 0,

  // GL state cache

  _oldDoubleSided = - 1,
  _oldFlipSided = - 1,

  _oldBlending = - 1,

  _oldBlendEquation = - 1,
  _oldBlendSrc = - 1,
  _oldBlendDst = - 1,

  _oldDepthTest = - 1,
  _oldDepthWrite = - 1,

  _oldPolygonOffset = null,
  _oldPolygonOffsetFactor = null,
  _oldPolygonOffsetUnits = null,

  _oldLineWidth = null,

  _viewportX = 0,
  _viewportY = 0,
  _viewportWidth = _canvas.width,
  _viewportHeight = _canvas.height,
  _currentWidth = 0,
  _currentHeight = 0,

  _newAttributes = new Uint8Array( 16 ),
  _enabledAttributes = new Uint8Array( 16 ),

  // frustum

  _frustum = new THREE.Frustum(),

   // camera matrices cache

  _projScreenMatrix = new THREE.Matrix4(),
  _projScreenMatrixPS = new THREE.Matrix4(),

  _vector3 = new THREE.Vector3(),

  // light arrays cache

  _direction = new THREE.Vector3(),

  _lightsNeedUpdate = true,

  _lights = {

    ambient: [ 0, 0, 0 ],
    directional: { length: 0, colors:[], positions: [] },
    point: { length: 0, colors: [], positions: [], distances: [] },
    spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },
    hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

  };

  // initialize

  var _gl;

  try {

    var attributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer
    };

    _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    if ( _gl === null ) {

      if ( _canvas.getContext( 'webgl') !== null ) {

        throw 'Error creating WebGL context with your selected attributes.';

      } else {

        throw 'Error creating WebGL context.';

      }

    }

  } catch ( error ) {

    console.error( error );

  }

  if ( _gl.getShaderPrecisionFormat === undefined ) {

    _gl.getShaderPrecisionFormat = function () {

      return {
        'rangeMin': 1,
        'rangeMax': 1,
        'precision': 1
      };

    }

  }

  var extensions = new THREE.WebGLExtensions( _gl );

  extensions.get( 'OES_texture_float' );
  extensions.get( 'OES_texture_float_linear' );
  extensions.get( 'OES_standard_derivatives' );

  if ( _logarithmicDepthBuffer ) {

    extensions.get( 'EXT_frag_depth' );

  }

  //

  function setDefaultGLState() {

    _gl.clearColor( 0, 0, 0, 1 );
    _gl.clearDepth( 1 );
    _gl.clearStencil( 0 );

    _gl.enable( _gl.DEPTH_TEST );
    _gl.depthFunc( _gl.LEQUAL );

    _gl.frontFace( _gl.CCW );
    _gl.cullFace( _gl.BACK );
    _gl.enable( _gl.CULL_FACE );

    _gl.enable( _gl.BLEND );
    _gl.blendEquation( _gl.FUNC_ADD );
    _gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

    _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    _gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  }

  setDefaultGLState();

  this.context = _gl;

  // GPU capabilities

  var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
  var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
  var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  var _supportsVertexTextures = _maxVertexTextures > 0;
  var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );

  //

  var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
  var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
  var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

  var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
  var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
  var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

  var getCompressedTextureFormats = ( function () {

    var array;

    return function () {

      if ( array !== undefined ) {

        return array;

      }

      array = [];

      if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

        var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

        for ( var i = 0; i < formats.length; i ++ ){

          array.push( formats[ i ] );

        }

      }
      
      return array;

    };

  } )();

  // clamp precision to maximum available

  var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
  var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

  if ( _precision === 'highp' && ! highpAvailable ) {

    if ( mediumpAvailable ) {

      _precision = 'mediump';
      console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

    } else {

      _precision = 'lowp';
      console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

    }

  }

  if ( _precision === 'mediump' && ! mediumpAvailable ) {

    _precision = 'lowp';
    console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

  }

  // Plugins

  var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );

  var spritePlugin = new THREE.SpritePlugin( this, sprites );
  var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

  // API

  this.getContext = function () {

    return _gl;

  };

  this.supportsVertexTextures = function () {

    return _supportsVertexTextures;

  };

  this.supportsFloatTextures = function () {

    return extensions.get( 'OES_texture_float' );

  };

  this.supportsStandardDerivatives = function () {

    return extensions.get( 'OES_standard_derivatives' );

  };

  this.supportsCompressedTextureS3TC = function () {

    return extensions.get( 'WEBGL_compressed_texture_s3tc' );

  };

  this.supportsCompressedTexturePVRTC = function () {

    return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  };

  this.supportsBlendMinMax = function () {

    return extensions.get( 'EXT_blend_minmax' );

  };

  this.getMaxAnisotropy = ( function () {

    var value;

    return function () {

      if ( value !== undefined ) {

        return value;

      }

      var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

      value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

      return value;

    }

  } )();

  this.getPrecision = function () {

    return _precision;

  };

  this.setSize = function ( width, height, updateStyle ) {

    _canvas.width = width * this.devicePixelRatio;
    _canvas.height = height * this.devicePixelRatio;

    if ( updateStyle !== false ) {

      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';

    }

    this.setViewport( 0, 0, width, height );

  };

  this.setViewport = function ( x, y, width, height ) {

    _viewportX = x * this.devicePixelRatio;
    _viewportY = y * this.devicePixelRatio;

    _viewportWidth = width * this.devicePixelRatio;
    _viewportHeight = height * this.devicePixelRatio;

    _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

  };

  this.setScissor = function ( x, y, width, height ) {

    _gl.scissor(
      x * this.devicePixelRatio,
      y * this.devicePixelRatio,
      width * this.devicePixelRatio,
      height * this.devicePixelRatio
    );

  };

  this.enableScissorTest = function ( enable ) {

    enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

  };

  // Clearing

  this.setClearColor = function ( color, alpha ) {

    _clearColor.set( color );
    _clearAlpha = alpha !== undefined ? alpha : 1;

    _gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.setClearColorHex = function ( hex, alpha ) {

    console.warn( 'THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
    this.setClearColor( hex, alpha );

  };

  this.getClearColor = function () {

    return _clearColor;

  };

  this.getClearAlpha = function () {

    return _clearAlpha;

  };

  this.clear = function ( color, depth, stencil ) {

    var bits = 0;

    if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    _gl.clear( bits );

  };

  this.clearColor = function () {

    _gl.clear( _gl.COLOR_BUFFER_BIT );

  };

  this.clearDepth = function () {

    _gl.clear( _gl.DEPTH_BUFFER_BIT );

  };

  this.clearStencil = function () {

    _gl.clear( _gl.STENCIL_BUFFER_BIT );

  };

  this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    this.setRenderTarget( renderTarget );
    this.clear( color, depth, stencil );

  };

  // Reset

  this.resetGLState = function () {

    _currentProgram = null;
    _currentCamera = null;

    _oldBlending = - 1;
    _oldDepthTest = - 1;
    _oldDepthWrite = - 1;
    _oldDoubleSided = - 1;
    _oldFlipSided = - 1;
    _currentGeometryGroupHash = - 1;
    _currentMaterialId = - 1;

    _lightsNeedUpdate = true;

  };

  // Buffer allocation

  function createParticleBuffers ( geometry ) {

    geometry.__webglVertexBuffer = _gl.createBuffer();
    geometry.__webglColorBuffer = _gl.createBuffer();

    _this.info.memory.geometries ++;

  };

  function createLineBuffers ( geometry ) {

    geometry.__webglVertexBuffer = _gl.createBuffer();
    geometry.__webglColorBuffer = _gl.createBuffer();
    geometry.__webglLineDistanceBuffer = _gl.createBuffer();

    _this.info.memory.geometries ++;

  };

  function createMeshBuffers ( geometryGroup ) {

    geometryGroup.__webglVertexBuffer = _gl.createBuffer();
    geometryGroup.__webglNormalBuffer = _gl.createBuffer();
    geometryGroup.__webglTangentBuffer = _gl.createBuffer();
    geometryGroup.__webglColorBuffer = _gl.createBuffer();
    geometryGroup.__webglUVBuffer = _gl.createBuffer();
    geometryGroup.__webglUV2Buffer = _gl.createBuffer();

    geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
    geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

    geometryGroup.__webglFaceBuffer = _gl.createBuffer();
    geometryGroup.__webglLineBuffer = _gl.createBuffer();

    var m, ml;

    if ( geometryGroup.numMorphTargets ) {

      geometryGroup.__webglMorphTargetsBuffers = [];

      for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

        geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

      }

    }

    if ( geometryGroup.numMorphNormals ) {

      geometryGroup.__webglMorphNormalsBuffers = [];

      for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

        geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

      }

    }

    _this.info.memory.geometries ++;

  };

  // Events

  var onObjectRemoved = function ( event ) {

    var object = event.target;

    object.traverse( function ( child ) {

      child.removeEventListener( 'remove', onObjectRemoved );

      removeObject( child );

    } );

  };

  var onGeometryDispose = function ( event ) {

    var geometry = event.target;

    geometry.removeEventListener( 'dispose', onGeometryDispose );

    deallocateGeometry( geometry );

  };

  var onTextureDispose = function ( event ) {

    var texture = event.target;

    texture.removeEventListener( 'dispose', onTextureDispose );

    deallocateTexture( texture );

    _this.info.memory.textures --;


  };

  var onRenderTargetDispose = function ( event ) {

    var renderTarget = event.target;

    renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    deallocateRenderTarget( renderTarget );

    _this.info.memory.textures --;

  };

  var onMaterialDispose = function ( event ) {

    var material = event.target;

    material.removeEventListener( 'dispose', onMaterialDispose );

    deallocateMaterial( material );

  };

  // Buffer deallocation

  var deleteBuffers = function ( geometry ) {
  
    var buffers = [
      '__webglVertexBuffer',
      '__webglNormalBuffer',
      '__webglTangentBuffer',
      '__webglColorBuffer',
      '__webglUVBuffer',
      '__webglUV2Buffer',
      
      '__webglSkinIndicesBuffer',
      '__webglSkinWeightsBuffer',
      
      '__webglFaceBuffer',
      '__webglLineBuffer',
      
      '__webglLineDistanceBuffer'
    ];

    for ( var i = 0, l = buffers.length; i < l; i ++ ) {

      var name = buffers[ i ];

      if ( geometry[ name ] !== undefined ) {

        _gl.deleteBuffer( geometry[ name ] );

        delete geometry[ name ];

      }

    }

    // custom attributes

    if ( geometry.__webglCustomAttributesList !== undefined ) {

      for ( var name in geometry.__webglCustomAttributesList ) {

        _gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

      }

      delete geometry.__webglCustomAttributesList;

    }

    _this.info.memory.geometries --;

  };

  var deallocateGeometry = function ( geometry ) {

    delete geometry.__webglInit;

    if ( geometry instanceof THREE.BufferGeometry ) {

      for ( var name in geometry.attributes ) {
      
        var attribute = geometry.attributes[ name ];

        if ( attribute.buffer !== undefined ) {

          _gl.deleteBuffer( attribute.buffer );

          delete attribute.buffer;

        }

      }

      _this.info.memory.geometries --;

    } else {

      var geometryGroupsList = geometryGroups[ geometry.id ];

      if ( geometryGroupsList !== undefined ) {

        for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

          var geometryGroup = geometryGroupsList[ i ];

          if ( geometryGroup.numMorphTargets !== undefined ) {

            for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

              _gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

            }

            delete geometryGroup.__webglMorphTargetsBuffers;

          }

          if ( geometryGroup.numMorphNormals !== undefined ) {

            for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

              _gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

            }

            delete geometryGroup.__webglMorphNormalsBuffers;

          }

          deleteBuffers( geometryGroup );

        }

        delete geometryGroups[ geometry.id ];

      } else {

        deleteBuffers( geometry );

      }

    }

    // TOFIX: Workaround for deleted geometry being currently bound

    _currentGeometryGroupHash = - 1;

  };

  var deallocateTexture = function ( texture ) {

    if ( texture.image && texture.image.__webglTextureCube ) {

      // cube texture

      _gl.deleteTexture( texture.image.__webglTextureCube );

      delete texture.image.__webglTextureCube;

    } else {

      // 2D texture

      if ( texture.__webglInit === undefined ) return;

      _gl.deleteTexture( texture.__webglTexture );

      delete texture.__webglTexture;
      delete texture.__webglInit;

    }

  };

  var deallocateRenderTarget = function ( renderTarget ) {

    if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

    _gl.deleteTexture( renderTarget.__webglTexture );

    delete renderTarget.__webglTexture;

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      for ( var i = 0; i < 6; i ++ ) {

        _gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
        _gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

      }

    } else {

      _gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
      _gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

    }

    delete renderTarget.__webglFramebuffer;
    delete renderTarget.__webglRenderbuffer;

  };

  var deallocateMaterial = function ( material ) {

    var program = material.program.program;

    if ( program === undefined ) return;

    material.program = undefined;

    // only deallocate GL program if this was the last use of shared program
    // assumed there is only single copy of any program in the _programs list
    // (that's how it's constructed)

    var i, il, programInfo;
    var deleteProgram = false;

    for ( i = 0, il = _programs.length; i < il; i ++ ) {

      programInfo = _programs[ i ];

      if ( programInfo.program === program ) {

        programInfo.usedTimes --;

        if ( programInfo.usedTimes === 0 ) {

          deleteProgram = true;

        }

        break;

      }

    }

    if ( deleteProgram === true ) {

      // avoid using array.splice, this is costlier than creating new array from scratch

      var newPrograms = [];

      for ( i = 0, il = _programs.length; i < il; i ++ ) {

        programInfo = _programs[ i ];

        if ( programInfo.program !== program ) {

          newPrograms.push( programInfo );

        }

      }

      _programs = newPrograms;

      _gl.deleteProgram( program );

      _this.info.memory.programs --;

    }

  };

  // Buffer initialization

  function initCustomAttributes ( object ) {

    var geometry = object.geometry;
    var material = object.material;

    var nvertices = geometry.vertices.length;

    if ( material.attributes ) {

      if ( geometry.__webglCustomAttributesList === undefined ) {

        geometry.__webglCustomAttributesList = [];

      }

      for ( var name in material.attributes ) {

        var attribute = material.attributes[ name ];

        if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

          attribute.__webglInitialized = true;

          var size = 1;   // "f" and "i"

          if ( attribute.type === 'v2' ) size = 2;
          else if ( attribute.type === 'v3' ) size = 3;
          else if ( attribute.type === 'v4' ) size = 4;
          else if ( attribute.type === 'c'  ) size = 3;

          attribute.size = size;

          attribute.array = new Float32Array( nvertices * size );

          attribute.buffer = _gl.createBuffer();
          attribute.buffer.belongsToAttribute = name;

          attribute.needsUpdate = true;

        }

        geometry.__webglCustomAttributesList.push( attribute );

      }

    }

  };

  function initParticleBuffers ( geometry, object ) {

    var nvertices = geometry.vertices.length;

    geometry.__vertexArray = new Float32Array( nvertices * 3 );
    geometry.__colorArray = new Float32Array( nvertices * 3 );

    geometry.__sortArray = [];

    geometry.__webglParticleCount = nvertices;

    initCustomAttributes( object );

  };

  function initLineBuffers ( geometry, object ) {

    var nvertices = geometry.vertices.length;

    geometry.__vertexArray = new Float32Array( nvertices * 3 );
    geometry.__colorArray = new Float32Array( nvertices * 3 );
    geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

    geometry.__webglLineCount = nvertices;

    initCustomAttributes( object );

  };

  function initMeshBuffers ( geometryGroup, object ) {

    var geometry = object.geometry,
      faces3 = geometryGroup.faces3,

      nvertices = faces3.length * 3,
      ntris     = faces3.length * 1,
      nlines    = faces3.length * 3,

      material = getBufferMaterial( object, geometryGroup );

    geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
    geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
    geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
    geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

    if ( geometry.faceVertexUvs.length > 1 ) {

      geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

    }

    if ( geometry.hasTangents ) {

      geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

    }

    if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

      geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
      geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

    }

    var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

    geometryGroup.__typeArray = UintArray;
    geometryGroup.__faceArray = new UintArray( ntris * 3 );
    geometryGroup.__lineArray = new UintArray( nlines * 2 );

    var m, ml;

    if ( geometryGroup.numMorphTargets ) {

      geometryGroup.__morphTargetsArrays = [];

      for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

        geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

      }

    }

    if ( geometryGroup.numMorphNormals ) {

      geometryGroup.__morphNormalsArrays = [];

      for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

        geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

      }

    }

    geometryGroup.__webglFaceCount = ntris * 3;
    geometryGroup.__webglLineCount = nlines * 2;


    // custom attributes

    if ( material.attributes ) {

      if ( geometryGroup.__webglCustomAttributesList === undefined ) {

        geometryGroup.__webglCustomAttributesList = [];

      }

      for ( var name in material.attributes ) {

        // Do a shallow copy of the attribute object so different geometryGroup chunks use different
        // attribute buffers which are correctly indexed in the setMeshBuffers function

        var originalAttribute = material.attributes[ name ];

        var attribute = {};

        for ( var property in originalAttribute ) {

          attribute[ property ] = originalAttribute[ property ];

        }

        if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

          attribute.__webglInitialized = true;

          var size = 1;   // "f" and "i"

          if ( attribute.type === 'v2' ) size = 2;
          else if ( attribute.type === 'v3' ) size = 3;
          else if ( attribute.type === 'v4' ) size = 4;
          else if ( attribute.type === 'c'  ) size = 3;

          attribute.size = size;

          attribute.array = new Float32Array( nvertices * size );

          attribute.buffer = _gl.createBuffer();
          attribute.buffer.belongsToAttribute = name;

          originalAttribute.needsUpdate = true;
          attribute.__original = originalAttribute;

        }

        geometryGroup.__webglCustomAttributesList.push( attribute );

      }

    }

    geometryGroup.__inittedArrays = true;

  };

  function getBufferMaterial( object, geometryGroup ) {

    return object.material instanceof THREE.MeshFaceMaterial
       ? object.material.materials[ geometryGroup.materialIndex ]
       : object.material;

  };

  function materialNeedsSmoothNormals ( material ) {

    return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

  };

  // Buffer setting

  function setParticleBuffers ( geometry, hint, object ) {

    var v, c, vertex, offset, index, color,

    vertices = geometry.vertices,
    vl = vertices.length,

    colors = geometry.colors,
    cl = colors.length,

    vertexArray = geometry.__vertexArray,
    colorArray = geometry.__colorArray,

    sortArray = geometry.__sortArray,

    dirtyVertices = geometry.verticesNeedUpdate,
    dirtyElements = geometry.elementsNeedUpdate,
    dirtyColors = geometry.colorsNeedUpdate,

    customAttributes = geometry.__webglCustomAttributesList,
    i, il,
    a, ca, cal, value,
    customAttribute;

    if ( object.sortParticles ) {

      _projScreenMatrixPS.copy( _projScreenMatrix );
      _projScreenMatrixPS.multiply( object.matrixWorld );

      for ( v = 0; v < vl; v ++ ) {

        vertex = vertices[ v ];

        _vector3.copy( vertex );
        _vector3.applyProjection( _projScreenMatrixPS );

        sortArray[ v ] = [ _vector3.z, v ];

      }

      sortArray.sort( numericalSort );

      for ( v = 0; v < vl; v ++ ) {

        vertex = vertices[ sortArray[ v ][ 1 ] ];

        offset = v * 3;

        vertexArray[ offset ]     = vertex.x;
        vertexArray[ offset + 1 ] = vertex.y;
        vertexArray[ offset + 2 ] = vertex.z;

      }

      for ( c = 0; c < cl; c ++ ) {

        offset = c * 3;

        color = colors[ sortArray[ c ][ 1 ] ];

        colorArray[ offset ]     = color.r;
        colorArray[ offset + 1 ] = color.g;
        colorArray[ offset + 2 ] = color.b;

      }

      if ( customAttributes ) {

        for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

          customAttribute = customAttributes[ i ];

          if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) continue;

          offset = 0;

          cal = customAttribute.value.length;

          if ( customAttribute.size === 1 ) {

            for ( ca = 0; ca < cal; ca ++ ) {

              index = sortArray[ ca ][ 1 ];

              customAttribute.array[ ca ] = customAttribute.value[ index ];

            }

          } else if ( customAttribute.size === 2 ) {

            for ( ca = 0; ca < cal; ca ++ ) {

              index = sortArray[ ca ][ 1 ];

              value = customAttribute.value[ index ];

              customAttribute.array[ offset ]   = value.x;
              customAttribute.array[ offset + 1 ] = value.y;

              offset += 2;

            }

          } else if ( customAttribute.size === 3 ) {

            if ( customAttribute.type === 'c' ) {

              for ( ca = 0; ca < cal; ca ++ ) {

                index = sortArray[ ca ][ 1 ];

                value = customAttribute.value[ index ];

                customAttribute.array[ offset ]     = value.r;
                customAttribute.array[ offset + 1 ] = value.g;
                customAttribute.array[ offset + 2 ] = value.b;

                offset += 3;

              }

            } else {

              for ( ca = 0; ca < cal; ca ++ ) {

                index = sortArray[ ca ][ 1 ];

                value = customAttribute.value[ index ];

                customAttribute.array[ offset ]   = value.x;
                customAttribute.array[ offset + 1 ] = value.y;
                customAttribute.array[ offset + 2 ] = value.z;

                offset += 3;

              }

            }

          } else if ( customAttribute.size === 4 ) {

            for ( ca = 0; ca < cal; ca ++ ) {

              index = sortArray[ ca ][ 1 ];

              value = customAttribute.value[ index ];

              customAttribute.array[ offset ]      = value.x;
              customAttribute.array[ offset + 1  ] = value.y;
              customAttribute.array[ offset + 2  ] = value.z;
              customAttribute.array[ offset + 3  ] = value.w;

              offset += 4;

            }

          }

        }

      }

    } else {

      if ( dirtyVertices ) {

        for ( v = 0; v < vl; v ++ ) {

          vertex = vertices[ v ];

          offset = v * 3;

          vertexArray[ offset ]     = vertex.x;
          vertexArray[ offset + 1 ] = vertex.y;
          vertexArray[ offset + 2 ] = vertex.z;

        }

      }

      if ( dirtyColors ) {

        for ( c = 0; c < cl; c ++ ) {

          color = colors[ c ];

          offset = c * 3;

          colorArray[ offset ]     = color.r;
          colorArray[ offset + 1 ] = color.g;
          colorArray[ offset + 2 ] = color.b;

        }

      }

      if ( customAttributes ) {

        for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

          customAttribute = customAttributes[ i ];

          if ( customAttribute.needsUpdate &&
             ( customAttribute.boundTo === undefined ||
               customAttribute.boundTo === 'vertices' ) ) {

            cal = customAttribute.value.length;

            offset = 0;

            if ( customAttribute.size === 1 ) {

              for ( ca = 0; ca < cal; ca ++ ) {

                customAttribute.array[ ca ] = customAttribute.value[ ca ];

              }

            } else if ( customAttribute.size === 2 ) {

              for ( ca = 0; ca < cal; ca ++ ) {

                value = customAttribute.value[ ca ];

                customAttribute.array[ offset ]   = value.x;
                customAttribute.array[ offset + 1 ] = value.y;

                offset += 2;

              }

            } else if ( customAttribute.size === 3 ) {

              if ( customAttribute.type === 'c' ) {

                for ( ca = 0; ca < cal; ca ++ ) {

                  value = customAttribute.value[ ca ];

                  customAttribute.array[ offset ]   = value.r;
                  customAttribute.array[ offset + 1 ] = value.g;
                  customAttribute.array[ offset + 2 ] = value.b;

                  offset += 3;

                }

              } else {

                for ( ca = 0; ca < cal; ca ++ ) {

                  value = customAttribute.value[ ca ];

                  customAttribute.array[ offset ]   = value.x;
                  customAttribute.array[ offset + 1 ] = value.y;
                  customAttribute.array[ offset + 2 ] = value.z;

                  offset += 3;

                }

              }

            } else if ( customAttribute.size === 4 ) {

              for ( ca = 0; ca < cal; ca ++ ) {

                value = customAttribute.value[ ca ];

                customAttribute.array[ offset ]      = value.x;
                customAttribute.array[ offset + 1  ] = value.y;
                customAttribute.array[ offset + 2  ] = value.z;
                customAttribute.array[ offset + 3  ] = value.w;

                offset += 4;

              }

            }

          }

        }

      }

    }

    if ( dirtyVertices || object.sortParticles ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

    }

    if ( dirtyColors || object.sortParticles ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

    }

    if ( customAttributes ) {

      for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

        customAttribute = customAttributes[ i ];

        if ( customAttribute.needsUpdate || object.sortParticles ) {

          _gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
          _gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

        }

      }

    }

  }

  function setLineBuffers ( geometry, hint ) {

    var v, c, d, vertex, offset, color,

    vertices = geometry.vertices,
    colors = geometry.colors,
    lineDistances = geometry.lineDistances,

    vl = vertices.length,
    cl = colors.length,
    dl = lineDistances.length,

    vertexArray = geometry.__vertexArray,
    colorArray = geometry.__colorArray,
    lineDistanceArray = geometry.__lineDistanceArray,

    dirtyVertices = geometry.verticesNeedUpdate,
    dirtyColors = geometry.colorsNeedUpdate,
    dirtyLineDistances = geometry.lineDistancesNeedUpdate,

    customAttributes = geometry.__webglCustomAttributesList,

    i, il,
    a, ca, cal, value,
    customAttribute;

    if ( dirtyVertices ) {

      for ( v = 0; v < vl; v ++ ) {

        vertex = vertices[ v ];

        offset = v * 3;

        vertexArray[ offset ]     = vertex.x;
        vertexArray[ offset + 1 ] = vertex.y;
        vertexArray[ offset + 2 ] = vertex.z;

      }

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

    }

    if ( dirtyColors ) {

      for ( c = 0; c < cl; c ++ ) {

        color = colors[ c ];

        offset = c * 3;

        colorArray[ offset ]     = color.r;
        colorArray[ offset + 1 ] = color.g;
        colorArray[ offset + 2 ] = color.b;

      }

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

    }

    if ( dirtyLineDistances ) {

      for ( d = 0; d < dl; d ++ ) {

        lineDistanceArray[ d ] = lineDistances[ d ];

      }

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

    }

    if ( customAttributes ) {

      for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

        customAttribute = customAttributes[ i ];

        if ( customAttribute.needsUpdate &&
           ( customAttribute.boundTo === undefined ||
             customAttribute.boundTo === 'vertices' ) ) {

          offset = 0;

          cal = customAttribute.value.length;

          if ( customAttribute.size === 1 ) {

            for ( ca = 0; ca < cal; ca ++ ) {

              customAttribute.array[ ca ] = customAttribute.value[ ca ];

            }

          } else if ( customAttribute.size === 2 ) {

            for ( ca = 0; ca < cal; ca ++ ) {

              value = customAttribute.value[ ca ];

              customAttribute.array[ offset ]   = value.x;
              customAttribute.array[ offset + 1 ] = value.y;

              offset += 2;

            }

          } else if ( customAttribute.size === 3 ) {

            if ( customAttribute.type === 'c' ) {

              for ( ca = 0; ca < cal; ca ++ ) {

                value = customAttribute.value[ ca ];

                customAttribute.array[ offset ]   = value.r;
                customAttribute.array[ offset + 1 ] = value.g;
                customAttribute.array[ offset + 2 ] = value.b;

                offset += 3;

              }

            } else {

              for ( ca = 0; ca < cal; ca ++ ) {

                value = customAttribute.value[ ca ];

                customAttribute.array[ offset ]   = value.x;
                customAttribute.array[ offset + 1 ] = value.y;
                customAttribute.array[ offset + 2 ] = value.z;

                offset += 3;

              }

            }

          } else if ( customAttribute.size === 4 ) {

            for ( ca = 0; ca < cal; ca ++ ) {

              value = customAttribute.value[ ca ];

              customAttribute.array[ offset ]    = value.x;
              customAttribute.array[ offset + 1  ] = value.y;
              customAttribute.array[ offset + 2  ] = value.z;
              customAttribute.array[ offset + 3  ] = value.w;

              offset += 4;

            }

          }

          _gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
          _gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

        }

      }

    }

  }

  function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

    if ( ! geometryGroup.__inittedArrays ) {

      return;

    }

    var needsSmoothNormals = materialNeedsSmoothNormals( material );

    var f, fl, fi, face,
    vertexNormals, faceNormal, normal,
    vertexColors, faceColor,
    vertexTangents,
    uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
    c1, c2, c3,
    sw1, sw2, sw3, sw4,
    si1, si2, si3, si4,
    sa1, sa2, sa3, sa4,
    sb1, sb2, sb3, sb4,
    m, ml, i, il,
    vn, uvi, uv2i,
    vk, vkl, vka,
    nka, chf, faceVertexNormals,
    a,

    vertexIndex = 0,

    offset = 0,
    offset_uv = 0,
    offset_uv2 = 0,
    offset_face = 0,
    offset_normal = 0,
    offset_tangent = 0,
    offset_line = 0,
    offset_color = 0,
    offset_skin = 0,
    offset_morphTarget = 0,
    offset_custom = 0,
    offset_customSrc = 0,

    value,

    vertexArray = geometryGroup.__vertexArray,
    uvArray = geometryGroup.__uvArray,
    uv2Array = geometryGroup.__uv2Array,
    normalArray = geometryGroup.__normalArray,
    tangentArray = geometryGroup.__tangentArray,
    colorArray = geometryGroup.__colorArray,

    skinIndexArray = geometryGroup.__skinIndexArray,
    skinWeightArray = geometryGroup.__skinWeightArray,

    morphTargetsArrays = geometryGroup.__morphTargetsArrays,
    morphNormalsArrays = geometryGroup.__morphNormalsArrays,

    customAttributes = geometryGroup.__webglCustomAttributesList,
    customAttribute,

    faceArray = geometryGroup.__faceArray,
    lineArray = geometryGroup.__lineArray,

    geometry = object.geometry, // this is shared for all chunks

    dirtyVertices = geometry.verticesNeedUpdate,
    dirtyElements = geometry.elementsNeedUpdate,
    dirtyUvs = geometry.uvsNeedUpdate,
    dirtyNormals = geometry.normalsNeedUpdate,
    dirtyTangents = geometry.tangentsNeedUpdate,
    dirtyColors = geometry.colorsNeedUpdate,
    dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

    vertices = geometry.vertices,
    chunk_faces3 = geometryGroup.faces3,
    obj_faces = geometry.faces,

    obj_uvs  = geometry.faceVertexUvs[ 0 ],
    obj_uvs2 = geometry.faceVertexUvs[ 1 ],

    obj_colors = geometry.colors,

    obj_skinIndices = geometry.skinIndices,
    obj_skinWeights = geometry.skinWeights,

    morphTargets = geometry.morphTargets,
    morphNormals = geometry.morphNormals;

    if ( dirtyVertices ) {

      for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

        face = obj_faces[ chunk_faces3[ f ] ];

        v1 = vertices[ face.a ];
        v2 = vertices[ face.b ];
        v3 = vertices[ face.c ];

        vertexArray[ offset ]     = v1.x;
        vertexArray[ offset + 1 ] = v1.y;
        vertexArray[ offset + 2 ] = v1.z;

        vertexArray[ offset + 3 ] = v2.x;
        vertexArray[ offset + 4 ] = v2.y;
        vertexArray[ offset + 5 ] = v2.z;

        vertexArray[ offset + 6 ] = v3.x;
        vertexArray[ offset + 7 ] = v3.y;
        vertexArray[ offset + 8 ] = v3.z;

        offset += 9;

      }

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

    }

    if ( dirtyMorphTargets ) {

      for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

        offset_morphTarget = 0;

        for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

          chf = chunk_faces3[ f ];
          face = obj_faces[ chf ];

          // morph positions

          v1 = morphTargets[ vk ].vertices[ face.a ];
          v2 = morphTargets[ vk ].vertices[ face.b ];
          v3 = morphTargets[ vk ].vertices[ face.c ];

          vka = morphTargetsArrays[ vk ];

          vka[ offset_morphTarget ]     = v1.x;
          vka[ offset_morphTarget + 1 ] = v1.y;
          vka[ offset_morphTarget + 2 ] = v1.z;

          vka[ offset_morphTarget + 3 ] = v2.x;
          vka[ offset_morphTarget + 4 ] = v2.y;
          vka[ offset_morphTarget + 5 ] = v2.z;

          vka[ offset_morphTarget + 6 ] = v3.x;
          vka[ offset_morphTarget + 7 ] = v3.y;
          vka[ offset_morphTarget + 8 ] = v3.z;

          // morph normals

          if ( material.morphNormals ) {

            if ( needsSmoothNormals ) {

              faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

              n1 = faceVertexNormals.a;
              n2 = faceVertexNormals.b;
              n3 = faceVertexNormals.c;

            } else {

              n1 = morphNormals[ vk ].faceNormals[ chf ];
              n2 = n1;
              n3 = n1;

            }

            nka = morphNormalsArrays[ vk ];

            nka[ offset_morphTarget ]     = n1.x;
            nka[ offset_morphTarget + 1 ] = n1.y;
            nka[ offset_morphTarget + 2 ] = n1.z;

            nka[ offset_morphTarget + 3 ] = n2.x;
            nka[ offset_morphTarget + 4 ] = n2.y;
            nka[ offset_morphTarget + 5 ] = n2.z;

            nka[ offset_morphTarget + 6 ] = n3.x;
            nka[ offset_morphTarget + 7 ] = n3.y;
            nka[ offset_morphTarget + 8 ] = n3.z;

          }

          //

          offset_morphTarget += 9;

        }

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
        _gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

        if ( material.morphNormals ) {

          _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
          _gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

        }

      }

    }

    if ( obj_skinWeights.length ) {

      for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

        face = obj_faces[ chunk_faces3[ f ] ];

        // weights

        sw1 = obj_skinWeights[ face.a ];
        sw2 = obj_skinWeights[ face.b ];
        sw3 = obj_skinWeights[ face.c ];

        skinWeightArray[ offset_skin ]     = sw1.x;
        skinWeightArray[ offset_skin + 1 ] = sw1.y;
        skinWeightArray[ offset_skin + 2 ] = sw1.z;
        skinWeightArray[ offset_skin + 3 ] = sw1.w;

        skinWeightArray[ offset_skin + 4 ] = sw2.x;
        skinWeightArray[ offset_skin + 5 ] = sw2.y;
        skinWeightArray[ offset_skin + 6 ] = sw2.z;
        skinWeightArray[ offset_skin + 7 ] = sw2.w;

        skinWeightArray[ offset_skin + 8 ]  = sw3.x;
        skinWeightArray[ offset_skin + 9 ]  = sw3.y;
        skinWeightArray[ offset_skin + 10 ] = sw3.z;
        skinWeightArray[ offset_skin + 11 ] = sw3.w;

        // indices

        si1 = obj_skinIndices[ face.a ];
        si2 = obj_skinIndices[ face.b ];
        si3 = obj_skinIndices[ face.c ];

        skinIndexArray[ offset_skin ]     = si1.x;
        skinIndexArray[ offset_skin + 1 ] = si1.y;
        skinIndexArray[ offset_skin + 2 ] = si1.z;
        skinIndexArray[ offset_skin + 3 ] = si1.w;

        skinIndexArray[ offset_skin + 4 ] = si2.x;
        skinIndexArray[ offset_skin + 5 ] = si2.y;
        skinIndexArray[ offset_skin + 6 ] = si2.z;
        skinIndexArray[ offset_skin + 7 ] = si2.w;

        skinIndexArray[ offset_skin + 8 ]  = si3.x;
        skinIndexArray[ offset_skin + 9 ]  = si3.y;
        skinIndexArray[ offset_skin + 10 ] = si3.z;
        skinIndexArray[ offset_skin + 11 ] = si3.w;

        offset_skin += 12;

      }

      if ( offset_skin > 0 ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
        _gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
        _gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

      }

    }

    if ( dirtyColors ) {

      for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

        face = obj_faces[ chunk_faces3[ f ] ];

        vertexColors = face.vertexColors;
        faceColor = face.color;

        if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {

          c1 = vertexColors[ 0 ];
          c2 = vertexColors[ 1 ];
          c3 = vertexColors[ 2 ];

        } else {

          c1 = faceColor;
          c2 = faceColor;
          c3 = faceColor;

        }

        colorArray[ offset_color ]     = c1.r;
        colorArray[ offset_color + 1 ] = c1.g;
        colorArray[ offset_color + 2 ] = c1.b;

        colorArray[ offset_color + 3 ] = c2.r;
        colorArray[ offset_color + 4 ] = c2.g;
        colorArray[ offset_color + 5 ] = c2.b;

        colorArray[ offset_color + 6 ] = c3.r;
        colorArray[ offset_color + 7 ] = c3.g;
        colorArray[ offset_color + 8 ] = c3.b;

        offset_color += 9;

      }

      if ( offset_color > 0 ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
        _gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

      }

    }

    if ( dirtyTangents && geometry.hasTangents ) {

      for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

        face = obj_faces[ chunk_faces3[ f ] ];

        vertexTangents = face.vertexTangents;

        t1 = vertexTangents[ 0 ];
        t2 = vertexTangents[ 1 ];
        t3 = vertexTangents[ 2 ];

        tangentArray[ offset_tangent ]     = t1.x;
        tangentArray[ offset_tangent + 1 ] = t1.y;
        tangentArray[ offset_tangent + 2 ] = t1.z;
        tangentArray[ offset_tangent + 3 ] = t1.w;

        tangentArray[ offset_tangent + 4 ] = t2.x;
        tangentArray[ offset_tangent + 5 ] = t2.y;
        tangentArray[ offset_tangent + 6 ] = t2.z;
        tangentArray[ offset_tangent + 7 ] = t2.w;

        tangentArray[ offset_tangent + 8 ]  = t3.x;
        tangentArray[ offset_tangent + 9 ]  = t3.y;
        tangentArray[ offset_tangent + 10 ] = t3.z;
        tangentArray[ offset_tangent + 11 ] = t3.w;

        offset_tangent += 12;

      }

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

    }

    if ( dirtyNormals ) {

      for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

        face = obj_faces[ chunk_faces3[ f ] ];

        vertexNormals = face.vertexNormals;
        faceNormal = face.normal;

        if ( vertexNormals.length === 3 && needsSmoothNormals ) {

          for ( i = 0; i < 3; i ++ ) {

            vn = vertexNormals[ i ];

            normalArray[ offset_normal ]     = vn.x;
            normalArray[ offset_normal + 1 ] = vn.y;
            normalArray[ offset_normal + 2 ] = vn.z;

            offset_normal += 3;

          }

        } else {

          for ( i = 0; i < 3; i ++ ) {

            normalArray[ offset_normal ]     = faceNormal.x;
            normalArray[ offset_normal + 1 ] = faceNormal.y;
            normalArray[ offset_normal + 2 ] = faceNormal.z;

            offset_normal += 3;

          }

        }

      }

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

    }

    if ( dirtyUvs && obj_uvs ) {

      for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

        fi = chunk_faces3[ f ];

        uv = obj_uvs[ fi ];

        if ( uv === undefined ) continue;

        for ( i = 0; i < 3; i ++ ) {

          uvi = uv[ i ];

          uvArray[ offset_uv ]     = uvi.x;
          uvArray[ offset_uv + 1 ] = uvi.y;

          offset_uv += 2;

        }

      }

      if ( offset_uv > 0 ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
        _gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

      }

    }

    if ( dirtyUvs && obj_uvs2 ) {

      for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

        fi = chunk_faces3[ f ];

        uv2 = obj_uvs2[ fi ];

        if ( uv2 === undefined ) continue;

        for ( i = 0; i < 3; i ++ ) {

          uv2i = uv2[ i ];

          uv2Array[ offset_uv2 ]     = uv2i.x;
          uv2Array[ offset_uv2 + 1 ] = uv2i.y;

          offset_uv2 += 2;

        }

      }

      if ( offset_uv2 > 0 ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
        _gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

      }

    }

    if ( dirtyElements ) {

      for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

        faceArray[ offset_face ]   = vertexIndex;
        faceArray[ offset_face + 1 ] = vertexIndex + 1;
        faceArray[ offset_face + 2 ] = vertexIndex + 2;

        offset_face += 3;

        lineArray[ offset_line ]     = vertexIndex;
        lineArray[ offset_line + 1 ] = vertexIndex + 1;

        lineArray[ offset_line + 2 ] = vertexIndex;
        lineArray[ offset_line + 3 ] = vertexIndex + 2;

        lineArray[ offset_line + 4 ] = vertexIndex + 1;
        lineArray[ offset_line + 5 ] = vertexIndex + 2;

        offset_line += 6;

        vertexIndex += 3;

      }

      _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
      _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

      _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
      _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

    }

    if ( customAttributes ) {

      for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

        customAttribute = customAttributes[ i ];

        if ( ! customAttribute.__original.needsUpdate ) continue;

        offset_custom = 0;
        offset_customSrc = 0;

        if ( customAttribute.size === 1 ) {

          if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              face = obj_faces[ chunk_faces3[ f ] ];

              customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
              customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
              customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

              offset_custom += 3;

            }

          } else if ( customAttribute.boundTo === 'faces' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              value = customAttribute.value[ chunk_faces3[ f ] ];

              customAttribute.array[ offset_custom ]     = value;
              customAttribute.array[ offset_custom + 1 ] = value;
              customAttribute.array[ offset_custom + 2 ] = value;

              offset_custom += 3;

            }

          }

        } else if ( customAttribute.size === 2 ) {

          if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              face = obj_faces[ chunk_faces3[ f ] ];

              v1 = customAttribute.value[ face.a ];
              v2 = customAttribute.value[ face.b ];
              v3 = customAttribute.value[ face.c ];

              customAttribute.array[ offset_custom ]     = v1.x;
              customAttribute.array[ offset_custom + 1 ] = v1.y;

              customAttribute.array[ offset_custom + 2 ] = v2.x;
              customAttribute.array[ offset_custom + 3 ] = v2.y;

              customAttribute.array[ offset_custom + 4 ] = v3.x;
              customAttribute.array[ offset_custom + 5 ] = v3.y;

              offset_custom += 6;

            }

          } else if ( customAttribute.boundTo === 'faces' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              value = customAttribute.value[ chunk_faces3[ f ] ];

              v1 = value;
              v2 = value;
              v3 = value;

              customAttribute.array[ offset_custom ]     = v1.x;
              customAttribute.array[ offset_custom + 1 ] = v1.y;

              customAttribute.array[ offset_custom + 2 ] = v2.x;
              customAttribute.array[ offset_custom + 3 ] = v2.y;

              customAttribute.array[ offset_custom + 4 ] = v3.x;
              customAttribute.array[ offset_custom + 5 ] = v3.y;

              offset_custom += 6;

            }

          }

        } else if ( customAttribute.size === 3 ) {

          var pp;

          if ( customAttribute.type === 'c' ) {

            pp = [ 'r', 'g', 'b' ];

          } else {

            pp = [ 'x', 'y', 'z' ];

          }

          if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              face = obj_faces[ chunk_faces3[ f ] ];

              v1 = customAttribute.value[ face.a ];
              v2 = customAttribute.value[ face.b ];
              v3 = customAttribute.value[ face.c ];

              customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

              customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

              customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

              offset_custom += 9;

            }

          } else if ( customAttribute.boundTo === 'faces' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              value = customAttribute.value[ chunk_faces3[ f ] ];

              v1 = value;
              v2 = value;
              v3 = value;

              customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

              customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

              customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

              offset_custom += 9;

            }

          } else if ( customAttribute.boundTo === 'faceVertices' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              value = customAttribute.value[ chunk_faces3[ f ] ];

              v1 = value[ 0 ];
              v2 = value[ 1 ];
              v3 = value[ 2 ];

              customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

              customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

              customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
              customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
              customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

              offset_custom += 9;

            }

          }

        } else if ( customAttribute.size === 4 ) {

          if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              face = obj_faces[ chunk_faces3[ f ] ];

              v1 = customAttribute.value[ face.a ];
              v2 = customAttribute.value[ face.b ];
              v3 = customAttribute.value[ face.c ];

              customAttribute.array[ offset_custom  ]   = v1.x;
              customAttribute.array[ offset_custom + 1  ] = v1.y;
              customAttribute.array[ offset_custom + 2  ] = v1.z;
              customAttribute.array[ offset_custom + 3  ] = v1.w;

              customAttribute.array[ offset_custom + 4  ] = v2.x;
              customAttribute.array[ offset_custom + 5  ] = v2.y;
              customAttribute.array[ offset_custom + 6  ] = v2.z;
              customAttribute.array[ offset_custom + 7  ] = v2.w;

              customAttribute.array[ offset_custom + 8  ] = v3.x;
              customAttribute.array[ offset_custom + 9  ] = v3.y;
              customAttribute.array[ offset_custom + 10 ] = v3.z;
              customAttribute.array[ offset_custom + 11 ] = v3.w;

              offset_custom += 12;

            }

          } else if ( customAttribute.boundTo === 'faces' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              value = customAttribute.value[ chunk_faces3[ f ] ];

              v1 = value;
              v2 = value;
              v3 = value;

              customAttribute.array[ offset_custom  ]   = v1.x;
              customAttribute.array[ offset_custom + 1  ] = v1.y;
              customAttribute.array[ offset_custom + 2  ] = v1.z;
              customAttribute.array[ offset_custom + 3  ] = v1.w;

              customAttribute.array[ offset_custom + 4  ] = v2.x;
              customAttribute.array[ offset_custom + 5  ] = v2.y;
              customAttribute.array[ offset_custom + 6  ] = v2.z;
              customAttribute.array[ offset_custom + 7  ] = v2.w;

              customAttribute.array[ offset_custom + 8  ] = v3.x;
              customAttribute.array[ offset_custom + 9  ] = v3.y;
              customAttribute.array[ offset_custom + 10 ] = v3.z;
              customAttribute.array[ offset_custom + 11 ] = v3.w;

              offset_custom += 12;

            }

          } else if ( customAttribute.boundTo === 'faceVertices' ) {

            for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

              value = customAttribute.value[ chunk_faces3[ f ] ];

              v1 = value[ 0 ];
              v2 = value[ 1 ];
              v3 = value[ 2 ];

              customAttribute.array[ offset_custom  ]   = v1.x;
              customAttribute.array[ offset_custom + 1  ] = v1.y;
              customAttribute.array[ offset_custom + 2  ] = v1.z;
              customAttribute.array[ offset_custom + 3  ] = v1.w;

              customAttribute.array[ offset_custom + 4  ] = v2.x;
              customAttribute.array[ offset_custom + 5  ] = v2.y;
              customAttribute.array[ offset_custom + 6  ] = v2.z;
              customAttribute.array[ offset_custom + 7  ] = v2.w;

              customAttribute.array[ offset_custom + 8  ] = v3.x;
              customAttribute.array[ offset_custom + 9  ] = v3.y;
              customAttribute.array[ offset_custom + 10 ] = v3.z;
              customAttribute.array[ offset_custom + 11 ] = v3.w;

              offset_custom += 12;

            }

          }

        }

        _gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
        _gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

      }

    }

    if ( dispose ) {

      delete geometryGroup.__inittedArrays;
      delete geometryGroup.__colorArray;
      delete geometryGroup.__normalArray;
      delete geometryGroup.__tangentArray;
      delete geometryGroup.__uvArray;
      delete geometryGroup.__uv2Array;
      delete geometryGroup.__faceArray;
      delete geometryGroup.__vertexArray;
      delete geometryGroup.__lineArray;
      delete geometryGroup.__skinIndexArray;
      delete geometryGroup.__skinWeightArray;

    }

  };

  function setDirectBuffers( geometry ) {

    var attributes = geometry.attributes;
    var attributesKeys = geometry.attributesKeys;

    for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {

      var key = attributesKeys[ i ];
      var attribute = attributes[ key ];

      if ( attribute.buffer === undefined ) {

        attribute.buffer = _gl.createBuffer();
        attribute.needsUpdate = true;

      }

      if ( attribute.needsUpdate === true ) {

        var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

        _gl.bindBuffer( bufferType, attribute.buffer );
        _gl.bufferData( bufferType, attribute.array, _gl.STATIC_DRAW );

        attribute.needsUpdate = false;

      }

    }

  }

  // Buffer rendering

  this.renderBufferImmediate = function ( object, program, material ) {

    initAttributes();

    if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
    if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
    if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
    if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

    if ( object.hasPositions ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
      enableAttribute( program.attributes.position );
      _gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasNormals ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

      if ( material.shading === THREE.FlatShading ) {

        var nx, ny, nz,
          nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
          normalArray,
          i, il = object.count * 3;

        for ( i = 0; i < il; i += 9 ) {

          normalArray = object.normalArray;

          nax  = normalArray[ i ];
          nay  = normalArray[ i + 1 ];
          naz  = normalArray[ i + 2 ];

          nbx  = normalArray[ i + 3 ];
          nby  = normalArray[ i + 4 ];
          nbz  = normalArray[ i + 5 ];

          ncx  = normalArray[ i + 6 ];
          ncy  = normalArray[ i + 7 ];
          ncz  = normalArray[ i + 8 ];

          nx = ( nax + nbx + ncx ) / 3;
          ny = ( nay + nby + ncy ) / 3;
          nz = ( naz + nbz + ncz ) / 3;

          normalArray[ i ]   = nx;
          normalArray[ i + 1 ] = ny;
          normalArray[ i + 2 ] = nz;

          normalArray[ i + 3 ] = nx;
          normalArray[ i + 4 ] = ny;
          normalArray[ i + 5 ] = nz;

          normalArray[ i + 6 ] = nx;
          normalArray[ i + 7 ] = ny;
          normalArray[ i + 8 ] = nz;

        }

      }

      _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
      enableAttribute( program.attributes.normal );
      _gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasUvs && material.map ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
      enableAttribute( program.attributes.uv );
      _gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
      enableAttribute( program.attributes.color );
      _gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    }

    disableUnusedAttributes();

    _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    object.count = 0;

  };

  function setupVertexAttributes( material, program, geometry, startIndex ) {

    var geometryAttributes = geometry.attributes;

    var programAttributes = program.attributes;
    var programAttributesKeys = program.attributesKeys;

    for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {

      var key = programAttributesKeys[ i ];
      var programAttribute = programAttributes[ key ];

      if ( programAttribute >= 0 ) {

        var geometryAttribute = geometryAttributes[ key ];

        if ( geometryAttribute !== undefined ) {

          var size = geometryAttribute.itemSize;

          _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );

          enableAttribute( programAttribute );

          _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

        } else if ( material.defaultAttributeValues !== undefined ) {

          if ( material.defaultAttributeValues[ key ].length === 2 ) {

            _gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

          } else if ( material.defaultAttributeValues[ key ].length === 3 ) {

            _gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

          }

        }

      }

    }

    disableUnusedAttributes();

  }

  this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

    if ( material.visible === false ) return;

    var program = setProgram( camera, lights, fog, material, object );

    var updateBuffers = false,
      wireframeBit = material.wireframe ? 1 : 0,
      geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

    if ( geometryHash !== _currentGeometryGroupHash ) {

      _currentGeometryGroupHash = geometryHash;
      updateBuffers = true;

    }

    if ( updateBuffers ) {

      initAttributes();

    }

    // render mesh

    if ( object instanceof THREE.Mesh ) {

      var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

      var index = geometry.attributes.index;

      if ( index ) {

        // indexed triangles

        var type, size;

        if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

          type = _gl.UNSIGNED_INT;
          size = 4;

        } else {

          type = _gl.UNSIGNED_SHORT;
          size = 2;

        }

        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry, 0 );
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

          }

          _gl.drawElements( mode, index.array.length, type, 0 );

          _this.info.render.calls ++;
          _this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
          _this.info.render.faces += index.array.length / 3;

        } else {

          // if there is more than 1 chunk
          // must set attribute pointers to use new offsets for each chunk
          // even if geometry and materials didn't change

          updateBuffers = true;

          for ( var i = 0, il = offsets.length; i < il; i ++ ) {

            var startIndex = offsets[ i ].index;

            if ( updateBuffers ) {

              setupVertexAttributes( material, program, geometry, startIndex );
              _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

            }

            // render indexed triangles

            _gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

            _this.info.render.calls ++;
            _this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
            _this.info.render.faces += offsets[ i ].count / 3;

          }

        }

      } else {

        // non-indexed triangles

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );

        }

        var position = geometry.attributes[ 'position' ];

        // render non-indexed triangles

        _gl.drawArrays( mode, 0, position.array.length / 3 );

        _this.info.render.calls ++;
        _this.info.render.vertices += position.array.length / 3;
        _this.info.render.faces += position.array.length / 9;

      }

    } else if ( object instanceof THREE.PointCloud ) {

      // render particles

      if ( updateBuffers ) {

        setupVertexAttributes( material, program, geometry, 0 );

      }

      var position = geometry.attributes.position;

      // render particles

      _gl.drawArrays( _gl.POINTS, 0, position.array.length / 3 );

      _this.info.render.calls ++;
      _this.info.render.points += position.array.length / 3;

    } else if ( object instanceof THREE.Line ) {

      var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

      setLineWidth( material.linewidth );

      var index = geometry.attributes.index;

      if ( index ) {

        // indexed lines

        var type, size;

        if ( index.array instanceof Uint32Array ) {

          type = _gl.UNSIGNED_INT;
          size = 4;

        } else {

          type = _gl.UNSIGNED_SHORT;
          size = 2;

        }

        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry, 0 );
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

          }

          _gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

          _this.info.render.calls ++;
          _this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

        } else {

          // if there is more than 1 chunk
          // must set attribute pointers to use new offsets for each chunk
          // even if geometry and materials didn't change

          if ( offsets.length > 1 ) updateBuffers = true;

          for ( var i = 0, il = offsets.length; i < il; i ++ ) {

            var startIndex = offsets[ i ].index;

            if ( updateBuffers ) {

              setupVertexAttributes( material, program, geometry, startIndex );
              _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

            }

            // render indexed lines

            _gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

            _this.info.render.calls ++;
            _this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

          }

        }

      } else {

        // non-indexed lines

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );

        }

        var position = geometry.attributes.position;

        _gl.drawArrays( mode, 0, position.array.length / 3 );

        _this.info.render.calls ++;
        _this.info.render.points += position.array.length / 3;

      }

    }

  };

  this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

    if ( material.visible === false ) return;

    var program = setProgram( camera, lights, fog, material, object );

    var attributes = program.attributes;

    var updateBuffers = false,
      wireframeBit = material.wireframe ? 1 : 0,
      geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

    if ( geometryGroupHash !== _currentGeometryGroupHash ) {

      _currentGeometryGroupHash = geometryGroupHash;
      updateBuffers = true;

    }

    if ( updateBuffers ) {

      initAttributes();

    }

    // vertices

    if ( ! material.morphTargets && attributes.position >= 0 ) {

      if ( updateBuffers ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
        enableAttribute( attributes.position );
        _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

      }

    } else {

      if ( object.morphTargetBase ) {

        setupMorphTargets( material, geometryGroup, object );

      }

    }


    if ( updateBuffers ) {

      // custom attributes

      // Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

      if ( geometryGroup.__webglCustomAttributesList ) {

        for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

          var attribute = geometryGroup.__webglCustomAttributesList[ i ];

          if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
            enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
            _gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

          }

        }

      }


      // colors

      if ( attributes.color >= 0 ) {

        if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

          _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
          enableAttribute( attributes.color );
          _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

        } else if ( material.defaultAttributeValues !== undefined ) {


          _gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

        }

      }

      // normals

      if ( attributes.normal >= 0 ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
        enableAttribute( attributes.normal );
        _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

      }

      // tangents

      if ( attributes.tangent >= 0 ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
        enableAttribute( attributes.tangent );
        _gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

      }

      // uvs

      if ( attributes.uv >= 0 ) {

        if ( object.geometry.faceVertexUvs[ 0 ] ) {

          _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
          enableAttribute( attributes.uv );
          _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

        } else if ( material.defaultAttributeValues !== undefined ) {


          _gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

        }

      }

      if ( attributes.uv2 >= 0 ) {

        if ( object.geometry.faceVertexUvs[ 1 ] ) {

          _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
          enableAttribute( attributes.uv2 );
          _gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

        } else if ( material.defaultAttributeValues !== undefined ) {


          _gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

        }

      }

      if ( material.skinning &&
         attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
        enableAttribute( attributes.skinIndex );
        _gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
        enableAttribute( attributes.skinWeight );
        _gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

      }

      // line distances

      if ( attributes.lineDistance >= 0 ) {

        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
        enableAttribute( attributes.lineDistance );
        _gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

      }

    }

    disableUnusedAttributes();

    // render mesh

    if ( object instanceof THREE.Mesh ) {

      var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

      // wireframe

      if ( material.wireframe ) {

        setLineWidth( material.wireframeLinewidth );
        if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
        _gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

      // triangles

      } else {

        if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
        _gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

      }

      _this.info.render.calls ++;
      _this.info.render.vertices += geometryGroup.__webglFaceCount;
      _this.info.render.faces += geometryGroup.__webglFaceCount / 3;

    // render lines

    } else if ( object instanceof THREE.Line ) {

      var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

      setLineWidth( material.linewidth );

      _gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

      _this.info.render.calls ++;

    // render particles

    } else if ( object instanceof THREE.PointCloud ) {

      _gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

      _this.info.render.calls ++;
      _this.info.render.points += geometryGroup.__webglParticleCount;

    }

  };

  function initAttributes() {

    for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {

      _newAttributes[ i ] = 0;

    }

  }

  function enableAttribute( attribute ) {

    _newAttributes[ attribute ] = 1;

    if ( _enabledAttributes[ attribute ] === 0 ) {

      _gl.enableVertexAttribArray( attribute );
      _enabledAttributes[ attribute ] = 1;

    }

  }

  function disableUnusedAttributes() {

    for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {

      if ( _enabledAttributes[ i ] !== _newAttributes[ i ] ) {

        _gl.disableVertexAttribArray( i );
        _enabledAttributes[ i ] = 0;

      }

    }

  }

  function setupMorphTargets ( material, geometryGroup, object ) {

    // set base

    var attributes = material.program.attributes;

    if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
      enableAttribute( attributes.position );
      _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    } else if ( attributes.position >= 0 ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
      enableAttribute( attributes.position );
      _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.morphTargetForcedOrder.length ) {

      // set forced order

      var m = 0;
      var order = object.morphTargetForcedOrder;
      var influences = object.morphTargetInfluences;

      while ( m < material.numSupportedMorphTargets && m < order.length ) {

        if ( attributes[ 'morphTarget' + m ] >= 0 ) {

          _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
          enableAttribute( attributes[ 'morphTarget' + m ] );
          _gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

        }

        if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

          _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
          enableAttribute( attributes[ 'morphNormal' + m ] );
          _gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );

        }

        object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

        m ++;
      }

    } else {

      // find the most influencing

      var influence, activeInfluenceIndices = [];
      var influences = object.morphTargetInfluences;
      var i, il = influences.length;

      for ( i = 0; i < il; i ++ ) {

        influence = influences[ i ];

        if ( influence > 0 ) {

          activeInfluenceIndices.push( [ influence, i ] );

        }

      }

      if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

        activeInfluenceIndices.sort( numericalSort );
        activeInfluenceIndices.length = material.numSupportedMorphTargets;

      } else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

        activeInfluenceIndices.sort( numericalSort );

      } else if ( activeInfluenceIndices.length === 0 ) {

        activeInfluenceIndices.push( [ 0, 0 ] );

      };

      var influenceIndex, m = 0;

      while ( m < material.numSupportedMorphTargets ) {

        if ( activeInfluenceIndices[ m ] ) {

          influenceIndex = activeInfluenceIndices[ m ][ 1 ];

          if ( attributes[ 'morphTarget' + m ] >= 0 ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
            enableAttribute( attributes[ 'morphTarget' + m ] );
            _gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

          }

          if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
            enableAttribute( attributes[ 'morphNormal' + m ] );
            _gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );


          }

          object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

        } else {

          /*
          _gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

          if ( material.morphNormals ) {

            _gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

          }
          */

          object.__webglMorphTargetInfluences[ m ] = 0;

        }

        m ++;

      }

    }

    // load updated influences uniform

    if ( material.program.uniforms.morphTargetInfluences !== null ) {

      _gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

    }

  }

  // Sorting

  function painterSortStable ( a, b ) {

    if ( a.material.id !== b.material.id ) {

      return b.material.id - a.material.id;

    } else if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return a.id - b.id;

    }

  }

  function reversePainterSortStable ( a, b ) {

    if ( a.z !== b.z ) {

      return a.z - b.z;

    } else {

      return a.id - b.id;

    }

  }

  function numericalSort ( a, b ) {

    return b[ 0 ] - a[ 0 ];

  }

  // Rendering

  this.render = function ( scene, camera, renderTarget, forceClear ) {

    if ( camera instanceof THREE.Camera === false ) {

      console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
      return;

    }

    var fog = scene.fog;

    // reset caching for this frame

    _currentGeometryGroupHash = - 1;
    _currentMaterialId = - 1;
    _currentCamera = null;
    _lightsNeedUpdate = true;

    // update scene graph

    if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    // update camera matrices and frustum

    if ( camera.parent === undefined ) camera.updateMatrixWorld();

    // update Skeleton objects

    scene.traverse( function ( object ) {

      if ( object instanceof THREE.SkinnedMesh ) {

        object.skeleton.update();

      }

    } );

    camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    _frustum.setFromMatrix( _projScreenMatrix );

    lights.length = 0;
    opaqueObjects.length = 0;
    transparentObjects.length = 0;

    sprites.length = 0;
    lensFlares.length = 0;

    projectObject( scene, scene );

    if ( _this.sortObjects === true ) {

      opaqueObjects.sort( painterSortStable );
      transparentObjects.sort( reversePainterSortStable );

    }

    // custom render plugins (pre pass)

    shadowMapPlugin.render( scene, camera );

    //

    _this.info.render.calls = 0;
    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;
    _this.info.render.points = 0;

    this.setRenderTarget( renderTarget );

    if ( this.autoClear || forceClear ) {

      this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    }

    // set matrices for immediate objects

    for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {

      var webglObject = _webglObjectsImmediate[ i ];
      var object = webglObject.object;

      if ( object.visible ) {

        setupMatrices( object, camera );

        unrollImmediateBufferMaterial( webglObject );

      }

    }

    if ( scene.overrideMaterial ) {

      var material = scene.overrideMaterial;

      this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
      this.setDepthTest( material.depthTest );
      this.setDepthWrite( material.depthWrite );
      setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

      renderObjects( opaqueObjects, camera, lights, fog, true, material );
      renderObjects( transparentObjects, camera, lights, fog, true, material );
      renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, false, material );

    } else {

      var material = null;

      // opaque pass (front-to-back order)

      this.setBlending( THREE.NoBlending );

      renderObjects( opaqueObjects, camera, lights, fog, false, material );
      renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, false, material );

      // transparent pass (back-to-front order)

      renderObjects( transparentObjects, camera, lights, fog, true, material );
      renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, true, material );

    }

    // custom render plugins (post pass)

    spritePlugin.render( scene, camera );
    lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

    // Generate mipmap if we're using any kind of mipmap filtering

    if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

      updateRenderTargetMipmap( renderTarget );

    }

    // Ensure depth buffer writing is enabled so it can be cleared on next render

    this.setDepthTest( true );
    this.setDepthWrite( true );

    // _gl.finish();

  };

  function projectObject( scene, object ) {

    if ( object.visible === false ) return;

    if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

      // skip

    } else {

      initObject( object, scene );

      if ( object instanceof THREE.Light ) {

        lights.push( object );

      } else if ( object instanceof THREE.Sprite ) {

        sprites.push( object );

      } else if ( object instanceof THREE.LensFlare ) {

        lensFlares.push( object );

      } else {

        var webglObjects = _webglObjects[ object.id ];

        if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

          updateObject( object, scene );

          for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

            var webglObject = webglObjects[i];

            unrollBufferMaterial( webglObject );

            webglObject.render = true;

            if ( _this.sortObjects === true ) {

              if ( object.renderDepth !== null ) {

                webglObject.z = object.renderDepth;

              } else {

                _vector3.setFromMatrixPosition( object.matrixWorld );
                _vector3.applyProjection( _projScreenMatrix );

                webglObject.z = _vector3.z;

              }

            }

          }

        }

      }

    }

    for ( var i = 0, l = object.children.length; i < l; i ++ ) {

      projectObject( scene, object.children[ i ] );

    }

  }

  function renderObjects( renderList, camera, lights, fog, useBlending, overrideMaterial ) {

    var material;

    for ( var i = renderList.length - 1; i !== - 1; i -- ) {

      var webglObject = renderList[ i ];

      var object = webglObject.object;
      var buffer = webglObject.buffer;

      setupMatrices( object, camera );

      if ( overrideMaterial ) {

        material = overrideMaterial;

      } else {

        material = webglObject.material;

        if ( ! material ) continue;

        if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

        _this.setDepthTest( material.depthTest );
        _this.setDepthWrite( material.depthWrite );
        setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

      }

      _this.setMaterialFaces( material );

      if ( buffer instanceof THREE.BufferGeometry ) {

        _this.renderBufferDirect( camera, lights, fog, material, buffer, object );

      } else {

        _this.renderBuffer( camera, lights, fog, material, buffer, object );

      }

    }

  }

  function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

    var material;

    for ( var i = 0, il = renderList.length; i < il; i ++ ) {

      var webglObject = renderList[ i ];
      var object = webglObject.object;

      if ( object.visible ) {

        if ( overrideMaterial ) {

          material = overrideMaterial;

        } else {

          material = webglObject[ materialType ];

          if ( ! material ) continue;

          if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

          _this.setDepthTest( material.depthTest );
          _this.setDepthWrite( material.depthWrite );
          setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

        }

        _this.renderImmediateObject( camera, lights, fog, material, object );

      }

    }

  }

  this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

    var program = setProgram( camera, lights, fog, material, object );

    _currentGeometryGroupHash = - 1;

    _this.setMaterialFaces( material );

    if ( object.immediateRenderCallback ) {

      object.immediateRenderCallback( program, _gl, _frustum );

    } else {

      object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

    }

  };

  function unrollImmediateBufferMaterial ( globject ) {

    var object = globject.object,
      material = object.material;

    if ( material.transparent ) {

      globject.transparent = material;
      globject.opaque = null;

    } else {

      globject.opaque = material;
      globject.transparent = null;

    }

  }

  function unrollBufferMaterial ( globject ) {

    var object = globject.object;
    var buffer = globject.buffer;

    var geometry = object.geometry;
    var material = object.material;

    if ( material instanceof THREE.MeshFaceMaterial ) {

      var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

      material = material.materials[ materialIndex ];

      globject.material = material;

      if ( material.transparent ) {

        transparentObjects.push( globject );

      } else {

        opaqueObjects.push( globject );

      }

    } else if ( material ) {

      globject.material = material;

      if ( material.transparent ) {

        transparentObjects.push( globject );

      } else {

        opaqueObjects.push( globject );

      }

    }

  }

  function initObject( object, scene ) {

    if ( object.__webglInit === undefined ) {

      object.__webglInit = true;
      object._modelViewMatrix = new THREE.Matrix4();
      object._normalMatrix = new THREE.Matrix3();

      object.addEventListener( 'removed', onObjectRemoved );

    }

    var geometry = object.geometry;

    if ( geometry === undefined ) {

      // ImmediateRenderObject

    } else if ( geometry.__webglInit === undefined ) {

      geometry.__webglInit = true;
      geometry.addEventListener( 'dispose', onGeometryDispose );

      if ( geometry instanceof THREE.BufferGeometry ) {

        //

      } else if ( object instanceof THREE.Mesh ) {

        initGeometryGroups( scene, object, geometry );

      } else if ( object instanceof THREE.Line ) {

        if ( geometry.__webglVertexBuffer === undefined ) {

          createLineBuffers( geometry );
          initLineBuffers( geometry, object );

          geometry.verticesNeedUpdate = true;
          geometry.colorsNeedUpdate = true;
          geometry.lineDistancesNeedUpdate = true;

        }

      } else if ( object instanceof THREE.PointCloud ) {

        if ( geometry.__webglVertexBuffer === undefined ) {

          createParticleBuffers( geometry );
          initParticleBuffers( geometry, object );

          geometry.verticesNeedUpdate = true;
          geometry.colorsNeedUpdate = true;

        }

      }

    }

    if ( object.__webglActive === undefined) {

      object.__webglActive = true;

      if ( object instanceof THREE.Mesh ) {

        if ( geometry instanceof THREE.BufferGeometry ) {

          addBuffer( _webglObjects, geometry, object );

        } else if ( geometry instanceof THREE.Geometry ) {

          var geometryGroupsList = geometryGroups[ geometry.id ];

          for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

            addBuffer( _webglObjects, geometryGroupsList[ i ], object );

          }

        }

      } else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

        addBuffer( _webglObjects, geometry, object );

      } else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

        addBufferImmediate( _webglObjectsImmediate, object );

      }

    }

  }

  // Geometry splitting

  var geometryGroups = {};
  var geometryGroupCounter = 0;

  function makeGroups( geometry, usesFaceMaterial ) {

    var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

    var groupHash, hash_map = {};

    var numMorphTargets = geometry.morphTargets.length;
    var numMorphNormals = geometry.morphNormals.length;

    var group;
    var groups = {};
    var groupsList = [];

    for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

      var face = geometry.faces[ f ];
      var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

      if ( ! ( materialIndex in hash_map ) ) {

        hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

      }

      groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

      if ( ! ( groupHash in groups ) ) {

        group = {
          id: geometryGroupCounter ++,
          faces3: [],
          materialIndex: materialIndex,
          vertices: 0,
          numMorphTargets: numMorphTargets,
          numMorphNormals: numMorphNormals
        };
        
        groups[ groupHash ] = group;
        groupsList.push( group );

      }

      if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

        hash_map[ materialIndex ].counter += 1;
        groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

        if ( ! ( groupHash in groups ) ) {

          group = {
            id: geometryGroupCounter ++,
            faces3: [],
            materialIndex: materialIndex,
            vertices: 0,
            numMorphTargets: numMorphTargets,
            numMorphNormals: numMorphNormals
          };
          
          groups[ groupHash ] = group;
          groupsList.push( group );

        }

      }

      groups[ groupHash ].faces3.push( f );
      groups[ groupHash ].vertices += 3;

    }

    return groupsList;

  }

  function initGeometryGroups( scene, object, geometry ) {

    var material = object.material, addBuffers = false;

    if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

      delete _webglObjects[ object.id ];

      geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );

      geometry.groupsNeedUpdate = false;

    }

    var geometryGroupsList = geometryGroups[ geometry.id ];

    // create separate VBOs per geometry chunk

    for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

      var geometryGroup = geometryGroupsList[ i ];

      // initialise VBO on the first access

      if ( geometryGroup.__webglVertexBuffer === undefined ) {

        createMeshBuffers( geometryGroup );
        initMeshBuffers( geometryGroup, object );

        geometry.verticesNeedUpdate = true;
        geometry.morphTargetsNeedUpdate = true;
        geometry.elementsNeedUpdate = true;
        geometry.uvsNeedUpdate = true;
        geometry.normalsNeedUpdate = true;
        geometry.tangentsNeedUpdate = true;
        geometry.colorsNeedUpdate = true;

        addBuffers = true;

      } else {

        addBuffers = false;

      }

      if ( addBuffers || object.__webglActive === undefined ) {

        addBuffer( _webglObjects, geometryGroup, object );

      }

    }

    object.__webglActive = true;

  }

  function addBuffer( objlist, buffer, object ) {

    var id = object.id;
    objlist[id] = objlist[id] || [];
    objlist[id].push(
      {
        id: id,
        buffer: buffer,
        object: object,
        material: null,
        z: 0
      }
    );

  };

  function addBufferImmediate( objlist, object ) {

    objlist.push(
      {
        id: null,
        object: object,
        opaque: null,
        transparent: null,
        z: 0
      }
    );

  };

  // Objects updates

  function updateObject( object, scene ) {

    var geometry = object.geometry, customAttributesDirty, material;

    if ( geometry instanceof THREE.BufferGeometry ) {

      setDirectBuffers( geometry );

    } else if ( object instanceof THREE.Mesh ) {

      // check all geometry groups

      if ( geometry.groupsNeedUpdate === true ) {

        initGeometryGroups( scene, object, geometry );

      }

      var geometryGroupsList = geometryGroups[ geometry.id ];

      for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

        var geometryGroup = geometryGroupsList[ i ];

        material = getBufferMaterial( object, geometryGroup );

        if ( geometry.groupsNeedUpdate === true ) {

          initMeshBuffers( geometryGroup, object );

        }

        customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

        if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
           geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
           geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

          setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

        }

      }

      geometry.verticesNeedUpdate = false;
      geometry.morphTargetsNeedUpdate = false;
      geometry.elementsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.tangentsNeedUpdate = false;

      material.attributes && clearCustomAttributes( material );

    } else if ( object instanceof THREE.Line ) {

      material = getBufferMaterial( object, geometry );

      customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

      if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

        setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

      }

      geometry.verticesNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.lineDistancesNeedUpdate = false;

      material.attributes && clearCustomAttributes( material );


    } else if ( object instanceof THREE.PointCloud ) {

      material = getBufferMaterial( object, geometry );

      customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

      if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

        setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

      }

      geometry.verticesNeedUpdate = false;
      geometry.colorsNeedUpdate = false;

      material.attributes && clearCustomAttributes( material );

    }

  }

  // Objects updates - custom attributes check

  function areCustomAttributesDirty( material ) {

    for ( var name in material.attributes ) {

      if ( material.attributes[ name ].needsUpdate ) return true;

    }

    return false;

  }

  function clearCustomAttributes( material ) {

    for ( var name in material.attributes ) {

      material.attributes[ name ].needsUpdate = false;

    }

  }

  // Objects removal

  function removeObject( object ) {

    if ( object instanceof THREE.Mesh  ||
       object instanceof THREE.PointCloud ||
       object instanceof THREE.Line ) {

      delete _webglObjects[ object.id ];

    } else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

      removeInstances( _webglObjectsImmediate, object );

    }

    delete object.__webglInit;
    delete object._modelViewMatrix;
    delete object._normalMatrix;

    delete object.__webglActive;

  }

  function removeInstances( objlist, object ) {

    for ( var o = objlist.length - 1; o >= 0; o -- ) {

      if ( objlist[ o ].object === object ) {

        objlist.splice( o, 1 );

      }

    }

  }

  // Materials

  function initMaterial( material, lights, fog, object ) {

    material.addEventListener( 'dispose', onMaterialDispose );

    var shaderID;

    if ( material instanceof THREE.MeshDepthMaterial ) {

      shaderID = 'depth';

    } else if ( material instanceof THREE.MeshNormalMaterial ) {

      shaderID = 'normal';

    } else if ( material instanceof THREE.MeshBasicMaterial ) {

      shaderID = 'basic';

    } else if ( material instanceof THREE.MeshLambertMaterial ) {

      shaderID = 'lambert';

    } else if ( material instanceof THREE.MeshPhongMaterial ) {

      shaderID = 'phong';

    } else if ( material instanceof THREE.LineBasicMaterial ) {

      shaderID = 'basic';

    } else if ( material instanceof THREE.LineDashedMaterial ) {

      shaderID = 'dashed';

    } else if ( material instanceof THREE.PointCloudMaterial ) {

      shaderID = 'particle_basic';

    }

    if ( shaderID ) {

      var shader = THREE.ShaderLib[ shaderID ];

      material.__webglShader = {
        uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      }

    } else {

      material.__webglShader = {
        uniforms: material.uniforms,
        vertexShader: material.vertexShader,
        fragmentShader: material.fragmentShader
      }

    }

    // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxLightCount = allocateLights( lights );
    var maxShadows = allocateShadows( lights );
    var maxBones = allocateBones( object );

    var parameters = {

      precision: _precision,
      supportsVertexTextures: _supportsVertexTextures,

      map: !! material.map,
      envMap: !! material.envMap,
      lightMap: !! material.lightMap,
      bumpMap: !! material.bumpMap,
      normalMap: !! material.normalMap,
      specularMap: !! material.specularMap,
      alphaMap: !! material.alphaMap,

      vertexColors: material.vertexColors,

      fog: fog,
      useFog: material.fog,
      fogExp: fog instanceof THREE.FogExp2,

      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: _logarithmicDepthBuffer,

      skinning: material.skinning,
      maxBones: maxBones,
      useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: _this.maxMorphTargets,
      maxMorphNormals: _this.maxMorphNormals,

      maxDirLights: maxLightCount.directional,
      maxPointLights: maxLightCount.point,
      maxSpotLights: maxLightCount.spot,
      maxHemiLights: maxLightCount.hemi,

      maxShadows: maxShadows,
      shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
      shadowMapType: _this.shadowMapType,
      shadowMapDebug: _this.shadowMapDebug,
      shadowMapCascade: _this.shadowMapCascade,

      alphaTest: material.alphaTest,
      metal: material.metal,
      wrapAround: material.wrapAround,
      doubleSided: material.side === THREE.DoubleSide,
      flipSided: material.side === THREE.BackSide

    };

    // Generate code

    var chunks = [];

    if ( shaderID ) {

      chunks.push( shaderID );

    } else {

      chunks.push( material.fragmentShader );
      chunks.push( material.vertexShader );

    }

    if ( material.defines !== undefined ) {

      for ( var name in material.defines ) {

        chunks.push( name );
        chunks.push( material.defines[ name ] );

      }

    }

    for ( var name in parameters ) {

      chunks.push( name );
      chunks.push( parameters[ name ] );

    }

    var code = chunks.join();

    var program;

    // Check if code has been already compiled

    for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

      var programInfo = _programs[ p ];

      if ( programInfo.code === code ) {

        program = programInfo;
        program.usedTimes ++;

        break;

      }

    }

    if ( program === undefined ) {

      program = new THREE.WebGLProgram( _this, code, material, parameters );
      _programs.push( program );

      _this.info.memory.programs = _programs.length;

    }

    material.program = program;

    var attributes = program.attributes;

    if ( material.morphTargets ) {

      material.numSupportedMorphTargets = 0;

      var id, base = 'morphTarget';

      for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

        id = base + i;

        if ( attributes[ id ] >= 0 ) {

          material.numSupportedMorphTargets ++;

        }

      }

    }

    if ( material.morphNormals ) {

      material.numSupportedMorphNormals = 0;

      var id, base = 'morphNormal';

      for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

        id = base + i;

        if ( attributes[ id ] >= 0 ) {

          material.numSupportedMorphNormals ++;

        }

      }

    }

    material.uniformsList = [];

    for ( var u in material.__webglShader.uniforms ) {

      var location = material.program.uniforms[ u ];

      if ( location ) {
        material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
      }

    }

  }

  function setProgram( camera, lights, fog, material, object ) {

    _usedTextureUnits = 0;

    if ( material.needsUpdate ) {

      if ( material.program ) deallocateMaterial( material );

      initMaterial( material, lights, fog, object );
      material.needsUpdate = false;

    }

    if ( material.morphTargets ) {

      if ( ! object.__webglMorphTargetInfluences ) {

        object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

      }

    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;

    var program = material.program,
      p_uniforms = program.uniforms,
      m_uniforms = material.__webglShader.uniforms;

    if ( program.id !== _currentProgram ) {

      _gl.useProgram( program.program );
      _currentProgram = program.id;

      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;

    }

    if ( material.id !== _currentMaterialId ) {

      if ( _currentMaterialId === -1 ) refreshLights = true;
      _currentMaterialId = material.id;

      refreshMaterial = true;

    }

    if ( refreshProgram || camera !== _currentCamera ) {

      _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

      if ( _logarithmicDepthBuffer ) {

        _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

      }


      if ( camera !== _currentCamera ) _currentCamera = camera;

      // load material specific uniforms
      // (shader material also gets them for the sake of genericity)

      if ( material instanceof THREE.ShaderMaterial ||
         material instanceof THREE.MeshPhongMaterial ||
         material.envMap ) {

        if ( p_uniforms.cameraPosition !== null ) {

          _vector3.setFromMatrixPosition( camera.matrixWorld );
          _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

        }

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.ShaderMaterial ||
         material.skinning ) {

        if ( p_uniforms.viewMatrix !== null ) {

          _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

        }

      }

    }

    // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen

    if ( material.skinning ) {

      if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

      }

      if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

      }

      if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

        if ( p_uniforms.boneTexture !== null ) {

          var textureUnit = getTextureUnit();

          _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
          _this.setTexture( object.skeleton.boneTexture, textureUnit );

        }

        if ( p_uniforms.boneTextureWidth !== null ) {

          _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

        }

        if ( p_uniforms.boneTextureHeight !== null ) {

          _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

        }

      } else if ( object.skeleton && object.skeleton.boneMatrices ) {

        if ( p_uniforms.boneGlobalMatrices !== null ) {

          _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

        }

      }

    }

    if ( refreshMaterial ) {

      // refresh uniforms common to several materials

      if ( fog && material.fog ) {

        refreshUniformsFog( m_uniforms, fog );

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material.lights ) {

        if ( _lightsNeedUpdate ) {

          refreshLights = true;
          setupLights( lights );
          _lightsNeedUpdate = false;
        }

        if ( refreshLights ) {
          refreshUniformsLights( m_uniforms, _lights );
          markUniformsLightsNeedsUpdate( m_uniforms, true );
        } else {
          markUniformsLightsNeedsUpdate( m_uniforms, false );
        }

      }

      if ( material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsCommon( m_uniforms, material );

      }

      // refresh single material specific uniforms

      if ( material instanceof THREE.LineBasicMaterial ) {

        refreshUniformsLine( m_uniforms, material );

      } else if ( material instanceof THREE.LineDashedMaterial ) {

        refreshUniformsLine( m_uniforms, material );
        refreshUniformsDash( m_uniforms, material );

      } else if ( material instanceof THREE.PointCloudMaterial ) {

        refreshUniformsParticle( m_uniforms, material );

      } else if ( material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsPhong( m_uniforms, material );

      } else if ( material instanceof THREE.MeshLambertMaterial ) {

        refreshUniformsLambert( m_uniforms, material );

      } else if ( material instanceof THREE.MeshDepthMaterial ) {

        m_uniforms.mNear.value = camera.near;
        m_uniforms.mFar.value = camera.far;
        m_uniforms.opacity.value = material.opacity;

      } else if ( material instanceof THREE.MeshNormalMaterial ) {

        m_uniforms.opacity.value = material.opacity;

      }

      if ( object.receiveShadow && ! material._shadowPass ) {

        refreshUniformsShadow( m_uniforms, lights );

      }

      // load common uniforms

      loadUniformsGeneric( material.uniformsList );

    }

    loadUniformsMatrices( p_uniforms, object );

    if ( p_uniforms.modelMatrix !== null ) {

      _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

    }

    return program;

  }

  // Uniforms (refresh uniforms objects)

  function refreshUniformsCommon ( uniforms, material ) {

    uniforms.opacity.value = material.opacity;

    if ( _this.gammaInput ) {

      uniforms.diffuse.value.copyGammaToLinear( material.color );

    } else {

      uniforms.diffuse.value = material.color;

    }

    uniforms.map.value = material.map;
    uniforms.lightMap.value = material.lightMap;
    uniforms.specularMap.value = material.specularMap;
    uniforms.alphaMap.value = material.alphaMap;

    if ( material.bumpMap ) {

      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;

    }

    if ( material.normalMap ) {

      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy( material.normalScale );

    }

    // uv repeat and offset setting priorities
    //  1. color map
    //  2. specular map
    //  3. normal map
    //  4. bump map
    //  5. alpha map

    var uvScaleMap;

    if ( material.map ) {

      uvScaleMap = material.map;

    } else if ( material.specularMap ) {

      uvScaleMap = material.specularMap;

    } else if ( material.normalMap ) {

      uvScaleMap = material.normalMap;

    } else if ( material.bumpMap ) {

      uvScaleMap = material.bumpMap;

    } else if ( material.alphaMap ) {

      uvScaleMap = material.alphaMap;

    }

    if ( uvScaleMap !== undefined ) {

      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

    if ( _this.gammaInput ) {

      //uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
      uniforms.reflectivity.value = material.reflectivity;

    } else {

      uniforms.reflectivity.value = material.reflectivity;

    }

    uniforms.refractionRatio.value = material.refractionRatio;
    uniforms.combine.value = material.combine;
    uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

  }

  function refreshUniformsLine ( uniforms, material ) {

    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;

  }

  function refreshUniformsDash ( uniforms, material ) {

    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;

  }

  function refreshUniformsParticle ( uniforms, material ) {

    uniforms.psColor.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size;
    uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

    uniforms.map.value = material.map;

  }

  function refreshUniformsFog ( uniforms, fog ) {

    uniforms.fogColor.value = fog.color;

    if ( fog instanceof THREE.Fog ) {

      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;

    } else if ( fog instanceof THREE.FogExp2 ) {

      uniforms.fogDensity.value = fog.density;

    }

  }

  function refreshUniformsPhong ( uniforms, material ) {

    uniforms.shininess.value = material.shininess;

    if ( _this.gammaInput ) {

      uniforms.ambient.value.copyGammaToLinear( material.ambient );
      uniforms.emissive.value.copyGammaToLinear( material.emissive );
      uniforms.specular.value.copyGammaToLinear( material.specular );

    } else {

      uniforms.ambient.value = material.ambient;
      uniforms.emissive.value = material.emissive;
      uniforms.specular.value = material.specular;

    }

    if ( material.wrapAround ) {

      uniforms.wrapRGB.value.copy( material.wrapRGB );

    }

  }

  function refreshUniformsLambert ( uniforms, material ) {

    if ( _this.gammaInput ) {

      uniforms.ambient.value.copyGammaToLinear( material.ambient );
      uniforms.emissive.value.copyGammaToLinear( material.emissive );

    } else {

      uniforms.ambient.value = material.ambient;
      uniforms.emissive.value = material.emissive;

    }

    if ( material.wrapAround ) {

      uniforms.wrapRGB.value.copy( material.wrapRGB );

    }

  }

  function refreshUniformsLights ( uniforms, lights ) {

    uniforms.ambientLightColor.value = lights.ambient;

    uniforms.directionalLightColor.value = lights.directional.colors;
    uniforms.directionalLightDirection.value = lights.directional.positions;

    uniforms.pointLightColor.value = lights.point.colors;
    uniforms.pointLightPosition.value = lights.point.positions;
    uniforms.pointLightDistance.value = lights.point.distances;

    uniforms.spotLightColor.value = lights.spot.colors;
    uniforms.spotLightPosition.value = lights.spot.positions;
    uniforms.spotLightDistance.value = lights.spot.distances;
    uniforms.spotLightDirection.value = lights.spot.directions;
    uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
    uniforms.spotLightExponent.value = lights.spot.exponents;

    uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
    uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
    uniforms.hemisphereLightDirection.value = lights.hemi.positions;

  }

  // If uniforms are marked as clean, they don't need to be loaded to the GPU.

  function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {

    uniforms.ambientLightColor.needsUpdate = boolean;

    uniforms.directionalLightColor.needsUpdate = boolean;
    uniforms.directionalLightDirection.needsUpdate = boolean;

    uniforms.pointLightColor.needsUpdate = boolean;
    uniforms.pointLightPosition.needsUpdate = boolean;
    uniforms.pointLightDistance.needsUpdate = boolean;

    uniforms.spotLightColor.needsUpdate = boolean;
    uniforms.spotLightPosition.needsUpdate = boolean;
    uniforms.spotLightDistance.needsUpdate = boolean;
    uniforms.spotLightDirection.needsUpdate = boolean;
    uniforms.spotLightAngleCos.needsUpdate = boolean;
    uniforms.spotLightExponent.needsUpdate = boolean;

    uniforms.hemisphereLightSkyColor.needsUpdate = boolean;
    uniforms.hemisphereLightGroundColor.needsUpdate = boolean;
    uniforms.hemisphereLightDirection.needsUpdate = boolean;

  }

  function refreshUniformsShadow ( uniforms, lights ) {

    if ( uniforms.shadowMatrix ) {

      var j = 0;

      for ( var i = 0, il = lights.length; i < il; i ++ ) {

        var light = lights[ i ];

        if ( ! light.castShadow ) continue;

        if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

          uniforms.shadowMap.value[ j ] = light.shadowMap;
          uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

          uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

          uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
          uniforms.shadowBias.value[ j ] = light.shadowBias;

          j ++;

        }

      }

    }

  }

  // Uniforms (load to GPU)

  function loadUniformsMatrices ( uniforms, object ) {

    _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

    if ( uniforms.normalMatrix ) {

      _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

    }

  }

  function getTextureUnit() {

    var textureUnit = _usedTextureUnits;

    if ( textureUnit >= _maxTextures ) {

      console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

    }

    _usedTextureUnits += 1;

    return textureUnit;

  }

  function loadUniformsGeneric ( uniforms ) {

    var texture, textureUnit, offset;

    for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

      var uniform = uniforms[ j ][ 0 ];

      // needsUpdate property is not added to all uniforms.
      if ( uniform.needsUpdate === false ) continue;

      var type = uniform.type;
      var value = uniform.value;
      var location = uniforms[ j ][ 1 ];

      switch ( type ) {

        case '1i':
          _gl.uniform1i( location, value );
          break;

        case '1f':
          _gl.uniform1f( location, value );
          break;

        case '2f':
          _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
          break;

        case '3f':
          _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
          break;

        case '4f':
          _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
          break;

        case '1iv':
          _gl.uniform1iv( location, value );
          break;

        case '3iv':
          _gl.uniform3iv( location, value );
          break;

        case '1fv':
          _gl.uniform1fv( location, value );
          break;

        case '2fv':
          _gl.uniform2fv( location, value );
          break;

        case '3fv':
          _gl.uniform3fv( location, value );
          break;

        case '4fv':
          _gl.uniform4fv( location, value );
          break;

        case 'Matrix3fv':
          _gl.uniformMatrix3fv( location, false, value );
          break;

        case 'Matrix4fv':
          _gl.uniformMatrix4fv( location, false, value );
          break;

        //

        case 'i':

          // single integer
          _gl.uniform1i( location, value );

          break;

        case 'f':

          // single float
          _gl.uniform1f( location, value );

          break;

        case 'v2':

          // single THREE.Vector2
          _gl.uniform2f( location, value.x, value.y );

          break;

        case 'v3':

          // single THREE.Vector3
          _gl.uniform3f( location, value.x, value.y, value.z );

          break;

        case 'v4':

          // single THREE.Vector4
          _gl.uniform4f( location, value.x, value.y, value.z, value.w );

          break;

        case 'c':

          // single THREE.Color
          _gl.uniform3f( location, value.r, value.g, value.b );

          break;

        case 'iv1':

          // flat array of integers (JS or typed array)
          _gl.uniform1iv( location, value );

          break;

        case 'iv':

          // flat array of integers with 3 x N size (JS or typed array)
          _gl.uniform3iv( location, value );

          break;

        case 'fv1':

          // flat array of floats (JS or typed array)
          _gl.uniform1fv( location, value );

          break;

        case 'fv':

          // flat array of floats with 3 x N size (JS or typed array)
          _gl.uniform3fv( location, value );

          break;

        case 'v2v':

          // array of THREE.Vector2

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 2 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 2;

            uniform._array[ offset ]   = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;

          }

          _gl.uniform2fv( location, uniform._array );

          break;

        case 'v3v':

          // array of THREE.Vector3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 3 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 3;

            uniform._array[ offset ]   = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;
            uniform._array[ offset + 2 ] = value[ i ].z;

          }

          _gl.uniform3fv( location, uniform._array );

          break;

        case 'v4v':

          // array of THREE.Vector4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 4 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 4;

            uniform._array[ offset ]   = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;
            uniform._array[ offset + 2 ] = value[ i ].z;
            uniform._array[ offset + 3 ] = value[ i ].w;

          }

          _gl.uniform4fv( location, uniform._array );

          break;

        case 'm3':

          // single THREE.Matrix3
          _gl.uniformMatrix3fv( location, false, value.elements );

          break;

        case 'm3v':

          // array of THREE.Matrix3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 9 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

          }

          _gl.uniformMatrix3fv( location, false, uniform._array );

          break;

        case 'm4':

          // single THREE.Matrix4
          _gl.uniformMatrix4fv( location, false, value.elements );

          break;

        case 'm4v':

          // array of THREE.Matrix4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 16 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

          }

          _gl.uniformMatrix4fv( location, false, uniform._array );

          break;

        case 't':

          // single THREE.Texture (2d or cube)

          texture = value;
          textureUnit = getTextureUnit();

          _gl.uniform1i( location, textureUnit );

          if ( ! texture ) continue;

          if ( texture instanceof THREE.CubeTexture ||
             ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

            setCubeTexture( texture, textureUnit );

          } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

            setCubeTextureDynamic( texture, textureUnit );

          } else {

            _this.setTexture( texture, textureUnit );

          }

          break;

        case 'tv':

          // array of THREE.Texture (2d)

          if ( uniform._array === undefined ) {

            uniform._array = [];

          }

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            uniform._array[ i ] = getTextureUnit();

          }

          _gl.uniform1iv( location, uniform._array );

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            texture = uniform.value[ i ];
            textureUnit = uniform._array[ i ];

            if ( ! texture ) continue;

            _this.setTexture( texture, textureUnit );

          }

          break;

        default:

          console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

      }

    }

  }

  function setupMatrices ( object, camera ) {

    object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
    object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

  }

  //

  function setColorGamma( array, offset, color, intensitySq ) {

    array[ offset ]     = color.r * color.r * intensitySq;
    array[ offset + 1 ] = color.g * color.g * intensitySq;
    array[ offset + 2 ] = color.b * color.b * intensitySq;

  }

  function setColorLinear( array, offset, color, intensity ) {

    array[ offset ]     = color.r * intensity;
    array[ offset + 1 ] = color.g * intensity;
    array[ offset + 2 ] = color.b * intensity;

  }

  function setupLights ( lights ) {

    var l, ll, light, n,
    r = 0, g = 0, b = 0,
    color, skyColor, groundColor,
    intensity,  intensitySq,
    position,
    distance,

    zlights = _lights,

    dirColors = zlights.directional.colors,
    dirPositions = zlights.directional.positions,

    pointColors = zlights.point.colors,
    pointPositions = zlights.point.positions,
    pointDistances = zlights.point.distances,

    spotColors = zlights.spot.colors,
    spotPositions = zlights.spot.positions,
    spotDistances = zlights.spot.distances,
    spotDirections = zlights.spot.directions,
    spotAnglesCos = zlights.spot.anglesCos,
    spotExponents = zlights.spot.exponents,

    hemiSkyColors = zlights.hemi.skyColors,
    hemiGroundColors = zlights.hemi.groundColors,
    hemiPositions = zlights.hemi.positions,

    dirLength = 0,
    pointLength = 0,
    spotLength = 0,
    hemiLength = 0,

    dirCount = 0,
    pointCount = 0,
    spotCount = 0,
    hemiCount = 0,

    dirOffset = 0,
    pointOffset = 0,
    spotOffset = 0,
    hemiOffset = 0;

    for ( l = 0, ll = lights.length; l < ll; l ++ ) {

      light = lights[ l ];

      if ( light.onlyShadow ) continue;

      color = light.color;
      intensity = light.intensity;
      distance = light.distance;

      if ( light instanceof THREE.AmbientLight ) {

        if ( ! light.visible ) continue;

        if ( _this.gammaInput ) {

          r += color.r * color.r;
          g += color.g * color.g;
          b += color.b * color.b;

        } else {

          r += color.r;
          g += color.g;
          b += color.b;

        }

      } else if ( light instanceof THREE.DirectionalLight ) {

        dirCount += 1;

        if ( ! light.visible ) continue;

        _direction.setFromMatrixPosition( light.matrixWorld );
        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        _direction.sub( _vector3 );
        _direction.normalize();

        dirOffset = dirLength * 3;

        dirPositions[ dirOffset ]     = _direction.x;
        dirPositions[ dirOffset + 1 ] = _direction.y;
        dirPositions[ dirOffset + 2 ] = _direction.z;

        if ( _this.gammaInput ) {

          setColorGamma( dirColors, dirOffset, color, intensity * intensity );

        } else {

          setColorLinear( dirColors, dirOffset, color, intensity );

        }

        dirLength += 1;

      } else if ( light instanceof THREE.PointLight ) {

        pointCount += 1;

        if ( ! light.visible ) continue;

        pointOffset = pointLength * 3;

        if ( _this.gammaInput ) {

          setColorGamma( pointColors, pointOffset, color, intensity * intensity );

        } else {

          setColorLinear( pointColors, pointOffset, color, intensity );

        }

        _vector3.setFromMatrixPosition( light.matrixWorld );

        pointPositions[ pointOffset ]     = _vector3.x;
        pointPositions[ pointOffset + 1 ] = _vector3.y;
        pointPositions[ pointOffset + 2 ] = _vector3.z;

        pointDistances[ pointLength ] = distance;

        pointLength += 1;

      } else if ( light instanceof THREE.SpotLight ) {

        spotCount += 1;

        if ( ! light.visible ) continue;

        spotOffset = spotLength * 3;

        if ( _this.gammaInput ) {

          setColorGamma( spotColors, spotOffset, color, intensity * intensity );

        } else {

          setColorLinear( spotColors, spotOffset, color, intensity );

        }

        _direction.setFromMatrixPosition( light.matrixWorld );

        spotPositions[ spotOffset ]     = _direction.x;
        spotPositions[ spotOffset + 1 ] = _direction.y;
        spotPositions[ spotOffset + 2 ] = _direction.z;

        spotDistances[ spotLength ] = distance;

        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        _direction.sub( _vector3 );
        _direction.normalize();

        spotDirections[ spotOffset ]     = _direction.x;
        spotDirections[ spotOffset + 1 ] = _direction.y;
        spotDirections[ spotOffset + 2 ] = _direction.z;

        spotAnglesCos[ spotLength ] = Math.cos( light.angle );
        spotExponents[ spotLength ] = light.exponent;

        spotLength += 1;

      } else if ( light instanceof THREE.HemisphereLight ) {

        hemiCount += 1;

        if ( ! light.visible ) continue;

        _direction.setFromMatrixPosition( light.matrixWorld );
        _direction.normalize();

        hemiOffset = hemiLength * 3;

        hemiPositions[ hemiOffset ]     = _direction.x;
        hemiPositions[ hemiOffset + 1 ] = _direction.y;
        hemiPositions[ hemiOffset + 2 ] = _direction.z;

        skyColor = light.color;
        groundColor = light.groundColor;

        if ( _this.gammaInput ) {

          intensitySq = intensity * intensity;

          setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
          setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

        } else {

          setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
          setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

        }

        hemiLength += 1;

      }

    }

    // null eventual remains from removed lights
    // (this is to avoid if in shader)

    for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
    for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
    for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
    for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
    for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

    zlights.directional.length = dirLength;
    zlights.point.length = pointLength;
    zlights.spot.length = spotLength;
    zlights.hemi.length = hemiLength;

    zlights.ambient[ 0 ] = r;
    zlights.ambient[ 1 ] = g;
    zlights.ambient[ 2 ] = b;

  }

  // GL state setting

  this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    if ( cullFace === THREE.CullFaceNone ) {

      _gl.disable( _gl.CULL_FACE );

    } else {

      if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

        _gl.frontFace( _gl.CW );

      } else {

        _gl.frontFace( _gl.CCW );

      }

      if ( cullFace === THREE.CullFaceBack ) {

        _gl.cullFace( _gl.BACK );

      } else if ( cullFace === THREE.CullFaceFront ) {

        _gl.cullFace( _gl.FRONT );

      } else {

        _gl.cullFace( _gl.FRONT_AND_BACK );

      }

      _gl.enable( _gl.CULL_FACE );

    }

  };

  this.setMaterialFaces = function ( material ) {

    var doubleSided = material.side === THREE.DoubleSide;
    var flipSided = material.side === THREE.BackSide;

    if ( _oldDoubleSided !== doubleSided ) {

      if ( doubleSided ) {

        _gl.disable( _gl.CULL_FACE );

      } else {

        _gl.enable( _gl.CULL_FACE );

      }

      _oldDoubleSided = doubleSided;

    }

    if ( _oldFlipSided !== flipSided ) {

      if ( flipSided ) {

        _gl.frontFace( _gl.CW );

      } else {

        _gl.frontFace( _gl.CCW );

      }

      _oldFlipSided = flipSided;

    }

  };

  this.setDepthTest = function ( depthTest ) {

    if ( _oldDepthTest !== depthTest ) {

      if ( depthTest ) {

        _gl.enable( _gl.DEPTH_TEST );

      } else {

        _gl.disable( _gl.DEPTH_TEST );

      }

      _oldDepthTest = depthTest;

    }

  };

  this.setDepthWrite = function ( depthWrite ) {

    if ( _oldDepthWrite !== depthWrite ) {

      _gl.depthMask( depthWrite );
      _oldDepthWrite = depthWrite;

    }

  };

  function setLineWidth ( width ) {

    if ( width !== _oldLineWidth ) {

      _gl.lineWidth( width );

      _oldLineWidth = width;

    }

  }

  function setPolygonOffset ( polygonoffset, factor, units ) {

    if ( _oldPolygonOffset !== polygonoffset ) {

      if ( polygonoffset ) {

        _gl.enable( _gl.POLYGON_OFFSET_FILL );

      } else {

        _gl.disable( _gl.POLYGON_OFFSET_FILL );

      }

      _oldPolygonOffset = polygonoffset;

    }

    if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

      _gl.polygonOffset( factor, units );

      _oldPolygonOffsetFactor = factor;
      _oldPolygonOffsetUnits = units;

    }

  }

  this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

    if ( blending !== _oldBlending ) {

      if ( blending === THREE.NoBlending ) {

        _gl.disable( _gl.BLEND );

      } else if ( blending === THREE.AdditiveBlending ) {

        _gl.enable( _gl.BLEND );
        _gl.blendEquation( _gl.FUNC_ADD );
        _gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

      } else if ( blending === THREE.SubtractiveBlending ) {

        // TODO: Find blendFuncSeparate() combination
        _gl.enable( _gl.BLEND );
        _gl.blendEquation( _gl.FUNC_ADD );
        _gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

      } else if ( blending === THREE.MultiplyBlending ) {

        // TODO: Find blendFuncSeparate() combination
        _gl.enable( _gl.BLEND );
        _gl.blendEquation( _gl.FUNC_ADD );
        _gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

      } else if ( blending === THREE.CustomBlending ) {

        _gl.enable( _gl.BLEND );

      } else {

        _gl.enable( _gl.BLEND );
        _gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
        _gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

      }

      _oldBlending = blending;

    }

    if ( blending === THREE.CustomBlending ) {

      if ( blendEquation !== _oldBlendEquation ) {

        _gl.blendEquation( paramThreeToGL( blendEquation ) );

        _oldBlendEquation = blendEquation;

      }

      if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

        _gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

        _oldBlendSrc = blendSrc;
        _oldBlendDst = blendDst;

      }

    } else {

      _oldBlendEquation = null;
      _oldBlendSrc = null;
      _oldBlendDst = null;

    }

  };

  // Textures

  function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

    var extension;

    if ( isImagePowerOfTwo ) {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    } else {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

    }

    extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    if ( extension && texture.type !== THREE.FloatType ) {

      if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

        _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
        texture.__oldAnisotropy = texture.anisotropy;

      }

    }

  }

  this.uploadTexture = function ( texture ) {

    if ( texture.__webglInit === undefined ) {

      texture.__webglInit = true;

      texture.addEventListener( 'dispose', onTextureDispose );

      texture.__webglTexture = _gl.createTexture();

      _this.info.memory.textures ++;

    }

    _gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

    _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    texture.image = clampToMaxSize( texture.image, _maxTextureSize );

    var image = texture.image,
    isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
    glFormat = paramThreeToGL( texture.format ),
    glType = paramThreeToGL( texture.type );

    setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

    var mipmap, mipmaps = texture.mipmaps;

    if ( texture instanceof THREE.DataTexture ) {

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          _gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

        texture.generateMipmaps = false;

      } else {

        _gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

      }

    } else if ( texture instanceof THREE.CompressedTexture ) {

      for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

        mipmap = mipmaps[ i ];

        if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

          if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

            _gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

          } else {

            console.warn( "Attempt to load unsupported compressed texture format" );

          }

        } else {

          _gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

      }

    } else { // regular Texture (image, video, canvas)

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          _gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

        }

        texture.generateMipmaps = false;

      } else {

        _gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

      }

    }

    if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

    texture.needsUpdate = false;

    if ( texture.onUpdate ) texture.onUpdate();

  };

  this.setTexture = function ( texture, slot ) {

    _gl.activeTexture( _gl.TEXTURE0 + slot );

    if ( texture.needsUpdate ) {

      _this.uploadTexture( texture );

    } else {

      _gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

    }

  };

  function clampToMaxSize ( image, maxSize ) {

    if ( image.width > maxSize || image.height > maxSize ) {

      // Warning: Scaling through the canvas will only work with images that use
      // premultiplied alpha.

      var scale = maxSize / Math.max( image.width, image.height );

      var canvas = document.createElement( 'canvas' );
      canvas.width = Math.floor( image.width * scale );
      canvas.height = Math.floor( image.height * scale );

      var context = canvas.getContext( '2d' );
      context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

      console.log( 'THREE.WebGLRenderer:', image, 'is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height + '.' );

      return canvas;

    }

    return image;

  }

  function setCubeTexture ( texture, slot ) {

    if ( texture.image.length === 6 ) {

      if ( texture.needsUpdate ) {

        if ( ! texture.image.__webglTextureCube ) {

          texture.addEventListener( 'dispose', onTextureDispose );

          texture.image.__webglTextureCube = _gl.createTexture();

          _this.info.memory.textures ++;

        }

        _gl.activeTexture( _gl.TEXTURE0 + slot );
        _gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

        var isCompressed = texture instanceof THREE.CompressedTexture;
        var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

        var cubeImage = [];

        for ( var i = 0; i < 6; i ++ ) {

          if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

            cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

          } else {

            cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

          }

        }

        var image = cubeImage[ 0 ],
        isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
        glFormat = paramThreeToGL( texture.format ),
        glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          if ( ! isCompressed ) {

            if ( isDataTexture ) {

              _gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

            } else {

              _gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

            }

          } else {

            var mipmap, mipmaps = cubeImage[ i ].mipmaps;

            for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

              mipmap = mipmaps[ j ];

              if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                  _gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                } else {

                  console.warn( "Attempt to load unsupported compressed texture format" );

                }

              } else {

                _gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

              }

            }

          }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) {

          _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

        }

        texture.needsUpdate = false;

        if ( texture.onUpdate ) texture.onUpdate();

      } else {

        _gl.activeTexture( _gl.TEXTURE0 + slot );
        _gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

      }

    }

  }

  function setCubeTextureDynamic ( texture, slot ) {

    _gl.activeTexture( _gl.TEXTURE0 + slot );
    _gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

  }

  // Render targets

  function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

    _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

  }

  function setupRenderBuffer ( renderbuffer, renderTarget  ) {

    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    /* For some reason this is not working. Defaulting to RGBA4.
    } else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
    */
    } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    } else {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    }

  }

  this.setRenderTarget = function ( renderTarget ) {

    var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

    if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

      if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
      if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

      renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

      renderTarget.__webglTexture = _gl.createTexture();

      _this.info.memory.textures ++;

      // Setup texture, create render and frame buffers

      var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
        glFormat = paramThreeToGL( renderTarget.format ),
        glType = paramThreeToGL( renderTarget.type );

      if ( isCube ) {

        renderTarget.__webglFramebuffer = [];
        renderTarget.__webglRenderbuffer = [];

        _gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
        setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
          renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

          _gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

          setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
          setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

        }

        if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

      } else {

        renderTarget.__webglFramebuffer = _gl.createFramebuffer();

        if ( renderTarget.shareDepthFrom ) {

          renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

        } else {

          renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

        }

        _gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
        setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

        _gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

        setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

        if ( renderTarget.shareDepthFrom ) {

          if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

          } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

          }

        } else {

          setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

        }

        if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

      }

      // Release everything

      if ( isCube ) {

        _gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

      } else {

        _gl.bindTexture( _gl.TEXTURE_2D, null );

      }

      _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
      _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    }

    var framebuffer, width, height, vx, vy;

    if ( renderTarget ) {

      if ( isCube ) {

        framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

      } else {

        framebuffer = renderTarget.__webglFramebuffer;

      }

      width = renderTarget.width;
      height = renderTarget.height;

      vx = 0;
      vy = 0;

    } else {

      framebuffer = null;

      width = _viewportWidth;
      height = _viewportHeight;

      vx = _viewportX;
      vy = _viewportY;

    }

    if ( framebuffer !== _currentFramebuffer ) {

      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
      _gl.viewport( vx, vy, width, height );

      _currentFramebuffer = framebuffer;

    }

    _currentWidth = width;
    _currentHeight = height;

  };

  function updateRenderTargetMipmap ( renderTarget ) {

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      _gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
      _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
      _gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    } else {

      _gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
      _gl.generateMipmap( _gl.TEXTURE_2D );
      _gl.bindTexture( _gl.TEXTURE_2D, null );

    }

  }

  // Fallback filters for non-power-of-2 textures

  function filterFallback ( f ) {

    if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

      return _gl.NEAREST;

    }

    return _gl.LINEAR;

  }

  // Map three.js constants to WebGL constants

  function paramThreeToGL ( p ) {

    var extension;

    if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
    if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    if ( p === THREE.NearestFilter ) return _gl.NEAREST;
    if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    if ( p === THREE.LinearFilter ) return _gl.LINEAR;
    if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    if ( p === THREE.ByteType ) return _gl.BYTE;
    if ( p === THREE.ShortType ) return _gl.SHORT;
    if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    if ( p === THREE.IntType ) return _gl.INT;
    if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
    if ( p === THREE.FloatType ) return _gl.FLOAT;

    if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
    if ( p === THREE.RGBFormat ) return _gl.RGB;
    if ( p === THREE.RGBAFormat ) return _gl.RGBA;
    if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
    if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

    if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
    if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
    if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    if ( p === THREE.ZeroFactor ) return _gl.ZERO;
    if ( p === THREE.OneFactor ) return _gl.ONE;
    if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
    if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
    if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
    if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
    if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    }

    extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    }

    extension = extensions.get( 'EXT_blend_minmax' );

    if ( extension !== null ) {

      if ( p === THREE.MinEquation ) return extension.MIN_EXT;
      if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

    }

    return 0;

  }

  // Allocations

  function allocateBones ( object ) {

    if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

      return 1024;

    } else {

      // default for when object is not specified
      // ( for example when prebuilding shader
      //   to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)

      var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
      var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

      var maxBones = nVertexMatrices;

      if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

        maxBones = Math.min( object.skeleton.bones.length, maxBones );

        if ( maxBones < object.skeleton.bones.length ) {

          console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

        }

      }

      return maxBones;

    }

  }

  function allocateLights( lights ) {

    var dirLights = 0;
    var pointLights = 0;
    var spotLights = 0;
    var hemiLights = 0;

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];

      if ( light.onlyShadow || light.visible === false ) continue;

      if ( light instanceof THREE.DirectionalLight ) dirLights ++;
      if ( light instanceof THREE.PointLight ) pointLights ++;
      if ( light instanceof THREE.SpotLight ) spotLights ++;
      if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

    }

    return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

  }

  function allocateShadows( lights ) {

    var maxShadows = 0;

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];

      if ( ! light.castShadow ) continue;

      if ( light instanceof THREE.SpotLight ) maxShadows ++;
      if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

    }

    return maxShadows;

  }

  // DEPRECATED
  
  this.initMaterial = function () {

    console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

  };

  this.addPrePlugin = function () {

    console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

  };

  this.addPostPlugin = function () {

    console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

  };

  this.updateShadowMap = function () {

    console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

  };

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

  this.width = width;
  this.height = height;

  options = options || {};

  this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
  this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
  this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

  this.generateMipmaps = true;

  this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype = {

  constructor: THREE.WebGLRenderTarget,

  setSize: function ( width, height ) {

    this.width = width;
    this.height = height;

  },

  clone: function () {

    var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

    tmp.wrapS = this.wrapS;
    tmp.wrapT = this.wrapT;

    tmp.magFilter = this.magFilter;
    tmp.minFilter = this.minFilter;

    tmp.anisotropy = this.anisotropy;

    tmp.offset.copy( this.offset );
    tmp.repeat.copy( this.repeat );

    tmp.format = this.format;
    tmp.type = this.type;

    tmp.depthBuffer = this.depthBuffer;
    tmp.stencilBuffer = this.stencilBuffer;

    tmp.generateMipmaps = this.generateMipmaps;

    tmp.shareDepthFrom = this.shareDepthFrom;

    return tmp;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

  THREE.WebGLRenderTarget.call( this, width, height, options );

  this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/webgl/WebGLExtensions.js

THREE.WebGLExtensions = function ( gl ) {

  var extensions = {};

  this.get = function ( name ) {

    if ( extensions[ name ] !== undefined ) {

      return extensions[ name ];

    }

    var extension;

    switch ( name ) {
    
      case 'OES_texture_float':
        extension = gl.getExtension( 'OES_texture_float' );
        break;

      case 'OES_texture_float_linear':
        extension = gl.getExtension( 'OES_texture_float_linear' );
        break;

      case 'OES_standard_derivatives':
        extension = gl.getExtension( 'OES_standard_derivatives' );
        break;

      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
        break;

      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
        break;

      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
        break;

      case 'OES_element_index_uint':
        extension = gl.getExtension( 'OES_element_index_uint' );
        break;

      case 'EXT_blend_minmax':
        extension = gl.getExtension( 'EXT_blend_minmax' );
        break;

      case 'EXT_frag_depth':
        extension = gl.getExtension( 'EXT_frag_depth' );
        break;

    }

    if ( extension === null ) {

      console.log( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    }

    extensions[ name ] = extension;

    return extension;

  };

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

  var programIdCount = 0;

  var generateDefines = function ( defines ) {

    var value, chunk, chunks = [];

    for ( var d in defines ) {

      value = defines[ d ];
      if ( value === false ) continue;

      chunk = "#define " + d + " " + value;
      chunks.push( chunk );

    }

    return chunks.join( "\n" );

  };

  var cacheUniformLocations = function ( gl, program, identifiers ) {

    var uniforms = {};

    for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

      var id = identifiers[ i ];
      uniforms[ id ] = gl.getUniformLocation( program, id );

    }

    return uniforms;

  };

  var cacheAttributeLocations = function ( gl, program, identifiers ) {

    var attributes = {};

    for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

      var id = identifiers[ i ];
      attributes[ id ] = gl.getAttribLocation( program, id );

    }

    return attributes;

  };

  return function ( renderer, code, material, parameters ) {

    var _this = renderer;
    var _gl = _this.context;

    var defines = material.defines;
    var uniforms = material.__webglShader.uniforms;
    var attributes = material.attributes;

    var vertexShader = material.__webglShader.vertexShader;
    var fragmentShader = material.__webglShader.fragmentShader;

    var index0AttributeName = material.index0AttributeName;

    if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

      // programs with morphTargets displace position out of attribute 0

      index0AttributeName = 'position';

    }

    var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

    if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

    } else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

    }

    // console.log( "building new program " );

    //

    var customDefines = generateDefines( defines );

    //

    var program = _gl.createProgram();

    var prefix_vertex, prefix_fragment;

    if ( material instanceof THREE.RawShaderMaterial ) {

      prefix_vertex = '';
      prefix_fragment = '';

    } else {

      prefix_vertex = [

        "precision " + parameters.precision + " float;",
        "precision " + parameters.precision + " int;",

        customDefines,

        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

        _this.gammaInput ? "#define GAMMA_INPUT" : "",
        _this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

        "#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
        "#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
        "#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
        "#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

        "#define MAX_SHADOWS " + parameters.maxShadows,

        "#define MAX_BONES " + parameters.maxBones,

        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",

        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
        parameters.wrapAround ? "#define WRAP_AROUND" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",

        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
        parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        //_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",


        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",

        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "attribute vec2 uv2;",

        "#ifdef USE_COLOR",

        " attribute vec3 color;",

        "#endif",

        "#ifdef USE_MORPHTARGETS",

        " attribute vec3 morphTarget0;",
        " attribute vec3 morphTarget1;",
        " attribute vec3 morphTarget2;",
        " attribute vec3 morphTarget3;",

        " #ifdef USE_MORPHNORMALS",

        "   attribute vec3 morphNormal0;",
        "   attribute vec3 morphNormal1;",
        "   attribute vec3 morphNormal2;",
        "   attribute vec3 morphNormal3;",

        " #else",

        "   attribute vec3 morphTarget4;",
        "   attribute vec3 morphTarget5;",
        "   attribute vec3 morphTarget6;",
        "   attribute vec3 morphTarget7;",

        " #endif",

        "#endif",

        "#ifdef USE_SKINNING",

        " attribute vec4 skinIndex;",
        " attribute vec4 skinWeight;",

        "#endif",

        ""

      ].join( '\n' );

      prefix_fragment = [

        "precision " + parameters.precision + " float;",
        "precision " + parameters.precision + " int;",

        ( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

        customDefines,

        "#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
        "#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
        "#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
        "#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

        "#define MAX_SHADOWS " + parameters.maxShadows,

        parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

        _this.gammaInput ? "#define GAMMA_INPUT" : "",
        _this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

        ( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
        ( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",

        parameters.metal ? "#define METAL" : "",
        parameters.wrapAround ? "#define WRAP_AROUND" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",

        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
        parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        //_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",

        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        ""

      ].join( '\n' );

    }

    var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
    var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

    _gl.attachShader( program, glVertexShader );
    _gl.attachShader( program, glFragmentShader );

    if ( index0AttributeName !== undefined ) {

      // Force a particular attribute to index 0.
      // because potentially expensive emulation is done by browser if attribute 0 is disabled.
      // And, color, for example is often automatically bound to index 0 so disabling it

      _gl.bindAttribLocation( program, 0, index0AttributeName );

    }

    _gl.linkProgram( program );

    if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

      console.error( 'THREE.WebGLProgram: Could not initialise shader.' );
      console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
      console.error( 'gl.getError()', _gl.getError() );

    }

    if ( _gl.getProgramInfoLog( program ) !== '' ) {

      console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

    }

    // clean up

    _gl.deleteShader( glVertexShader );
    _gl.deleteShader( glFragmentShader );

    // cache uniform locations

    var identifiers = [

      'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition', 'morphTargetInfluences', 'bindMatrix', 'bindMatrixInverse'

    ];

    if ( parameters.useVertexTexture ) {

      identifiers.push( 'boneTexture' );
      identifiers.push( 'boneTextureWidth' );
      identifiers.push( 'boneTextureHeight' );

    } else {

      identifiers.push( 'boneGlobalMatrices' );

    }

    if ( parameters.logarithmicDepthBuffer ) {

      identifiers.push('logDepthBufFC');

    }


    for ( var u in uniforms ) {

      identifiers.push( u );

    }

    this.uniforms = cacheUniformLocations( _gl, program, identifiers );

    // cache attributes locations

    identifiers = [

      "position", "normal", "uv", "uv2", "tangent", "color",
      "skinIndex", "skinWeight", "lineDistance"

    ];

    for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {

      identifiers.push( "morphTarget" + i );

    }

    for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {

      identifiers.push( "morphNormal" + i );

    }

    for ( var a in attributes ) {

      identifiers.push( a );

    }

    this.attributes = cacheAttributeLocations( _gl, program, identifiers );
    this.attributesKeys = Object.keys( this.attributes );

    //

    this.id = programIdCount ++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;

    return this;

  };

} )();

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

  var addLineNumbers = function ( string ) {

    var lines = string.split( '\n' );

    for ( var i = 0; i < lines.length; i ++ ) {

      lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    }

    return lines.join( '\n' );

  };

  return function ( gl, type, string ) {

    var shader = gl.createShader( type ); 

    gl.shaderSource( shader, string );
    gl.compileShader( shader );

    if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

      console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    }

    if ( gl.getShaderInfoLog( shader ) !== '' ) {

      console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ) );
      console.warn( addLineNumbers( string ) );

    }

    // --enable-privileged-webgl-extension
    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    return shader;

  };

} )();

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

  var gl = renderer.context;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;
  var hasVertexTexture;

  var tempTexture, occlusionTexture;

  var init = function () {

    var vertices = new Float32Array( [
      -1, -1,  0, 0,
       1, -1,  1, 0,
       1,  1,  1, 1,
      -1,  1,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    // buffers

    vertexBuffer     = gl.createBuffer();
    elementBuffer    = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    // textures

    tempTexture      = gl.createTexture();
    occlusionTexture = gl.createTexture();

    gl.bindTexture( gl.TEXTURE_2D, tempTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

    var shader;

    if ( hasVertexTexture ) {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "uniform sampler2D occlusionMap;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if( renderType == 2 ) {",

              "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

              "vVisibility =        visibility.r / 9.0;",
              "vVisibility *= 1.0 - visibility.g / 9.0;",
              "vVisibility *=       visibility.b / 9.0;",
              "vVisibility *= 1.0 - visibility.a / 9.0;",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            // pink square

            "if( renderType == 0 ) {",

              "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

            // restore

            "} else if( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * vVisibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    } else {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if( renderType == 2 ) {",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "precision mediump float;",

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform sampler2D occlusionMap;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",

          "void main() {",

            // pink square

            "if( renderType == 0 ) {",

              "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

            // restore

            "} else if( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
              "visibility = ( 1.0 - visibility / 4.0 );",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * visibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    }

    program = createProgram( shader );

    attributes = {
      vertex: gl.getAttribLocation ( program, "position" ),
      uv:     gl.getAttribLocation ( program, "uv" )
    }

    uniforms = {
      renderType:     gl.getUniformLocation( program, "renderType" ),
      map:            gl.getUniformLocation( program, "map" ),
      occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
      opacity:        gl.getUniformLocation( program, "opacity" ),
      color:          gl.getUniformLocation( program, "color" ),
      scale:          gl.getUniformLocation( program, "scale" ),
      rotation:       gl.getUniformLocation( program, "rotation" ),
      screenPosition: gl.getUniformLocation( program, "screenPosition" )
    };

  };

  /*
   * Render lens flares
   * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
   *         reads these back and calculates occlusion.
   */

  this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

    if ( flares.length === 0 ) return;

    var tempPosition = new THREE.Vector3();

    var invAspect = viewportHeight / viewportWidth,
      halfViewportWidth = viewportWidth * 0.5,
      halfViewportHeight = viewportHeight * 0.5;

    var size = 16 / viewportHeight,
      scale = new THREE.Vector2( size * invAspect, size );

    var screenPosition = new THREE.Vector3( 1, 1, 0 ),
      screenPositionPixels = new THREE.Vector2( 1, 1 );

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    gl.enableVertexAttribArray( attributes.vertex );
    gl.enableVertexAttribArray( attributes.uv );

    // loop through all lens flares to update their occlusion and positions
    // setup gl and common used attribs/unforms

    gl.uniform1i( uniforms.occlusionMap, 0 );
    gl.uniform1i( uniforms.map, 1 );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    gl.disable( gl.CULL_FACE );
    gl.depthMask( false );

    for ( var i = 0, l = flares.length; i < l; i ++ ) {

      size = 16 / viewportHeight;
      scale.set( size * invAspect, size );

      // calc object screen position

      var flare = flares[ i ];
      
      tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

      tempPosition.applyMatrix4( camera.matrixWorldInverse );
      tempPosition.applyProjection( camera.projectionMatrix );

      // setup arrays for gl programs

      screenPosition.copy( tempPosition )

      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

      // screen cull

      if ( hasVertexTexture || (
        screenPositionPixels.x > 0 &&
        screenPositionPixels.x < viewportWidth &&
        screenPositionPixels.y > 0 &&
        screenPositionPixels.y < viewportHeight ) ) {

        // save current RGB to temp texture

        gl.activeTexture( gl.TEXTURE1 );
        gl.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


        // render pink quad

        gl.uniform1i( uniforms.renderType, 0 );
        gl.uniform2f( uniforms.scale, scale.x, scale.y );
        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

        gl.disable( gl.BLEND );
        gl.enable( gl.DEPTH_TEST );

        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // copy result to occlusionMap

        gl.activeTexture( gl.TEXTURE0 );
        gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


        // restore graphics

        gl.uniform1i( uniforms.renderType, 1 );
        gl.disable( gl.DEPTH_TEST );

        gl.activeTexture( gl.TEXTURE1 );
        gl.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // update object positions

        flare.positionScreen.copy( screenPosition )

        if ( flare.customUpdateCallback ) {

          flare.customUpdateCallback( flare );

        } else {

          flare.updateLensFlares();

        }

        // render flares

        gl.uniform1i( uniforms.renderType, 2 );
        gl.enable( gl.BLEND );

        for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

          var sprite = flare.lensFlares[ j ];

          if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;

            size = sprite.size * sprite.scale / viewportHeight;

            scale.x = size * invAspect;
            scale.y = size;

            gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
            gl.uniform2f( uniforms.scale, scale.x, scale.y );
            gl.uniform1f( uniforms.rotation, sprite.rotation );

            gl.uniform1f( uniforms.opacity, sprite.opacity );
            gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

            renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
            renderer.setTexture( sprite.texture, 1 );

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

          }

        }

      }

    }

    // restore gl

    gl.enable( gl.CULL_FACE );
    gl.enable( gl.DEPTH_TEST );
    gl.depthMask( true );

    renderer.resetGLState();

  };

  function createProgram ( shader ) {

    var program = gl.createProgram();

    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    var prefix = "precision " + renderer.getPrecision() + " float;\n";

    gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    gl.compileShader( fragmentShader );
    gl.compileShader( vertexShader );

    gl.attachShader( program, fragmentShader );
    gl.attachShader( program, vertexShader );

    gl.linkProgram( program );

    return program;

  }

};

// File:src/renderers/webgl/plugins/ShadowMapPlugin.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {

  var _gl = _renderer.context;

  var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

  _frustum = new THREE.Frustum(),
  _projScreenMatrix = new THREE.Matrix4(),

  _min = new THREE.Vector3(),
  _max = new THREE.Vector3(),

  _matrixPosition = new THREE.Vector3(),
  
  _renderList = [];

  // init

  var depthShader = THREE.ShaderLib[ "depthRGBA" ];
  var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

  _depthMaterial = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader
   } );

  _depthMaterialMorph = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    morphTargets: true
  } );

  _depthMaterialSkin = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    skinning: true
  } );

  _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    morphTargets: true,
    skinning: true
  } );

  _depthMaterial._shadowPass = true;
  _depthMaterialMorph._shadowPass = true;
  _depthMaterialSkin._shadowPass = true;
  _depthMaterialMorphSkin._shadowPass = true;

  this.render = function ( scene, camera ) {

    if ( _renderer.shadowMapEnabled === false ) return;

    var i, il, j, jl, n,

    shadowMap, shadowMatrix, shadowCamera,
    program, buffer, material,
    webglObject, object, light,

    lights = [],
    k = 0,

    fog = null;

    // set GL state for depth map

    _gl.clearColor( 1, 1, 1, 1 );
    _gl.disable( _gl.BLEND );

    _gl.enable( _gl.CULL_FACE );
    _gl.frontFace( _gl.CCW );

    if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.FRONT );

    } else {

      _gl.cullFace( _gl.BACK );

    }

    _renderer.setDepthTest( true );

    // preprocess lights
    //  - skip lights that are not casting shadows
    //  - create virtual lights for cascaded shadow maps

    for ( i = 0, il = _lights.length; i < il; i ++ ) {

      light = _lights[ i ];

      if ( ! light.castShadow ) continue;

      if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

        for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

          var virtualLight;

          if ( ! light.shadowCascadeArray[ n ] ) {

            virtualLight = createVirtualLight( light, n );
            virtualLight.originalCamera = camera;

            var gyro = new THREE.Gyroscope();
            gyro.position.copy( light.shadowCascadeOffset );

            gyro.add( virtualLight );
            gyro.add( virtualLight.target );

            camera.add( gyro );

            light.shadowCascadeArray[ n ] = virtualLight;

            console.log( "Created virtualLight", virtualLight );

          } else {

            virtualLight = light.shadowCascadeArray[ n ];

          }

          updateVirtualLight( light, n );

          lights[ k ] = virtualLight;
          k ++;

        }

      } else {

        lights[ k ] = light;
        k ++;

      }

    }

    // render depth map

    for ( i = 0, il = lights.length; i < il; i ++ ) {

      light = lights[ i ];

      if ( ! light.shadowMap ) {

        var shadowFilter = THREE.LinearFilter;

        if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

          shadowFilter = THREE.NearestFilter;

        }

        var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

        light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
        light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

        light.shadowMatrix = new THREE.Matrix4();

      }

      if ( ! light.shadowCamera ) {

        if ( light instanceof THREE.SpotLight ) {

          light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

        } else if ( light instanceof THREE.DirectionalLight ) {

          light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

        } else {

          console.error( "Unsupported light type for shadow" );
          continue;

        }

        scene.add( light.shadowCamera );

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

      }

      if ( light.shadowCameraVisible && ! light.cameraHelper ) {

        light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
        scene.add( light.cameraHelper );

      }

      if ( light.isVirtual && virtualLight.originalCamera == camera ) {

        updateShadowCamera( camera, light );

      }

      shadowMap = light.shadowMap;
      shadowMatrix = light.shadowMatrix;
      shadowCamera = light.shadowCamera;

      //

      shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
      _matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
      shadowCamera.lookAt( _matrixPosition );
      shadowCamera.updateMatrixWorld();

      shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

      //

      if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
      if ( light.shadowCameraVisible ) light.cameraHelper.update();

      // compute shadow matrix

      shadowMatrix.set(
        0.5, 0.0, 0.0, 0.5,
        0.0, 0.5, 0.0, 0.5,
        0.0, 0.0, 0.5, 0.5,
        0.0, 0.0, 0.0, 1.0
      );

      shadowMatrix.multiply( shadowCamera.projectionMatrix );
      shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

      // update camera matrices and frustum

      _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
      _frustum.setFromMatrix( _projScreenMatrix );

      // render shadow map

      _renderer.setRenderTarget( shadowMap );
      _renderer.clear();

      // set object matrices & frustum culling

      _renderList.length = 0;

      projectObject( scene, scene, shadowCamera );


      // render regular objects

      var objectMaterial, useMorphing, useSkinning;

      for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

        webglObject = _renderList[ j ];

        object = webglObject.object;
        buffer = webglObject.buffer;

        // culling is overriden globally for all objects
        // while rendering depth map

        // need to deal with MeshFaceMaterial somehow
        // in that case just use the first of material.materials for now
        // (proper solution would require to break objects by materials
        //  similarly to regular rendering and then set corresponding
        //  depth materials per each chunk instead of just once per object)

        objectMaterial = getObjectMaterial( object );

        useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
        useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

        if ( object.customDepthMaterial ) {

          material = object.customDepthMaterial;

        } else if ( useSkinning ) {

          material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

        } else if ( useMorphing ) {

          material = _depthMaterialMorph;

        } else {

          material = _depthMaterial;

        }

        _renderer.setMaterialFaces( objectMaterial );

        if ( buffer instanceof THREE.BufferGeometry ) {

          _renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );

        } else {

          _renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );

        }

      }

      // set matrices and render immediate objects

      for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

        webglObject = _webglObjectsImmediate[ j ];
        object = webglObject.object;

        if ( object.visible && object.castShadow ) {

          object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

          _renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

        }

      }

    }

    // restore GL state

    var clearColor = _renderer.getClearColor(),
    clearAlpha = _renderer.getClearAlpha();

    _gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
    _gl.enable( _gl.BLEND );

    if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.BACK );

    }

    _renderer.resetGLState();

  };

  function projectObject( scene, object, shadowCamera ){

    if ( object.visible ) {

      var webglObjects = _webglObjects[ object.id ];

      if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {

        for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

          var webglObject = webglObjects[ i ];

          object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
          _renderList.push( webglObject );

        }

      }

      for ( var i = 0, l = object.children.length; i < l; i ++ ) {

        projectObject( scene, object.children[ i ], shadowCamera );

      }

    }

  }

  function createVirtualLight( light, cascade ) {

    var virtualLight = new THREE.DirectionalLight();

    virtualLight.isVirtual = true;

    virtualLight.onlyShadow = true;
    virtualLight.castShadow = true;

    virtualLight.shadowCameraNear = light.shadowCameraNear;
    virtualLight.shadowCameraFar = light.shadowCameraFar;

    virtualLight.shadowCameraLeft = light.shadowCameraLeft;
    virtualLight.shadowCameraRight = light.shadowCameraRight;
    virtualLight.shadowCameraBottom = light.shadowCameraBottom;
    virtualLight.shadowCameraTop = light.shadowCameraTop;

    virtualLight.shadowCameraVisible = light.shadowCameraVisible;

    virtualLight.shadowDarkness = light.shadowDarkness;

    virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
    virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
    virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

    virtualLight.pointsWorld = [];
    virtualLight.pointsFrustum = [];

    var pointsWorld = virtualLight.pointsWorld,
      pointsFrustum = virtualLight.pointsFrustum;

    for ( var i = 0; i < 8; i ++ ) {

      pointsWorld[ i ] = new THREE.Vector3();
      pointsFrustum[ i ] = new THREE.Vector3();

    }

    var nearZ = light.shadowCascadeNearZ[ cascade ];
    var farZ = light.shadowCascadeFarZ[ cascade ];

    pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
    pointsFrustum[ 1 ].set(  1, - 1, nearZ );
    pointsFrustum[ 2 ].set( - 1,  1, nearZ );
    pointsFrustum[ 3 ].set(  1,  1, nearZ );

    pointsFrustum[ 4 ].set( - 1, - 1, farZ );
    pointsFrustum[ 5 ].set(  1, - 1, farZ );
    pointsFrustum[ 6 ].set( - 1,  1, farZ );
    pointsFrustum[ 7 ].set(  1,  1, farZ );

    return virtualLight;

  }

  // Synchronize virtual light with the original light

  function updateVirtualLight( light, cascade ) {

    var virtualLight = light.shadowCascadeArray[ cascade ];

    virtualLight.position.copy( light.position );
    virtualLight.target.position.copy( light.target.position );
    virtualLight.lookAt( virtualLight.target );

    virtualLight.shadowCameraVisible = light.shadowCameraVisible;
    virtualLight.shadowDarkness = light.shadowDarkness;

    virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

    var nearZ = light.shadowCascadeNearZ[ cascade ];
    var farZ = light.shadowCascadeFarZ[ cascade ];

    var pointsFrustum = virtualLight.pointsFrustum;

    pointsFrustum[ 0 ].z = nearZ;
    pointsFrustum[ 1 ].z = nearZ;
    pointsFrustum[ 2 ].z = nearZ;
    pointsFrustum[ 3 ].z = nearZ;

    pointsFrustum[ 4 ].z = farZ;
    pointsFrustum[ 5 ].z = farZ;
    pointsFrustum[ 6 ].z = farZ;
    pointsFrustum[ 7 ].z = farZ;

  }

  // Fit shadow camera's ortho frustum to camera frustum

  function updateShadowCamera( camera, light ) {

    var shadowCamera = light.shadowCamera,
      pointsFrustum = light.pointsFrustum,
      pointsWorld = light.pointsWorld;

    _min.set( Infinity, Infinity, Infinity );
    _max.set( - Infinity, - Infinity, - Infinity );

    for ( var i = 0; i < 8; i ++ ) {

      var p = pointsWorld[ i ];

      p.copy( pointsFrustum[ i ] );
      p.unproject( camera );

      p.applyMatrix4( shadowCamera.matrixWorldInverse );

      if ( p.x < _min.x ) _min.x = p.x;
      if ( p.x > _max.x ) _max.x = p.x;

      if ( p.y < _min.y ) _min.y = p.y;
      if ( p.y > _max.y ) _max.y = p.y;

      if ( p.z < _min.z ) _min.z = p.z;
      if ( p.z > _max.z ) _max.z = p.z;

    }

    shadowCamera.left = _min.x;
    shadowCamera.right = _max.x;
    shadowCamera.top = _max.y;
    shadowCamera.bottom = _min.y;

    // can't really fit near/far
    //shadowCamera.near = _min.z;
    //shadowCamera.far = _max.z;

    shadowCamera.updateProjectionMatrix();

  }

  // For the moment just ignore objects that have multiple materials with different animation methods
  // Only the first material will be taken into account for deciding which depth material to use for shadow maps

  function getObjectMaterial( object ) {

    return object.material instanceof THREE.MeshFaceMaterial
      ? object.material.materials[ 0 ]
      : object.material;

  };

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

  var gl = renderer.context;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;

  var texture;
  
  var init = function () {

    var vertices = new Float32Array( [
      - 0.5, - 0.5,  0, 0,
        0.5, - 0.5,  1, 0,
        0.5,   0.5,  1, 1,
      - 0.5,   0.5,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    vertexBuffer  = gl.createBuffer();
    elementBuffer = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    program = createProgram();

    attributes = {
      position:     gl.getAttribLocation ( program, 'position' ),
      uv:         gl.getAttribLocation ( program, 'uv' )
    };

    uniforms = {
      uvOffset:     gl.getUniformLocation( program, 'uvOffset' ),
      uvScale:      gl.getUniformLocation( program, 'uvScale' ),

      rotation:     gl.getUniformLocation( program, 'rotation' ),
      scale:        gl.getUniformLocation( program, 'scale' ),

      color:        gl.getUniformLocation( program, 'color' ),
      map:        gl.getUniformLocation( program, 'map' ),
      opacity:      gl.getUniformLocation( program, 'opacity' ),

      modelViewMatrix:  gl.getUniformLocation( program, 'modelViewMatrix' ),
      projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

      fogType:      gl.getUniformLocation( program, 'fogType' ),
      fogDensity:     gl.getUniformLocation( program, 'fogDensity' ),
      fogNear:      gl.getUniformLocation( program, 'fogNear' ),
      fogFar:       gl.getUniformLocation( program, 'fogFar' ),
      fogColor:     gl.getUniformLocation( program, 'fogColor' ),

      alphaTest:      gl.getUniformLocation( program, 'alphaTest' )
    };

    var canvas = document.createElement( 'canvas' );
    canvas.width = 8;
    canvas.height = 8;

    var context = canvas.getContext( '2d' );
    context.fillStyle = 'white';
    context.fillRect( 0, 0, 8, 8 );

    texture = new THREE.Texture( canvas );
    texture.needsUpdate = true;

  };

  this.render = function ( scene, camera ) {

    if ( sprites.length === 0 ) return;

    // setup gl

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    gl.enableVertexAttribArray( attributes.position );
    gl.enableVertexAttribArray( attributes.uv );

    gl.disable( gl.CULL_FACE );
    gl.enable( gl.BLEND );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    gl.activeTexture( gl.TEXTURE0 );
    gl.uniform1i( uniforms.map, 0 );

    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;

    if ( fog ) {

      gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

      if ( fog instanceof THREE.Fog ) {

        gl.uniform1f( uniforms.fogNear, fog.near );
        gl.uniform1f( uniforms.fogFar, fog.far );

        gl.uniform1i( uniforms.fogType, 1 );
        oldFogType = 1;
        sceneFogType = 1;

      } else if ( fog instanceof THREE.FogExp2 ) {

        gl.uniform1f( uniforms.fogDensity, fog.density );

        gl.uniform1i( uniforms.fogType, 2 );
        oldFogType = 2;
        sceneFogType = 2;

      }

    } else {

      gl.uniform1i( uniforms.fogType, 0 );
      oldFogType = 0;
      sceneFogType = 0;

    }


    // update positions and sort

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];

      sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );

      if ( sprite.renderDepth === null ) {

        sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

      } else {

        sprite.z = sprite.renderDepth;

      }

    }

    sprites.sort( painterSortStable );

    // render all sprites

    var scale = [];

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];
      var material = sprite.material;

      gl.uniform1f( uniforms.alphaTest, material.alphaTest );
      gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

      scale[ 0 ] = sprite.scale.x;
      scale[ 1 ] = sprite.scale.y;

      var fogType = 0;

      if ( scene.fog && material.fog ) {

        fogType = sceneFogType;

      }

      if ( oldFogType !== fogType ) {

        gl.uniform1i( uniforms.fogType, fogType );
        oldFogType = fogType;

      }

      if ( material.map !== null ) {

        gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
        gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

      } else {

        gl.uniform2f( uniforms.uvOffset, 0, 0 );
        gl.uniform2f( uniforms.uvScale, 1, 1 );

      }

      gl.uniform1f( uniforms.opacity, material.opacity );
      gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

      gl.uniform1f( uniforms.rotation, material.rotation );
      gl.uniform2fv( uniforms.scale, scale );

      renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
      renderer.setDepthTest( material.depthTest );
      renderer.setDepthWrite( material.depthWrite );

      if ( material.map && material.map.image && material.map.image.width ) {

        renderer.setTexture( material.map, 0 );

      } else {

        renderer.setTexture( texture, 0 );

      }

      gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    }

    // restore gl

    gl.enable( gl.CULL_FACE );
    
    renderer.resetGLState();

  };

  function createProgram () {

    var program = gl.createProgram();

    var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    gl.shaderSource( vertexShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform float rotation;',
      'uniform vec2 scale;',
      'uniform vec2 uvOffset;',
      'uniform vec2 uvScale;',

      'attribute vec2 position;',
      'attribute vec2 uv;',

      'varying vec2 vUV;',

      'void main() {',

        'vUV = uvOffset + uv * uvScale;',

        'vec2 alignedPosition = position * scale;',

        'vec2 rotatedPosition;',
        'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
        'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

        'vec4 finalPosition;',

        'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
        'finalPosition.xy += rotatedPosition;',
        'finalPosition = projectionMatrix * finalPosition;',

        'gl_Position = finalPosition;',

      '}'

    ].join( '\n' ) );

    gl.shaderSource( fragmentShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform vec3 color;',
      'uniform sampler2D map;',
      'uniform float opacity;',

      'uniform int fogType;',
      'uniform vec3 fogColor;',
      'uniform float fogDensity;',
      'uniform float fogNear;',
      'uniform float fogFar;',
      'uniform float alphaTest;',

      'varying vec2 vUV;',

      'void main() {',

        'vec4 texture = texture2D( map, vUV );',

        'if ( texture.a < alphaTest ) discard;',

        'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

        'if ( fogType > 0 ) {',

          'float depth = gl_FragCoord.z / gl_FragCoord.w;',
          'float fogFactor = 0.0;',

          'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

          '} else {',

            'const float LOG2 = 1.442695;',
            'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

          '}',

          'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

        '}',

      '}'

    ].join( '\n' ) );

    gl.compileShader( vertexShader );
    gl.compileShader( fragmentShader );

    gl.attachShader( program, vertexShader );
    gl.attachShader( program, fragmentShader );

    gl.linkProgram( program );

    return program;

  };

  function painterSortStable ( a, b ) {

    if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return b.id - a.id;

    }

  };

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

  merge: function ( geometry1, geometry2, materialIndexOffset ) {

    console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    var matrix;

    if ( geometry2 instanceof THREE.Mesh ) {

      geometry2.matrixAutoUpdate && geometry2.updateMatrix();

      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;

    }

    geometry1.merge( geometry2, matrix, materialIndexOffset );

  },

  center: function ( geometry ) {

    console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    return geometry.center();

  }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

  crossOrigin: undefined,

  loadTexture: function ( url, mapping, onLoad, onError ) {

    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;

    var texture = new THREE.Texture( undefined, mapping );

    loader.load( url, function ( image ) {

      texture.image = image;
      texture.needsUpdate = true;

      if ( onLoad ) onLoad( texture );

    }, undefined, function ( event ) {

      if ( onError ) onError( event );

    } );

    texture.sourceFile = url;

    return texture;

  },

  loadTextureCube: function ( array, mapping, onLoad, onError ) {

    var images = [];

    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;

    var texture = new THREE.CubeTexture( images, mapping );

    // no flipping needed for cube textures

    texture.flipY = false;

    var loaded = 0;

    var loadTexture = function ( i ) {

      loader.load( array[ i ], function ( image ) {

        texture.images[ i ] = image;

        loaded += 1;

        if ( loaded === 6 ) {

          texture.needsUpdate = true;

          if ( onLoad ) onLoad( texture );

        }

      } );

    }

    for ( var i = 0, il = array.length; i < il; ++ i ) {

      loadTexture( i );

    }

    return texture;

  },

  loadCompressedTexture: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

  },

  loadCompressedTextureCube: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

  },

  getNormalMap: function ( image, depth ) {

    // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

    var cross = function ( a, b ) {

      return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

    }

    var subtract = function ( a, b ) {

      return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

    }

    var normalize = function ( a ) {

      var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
      return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

    }

    depth = depth | 1;

    var width = image.width;
    var height = image.height;

    var canvas = document.createElement( 'canvas' );
    canvas.width = width;
    canvas.height = height;

    var context = canvas.getContext( '2d' );
    context.drawImage( image, 0, 0 );

    var data = context.getImageData( 0, 0, width, height ).data;
    var imageData = context.createImageData( width, height );
    var output = imageData.data;

    for ( var x = 0; x < width; x ++ ) {

      for ( var y = 0; y < height; y ++ ) {

        var ly = y - 1 < 0 ? 0 : y - 1;
        var uy = y + 1 > height - 1 ? height - 1 : y + 1;
        var lx = x - 1 < 0 ? 0 : x - 1;
        var ux = x + 1 > width - 1 ? width - 1 : x + 1;

        var points = [];
        var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
        points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
        points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
        points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
        points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
        points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

        var normals = [];
        var num_points = points.length;

        for ( var i = 0; i < num_points; i ++ ) {

          var v1 = points[ i ];
          var v2 = points[ ( i + 1 ) % num_points ];
          v1 = subtract( v1, origin );
          v2 = subtract( v2, origin );
          normals.push( normalize( cross( v1, v2 ) ) );

        }

        var normal = [ 0, 0, 0 ];

        for ( var i = 0; i < normals.length; i ++ ) {

          normal[ 0 ] += normals[ i ][ 0 ];
          normal[ 1 ] += normals[ i ][ 1 ];
          normal[ 2 ] += normals[ i ][ 2 ];

        }

        normal[ 0 ] /= normals.length;
        normal[ 1 ] /= normals.length;
        normal[ 2 ] /= normals.length;

        var idx = ( y * width + x ) * 4;

        output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
        output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
        output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
        output[ idx + 3 ] = 255;

      }

    }

    context.putImageData( imageData, 0, 0 );

    return canvas;

  },

  generateDataTexture: function ( width, height, color ) {

    var size = width * height;
    var data = new Uint8Array( 3 * size );

    var r = Math.floor( color.r * 255 );
    var g = Math.floor( color.g * 255 );
    var b = Math.floor( color.b * 255 );

    for ( var i = 0; i < size; i ++ ) {

      data[ i * 3 ]      = r;
      data[ i * 3 + 1 ] = g;
      data[ i * 3 + 2 ] = b;

    }

    var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
    texture.needsUpdate = true;

    return texture;

  }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

  createMultiMaterialObject: function ( geometry, materials ) {

    var group = new THREE.Object3D();

    for ( var i = 0, l = materials.length; i < l; i ++ ) {

      group.add( new THREE.Mesh( geometry, materials[ i ] ) );

    }

    return group;

  },

  detach: function ( child, parent, scene ) {

    child.applyMatrix( parent.matrixWorld );
    parent.remove( child );
    scene.add( child );

  },

  attach: function ( child, scene, parent ) {

    var matrixWorldInverse = new THREE.Matrix4();
    matrixWorldInverse.getInverse( parent.matrixWorld );
    child.applyMatrix( matrixWorldInverse );

    scene.remove( child );
    parent.add( child );

  }

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *  typeface.js and canvastext
 *    For converting fonts and rendering with javascript
 *    http://typeface.neocracy.org
 *
 *  Triangulation ported from AS3
 *    Simple Polygon Triangulation
 *    http://actionsnippet.com/?p=1462
 *
 *  A Method to triangulate shapes with holes
 *    http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

  faces: {},

  // Just for now. face[weight][style]

  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,

  getFace: function () {

    try {

      return this.faces[ this.face ][ this.weight ][ this.style ];

    } catch (e) {

      throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

    };

  },

  loadFace: function ( data ) {

    var family = data.familyName.toLowerCase();

    var ThreeFont = this;

    ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

    ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
    ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

    var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

    return data;

  },

  drawText: function ( text ) {

    var characterPts = [], allPts = [];

    // RenderText

    var i, p,
      face = this.getFace(),
      scale = this.size / face.resolution,
      offset = 0,
      chars = String( text ).split( '' ),
      length = chars.length;

    var fontPaths = [];

    for ( i = 0; i < length; i ++ ) {

      var path = new THREE.Path();

      var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
      offset += ret.offset;

      fontPaths.push( ret.path );

    }

    // get the width

    var width = offset / 2;
    //
    // for ( p = 0; p < allPts.length; p++ ) {
    //
    //  allPts[ p ].x -= width;
    //
    // }

    //var extract = this.extractPoints( allPts, characterPts );
    //extract.contour = allPts;

    //extract.paths = fontPaths;
    //extract.offset = width;

    return { paths: fontPaths, offset: width };

  },




  extractGlyphPoints: function ( c, face, scale, offset, path ) {

    var pts = [];

    var i, i2, divisions,
      outline, action, length,
      scaleX, scaleY,
      x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
      laste,
      glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

    if ( ! glyph ) return;

    if ( glyph.o ) {

      outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
      length = outline.length;

      scaleX = scale;
      scaleY = scale;

      for ( i = 0; i < length; ) {

        action = outline[ i ++ ];

        //console.log( action );

        switch ( action ) {

        case 'm':

          // Move To

          x = outline[ i ++ ] * scaleX + offset;
          y = outline[ i ++ ] * scaleY;

          path.moveTo( x, y );
          break;

        case 'l':

          // Line To

          x = outline[ i ++ ] * scaleX + offset;
          y = outline[ i ++ ] * scaleY;
          path.lineTo( x,y );
          break;

        case 'q':

          // QuadraticCurveTo

          cpx  = outline[ i ++ ] * scaleX + offset;
          cpy  = outline[ i ++ ] * scaleY;
          cpx1 = outline[ i ++ ] * scaleX + offset;
          cpy1 = outline[ i ++ ] * scaleY;

          path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

          laste = pts[ pts.length - 1 ];

          if ( laste ) {

            cpx0 = laste.x;
            cpy0 = laste.y;

            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

              var t = i2 / divisions;
              var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
              var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
            }

          }

          break;

        case 'b':

          // Cubic Bezier Curve

          cpx  = outline[ i ++ ] *  scaleX + offset;
          cpy  = outline[ i ++ ] *  scaleY;
          cpx1 = outline[ i ++ ] *  scaleX + offset;
          cpy1 = outline[ i ++ ] *  scaleY;
          cpx2 = outline[ i ++ ] *  scaleX + offset;
          cpy2 = outline[ i ++ ] *  scaleY;

          path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

          laste = pts[ pts.length - 1 ];

          if ( laste ) {

            cpx0 = laste.x;
            cpy0 = laste.y;

            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

              var t = i2 / divisions;
              var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
              var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

            }

          }

          break;

        }

      }
    }



    return { offset: glyph.ha * scale, path:path };
  }

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

  // Parameters 

  parameters = parameters || {};

  var size = parameters.size !== undefined ? parameters.size : 100;
  var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

  var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
  var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
  var style = parameters.style !== undefined ? parameters.style : 'normal';

  THREE.FontUtils.size = size;
  THREE.FontUtils.divisions = curveSegments;

  THREE.FontUtils.face = font;
  THREE.FontUtils.weight = weight;
  THREE.FontUtils.style = style;

  // Get a Font data json object

  var data = THREE.FontUtils.drawText( text );

  var paths = data.paths;
  var shapes = [];

  for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

    Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  }

  return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function ( namespace ) {

  var EPSILON = 0.0000000001;

  // takes in an contour array and returns

  var process = function ( contour, indices ) {

    var n = contour.length;

    if ( n < 3 ) return null;

    var result = [],
      verts = [],
      vertIndices = [];

    /* we want a counter-clockwise polygon in verts */

    var u, v, w;

    if ( area( contour ) > 0.0 ) {

      for ( v = 0; v < n; v ++ ) verts[ v ] = v;

    } else {

      for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

    }

    var nv = n;

    /*  remove nv - 2 vertices, creating 1 triangle every time */

    var count = 2 * nv;   /* error detection */

    for ( v = nv - 1; nv > 2; ) {

      /* if we loop, it is probably a non-simple polygon */

      if ( ( count -- ) <= 0 ) {

        //** Triangulate: ERROR - probable bad polygon!

        //throw ( "Warning, unable to triangulate polygon!" );
        //return null;
        // Sometimes warning is fine, especially polygons are triangulated in reverse.
        console.log( 'Warning, unable to triangulate polygon!' );

        if ( indices ) return vertIndices;
        return result;

      }

      /* three consecutive vertices in current polygon, <u,v,w> */

      u = v;    if ( nv <= u ) u = 0;     /* previous */
      v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
      w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

      if ( snip( contour, u, v, w, nv, verts ) ) {

        var a, b, c, s, t;

        /* true names of the vertices */

        a = verts[ u ];
        b = verts[ v ];
        c = verts[ w ];

        /* output Triangle */

        result.push( [ contour[ a ],
          contour[ b ],
          contour[ c ] ] );


        vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

        /* remove v from the remaining polygon */

        for ( s = v, t = v + 1; t < nv; s++, t++ ) {

          verts[ s ] = verts[ t ];

        }

        nv --;

        /* reset error detection counter */

        count = 2 * nv;

      }

    }

    if ( indices ) return vertIndices;
    return result;

  };

  // calculate area of the contour polygon

  var area = function ( contour ) {

    var n = contour.length;
    var a = 0.0;

    for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

      a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    }

    return a * 0.5;

  };

  var snip = function ( contour, u, v, w, n, verts ) {

    var p;
    var ax, ay, bx, by;
    var cx, cy, px, py;

    ax = contour[ verts[ u ] ].x;
    ay = contour[ verts[ u ] ].y;

    bx = contour[ verts[ v ] ].x;
    by = contour[ verts[ v ] ].y;

    cx = contour[ verts[ w ] ].x;
    cy = contour[ verts[ w ] ].y;

    if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

    var aX, aY, bX, bY, cX, cY;
    var apx, apy, bpx, bpy, cpx, cpy;
    var cCROSSap, bCROSScp, aCROSSbp;

    aX = cx - bx;  aY = cy - by;
    bX = ax - cx;  bY = ay - cy;
    cX = bx - ax;  cY = by - ay;

    for ( p = 0; p < n; p ++ ) {

      px = contour[ verts[ p ] ].x
      py = contour[ verts[ p ] ].y

      if ( ( ( px === ax ) && ( py === ay ) ) ||
         ( ( px === bx ) && ( py === by ) ) ||
         ( ( px === cx ) && ( py === cy ) ) ) continue;

      apx = px - ax;  apy = py - ay;
      bpx = px - bx;  bpy = py - by;
      cpx = px - cx;  cpy = py - cy;

      // see if p is inside triangle abc

      aCROSSbp = aX * bpy - aY * bpx;
      cCROSSap = cX * apy - cY * apx;
      bCROSScp = bX * cpy - bY * cpx;

      if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

    }

    return true;

  };


  namespace.Triangulate = process;
  namespace.Triangulate.area = area;

  return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

  THREE.Object3D.call( this );

  this.type = 'Audio';

  this.context = listener.context;
  this.source = this.context.createBufferSource();

  this.gain = this.context.createGain();
  this.gain.connect( this.context.destination );

  this.panner = this.context.createPanner();
  this.panner.connect( this.gain );

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );

THREE.Audio.prototype.load = function ( file ) {

  var scope = this;

  var request = new XMLHttpRequest();
  request.open( 'GET', file, true );
  request.responseType = 'arraybuffer';
  request.onload = function ( e ) {

    scope.context.decodeAudioData( this.response, function ( buffer ) {

      scope.source.buffer = buffer;
      scope.source.connect( scope.panner );
      scope.source.start( 0 );

    } );

  };
  request.send();

  return this;

};

THREE.Audio.prototype.setLoop = function ( value ) {

  this.source.loop = value;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

  this.panner.refDistance = value;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

  this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();

  return function ( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    position.setFromMatrixPosition( this.matrixWorld );

    this.panner.setPosition( position.x, position.y, position.z );

  };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

  THREE.Object3D.call( this );

  this.type = 'AudioListener';

  this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3();

  var orientation = new THREE.Vector3();
  var velocity = new THREE.Vector3();

  var positionPrev = new THREE.Vector3();

  return function ( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    var listener = this.context.listener;

    this.matrixWorld.decompose( position, quaternion, scale );

    orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
    velocity.subVectors( position, positionPrev );

    listener.setPosition( position.x, position.y, position.z );
    listener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );
    listener.setVelocity( velocity.x, velocity.y, velocity.z );

    positionPrev.copy( position );

  };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *  Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//  - t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

  console.log( "Warning, getPoint() not implemented!" );
  return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

  var t = this.getUtoTmapping( u );
  return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 5;

  var d, pts = [];

  for ( d = 0; d <= divisions; d ++ ) {

    pts.push( this.getPoint( d / divisions ) );

  }

  return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 5;

  var d, pts = [];

  for ( d = 0; d <= divisions; d ++ ) {

    pts.push( this.getPointAt( d / divisions ) );

  }

  return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

  var lengths = this.getLengths();
  return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

  if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

  if ( this.cacheArcLengths
    && ( this.cacheArcLengths.length == divisions + 1 )
    && ! this.needsUpdate) {

    //console.log( "cached", this.cacheArcLengths );
    return this.cacheArcLengths;

  }

  this.needsUpdate = false;

  var cache = [];
  var current, last = this.getPoint( 0 );
  var p, sum = 0;

  cache.push( 0 );

  for ( p = 1; p <= divisions; p ++ ) {

    current = this.getPoint ( p / divisions );
    sum += current.distanceTo( last );
    cache.push( sum );
    last = current;

  }

  this.cacheArcLengths = cache;

  return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
  this.needsUpdate = true;
  this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

  var arcLengths = this.getLengths();

  var i = 0, il = arcLengths.length;

  var targetArcLength; // The targeted u distance value to get

  if ( distance ) {

    targetArcLength = distance;

  } else {

    targetArcLength = u * arcLengths[ il - 1 ];

  }

  //var time = Date.now();

  // binary search for the index with largest value smaller than target u distance

  var low = 0, high = il - 1, comparison;

  while ( low <= high ) {

    i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    comparison = arcLengths[ i ] - targetArcLength;

    if ( comparison < 0 ) {

      low = i + 1;
      continue;

    } else if ( comparison > 0 ) {

      high = i - 1;
      continue;

    } else {

      high = i;
      break;

      // DONE

    }

  }

  i = high;

  //console.log('b' , i, low, high, Date.now()- time);

  if ( arcLengths[ i ] == targetArcLength ) {

    var t = i / ( il - 1 );
    return t;

  }

  // we could get finer grain at lengths, or use simple interpolatation between two points

  var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

  return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

  var delta = 0.0001;
  var t1 = t - delta;
  var t2 = t + delta;

  // Capping in case of danger

  if ( t1 < 0 ) t1 = 0;
  if ( t2 > 1 ) t2 = 1;

  var pt1 = this.getPoint( t1 );
  var pt2 = this.getPoint( t2 );

  var vec = pt2.clone().sub(pt1);
  return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

  var t = this.getUtoTmapping( u );
  return this.getTangent( t );

};





/**************************************************************
 *  Utils
 **************************************************************/

THREE.Curve.Utils = {

  tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

  },

  // Puay Bing, thanks for helping with this derivative!

  tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

    return - 3 * p0 * (1 - t) * (1 - t)  +
      3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
      6 * t *  p2 * (1-t) - 3 * t * t * p2 +
      3 * t * t * p3;

  },

  tangentSpline: function ( t, p0, p1, p2, p3 ) {

    // To check if my formulas are correct

    var h00 = 6 * t * t - 6 * t;  // derived from 2t^3 âˆ’ 3t^2 + 1
    var h10 = 3 * t * t - 4 * t + 1; // t^3 âˆ’ 2t^2 + t
    var h01 = - 6 * t * t + 6 * t;  // âˆ’ 2t3 + 3t2
    var h11 = 3 * t * t - 2 * t;  // t3 âˆ’ t2

    return h00 + h10 + h01 + h11;

  },

  // Catmull-Rom

  interpolate: function( p0, p1, p2, p3, t ) {

    var v0 = ( p2 - p0 ) * 0.5;
    var v1 = ( p3 - p1 ) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};


// TODO: Transformation for Curves?

/**************************************************************
 *  3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

  constructor.prototype = Object.create( THREE.Curve.prototype );
  constructor.prototype.getPoint = getPointFunc;

  return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *  Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

  this.curves = [];
  this.bends = [];
  
  this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

  this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
  // TODO
  // If the ending of curve is not connected to the starting
  // or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
  // TODO Test
  // and verify for vector3 (needs to implement equals)
  // Add a line curve if start and end of lines are not connected
  var startPoint = this.curves[0].getPoint(0);
  var endPoint = this.curves[this.curves.length-1].getPoint(1);
  
  if (! startPoint.equals(endPoint)) {
    this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
  }
  
};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

  var d = t * this.getLength();
  var curveLengths = this.getCurveLengths();
  var i = 0, diff, curve;

  // To think about boundaries points.

  while ( i < curveLengths.length ) {

    if ( curveLengths[ i ] >= d ) {

      diff = curveLengths[ i ] - d;
      curve = this.curves[ i ];

      var u = 1 - diff / curve.getLength();

      return curve.getPointAt( u );

      break;
    }

    i ++;

  }

  return null;

  // loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

  var lens = this.getCurveLengths();
  return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

  // We use cache values if curves and cache array are same length

  if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

    return this.cacheLengths;

  };

  // Get length of subsurve
  // Push sums into cached array

  var lengths = [], sums = 0;
  var i, il = this.curves.length;

  for ( i = 0; i < il; i ++ ) {

    sums += this.curves[ i ].getLength();
    lengths.push( sums );

  }

  this.cacheLengths = lengths;

  return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function () {

  var points = this.getPoints();

  var maxX, maxY, maxZ;
  var minX, minY, minZ;

  maxX = maxY = Number.NEGATIVE_INFINITY;
  minX = minY = Number.POSITIVE_INFINITY;

  var p, i, il, sum;

  var v3 = points[0] instanceof THREE.Vector3;

  sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

  for ( i = 0, il = points.length; i < il; i ++ ) {

    p = points[ i ];

    if ( p.x > maxX ) maxX = p.x;
    else if ( p.x < minX ) minX = p.x;

    if ( p.y > maxY ) maxY = p.y;
    else if ( p.y < minY ) minY = p.y;

    if ( v3 ) {

      if ( p.z > maxZ ) maxZ = p.z;
      else if ( p.z < minZ ) minZ = p.z;

    }

    sum.add( p );

  }

  var ret = {

    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY

  };

  if ( v3 ) {

    ret.maxZ = maxZ;
    ret.minZ = minZ;

  }

  return ret;

};

/**************************************************************
 *  Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

  var pts = this.getPoints( divisions, true );
  return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

  var pts = this.getSpacedPoints( divisions, true );
  return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < points.length; i ++ ) {

    geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

  }

  return geometry;

};


/**************************************************************
 *  Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

  this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

  var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
  var i, il;

  if ( ! bends ) {

    bends = this.bends;

  }

  for ( i = 0, il = bends.length; i < il; i ++ ) {

    oldPts = this.getWrapPoints( oldPts, bends[ i ] );

  }

  return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

  var oldPts = this.getSpacedPoints( segments );

  var i, il;

  if ( ! bends ) {

    bends = this.bends;

  }

  for ( i = 0, il = bends.length; i < il; i ++ ) {

    oldPts = this.getWrapPoints( oldPts, bends[ i ] );

  }

  return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

  var bounds = this.getBoundingBox();

  var i, il, p, oldX, oldY, xNorm;

  for ( i = 0, il = oldPts.length; i < il; i ++ ) {

    p = oldPts[ i ];

    oldX = p.x;
    oldY = p.y;

    xNorm = oldX / bounds.maxX;

    // If using actual distance, for length > path, requires line extrusions
    //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

    xNorm = path.getUtoTmapping( xNorm, oldX );

    // check for out of bounds?

    var pathPt = path.getPoint( xNorm );
    var normal = path.getTangent( xNorm );
    normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

    p.x = pathPt.x + normal.x;
    p.y = pathPt.y + normal.y;

  }

  return oldPts;

};


// File:src/extras/core/Gyroscope.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

  THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

  var translationObject = new THREE.Vector3();
  var quaternionObject = new THREE.Quaternion();
  var scaleObject = new THREE.Vector3();

  var translationWorld = new THREE.Vector3();
  var quaternionWorld = new THREE.Quaternion();
  var scaleWorld = new THREE.Vector3();

  return function ( force ) {

    this.matrixAutoUpdate && this.updateMatrix();

    // update matrixWorld

    if ( this.matrixWorldNeedsUpdate || force ) {

      if ( this.parent ) {

        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

        this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
        this.matrix.decompose( translationObject, quaternionObject, scaleObject );

        this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


      } else {

        this.matrixWorld.copy( this.matrix );

      }


      this.matrixWorldNeedsUpdate = false;

      force = true;

    }

    // update children

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].updateMatrixWorld( force );

    }

  };
  
}() );

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

  THREE.CurvePath.call(this);

  this.actions = [];

  if ( points ) {

    this.fromPoints( points );

  }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
  BEZIER_CURVE_TO: 'bezierCurveTo',     // Bezier cubic curve
  CSPLINE_THRU: 'splineThru',       // Catmull-rom spline
  ARC: 'arc',               // Circle
  ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

  this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

  for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

    this.lineTo( vectors[ v ].x, vectors[ v ].y );

  };

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

  var args = Array.prototype.slice.call( arguments );
  this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
                        new THREE.Vector2( aCPx, aCPy ),
                        new THREE.Vector2( aX, aY ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
                         aCP2x, aCP2y,
                         aX, aY ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
                      new THREE.Vector2( aCP1x, aCP1y ),
                      new THREE.Vector2( aCP2x, aCP2y ),
                      new THREE.Vector2( aX, aY ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

  var args = Array.prototype.slice.call( arguments );
  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];
//---
  var npts = [ new THREE.Vector2( x0, y0 ) ];
  Array.prototype.push.apply( npts, pts );

  var curve = new THREE.SplineCurve( npts );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var lastargs = this.actions[ this.actions.length - 1].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absarc(aX + x0, aY + y0, aRadius,
    aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise ) {
  this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var lastargs = this.actions[ this.actions.length - 1].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var args = Array.prototype.slice.call( arguments );
  var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
                  aStartAngle, aEndAngle, aClockwise );
  this.curves.push( curve );

  var lastPoint = curve.getPoint(1);
  args.push(lastPoint.x);
  args.push(lastPoint.y);

  this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

  if ( ! divisions ) divisions = 40;

  var points = [];

  for ( var i = 0; i < divisions; i ++ ) {

    points.push( this.getPoint( i / divisions ) );

    //if( !this.getPoint( i / divisions ) ) throw "DIE";

  }

  // if ( closedPath ) {
  //
  //  points.push( points[ 0 ] );
  //
  // }

  return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

  if (this.useSpacedPoints) {
    console.log('tata');
    return this.getSpacedPoints( divisions, closedPath );
  }

  divisions = divisions || 12;

  var points = [];

  var i, il, item, action, args;
  var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
    laste, j,
    t, tx, ty;

  for ( i = 0, il = this.actions.length; i < il; i ++ ) {

    item = this.actions[ i ];

    action = item.action;
    args = item.args;

    switch( action ) {

    case THREE.PathActions.MOVE_TO:

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case THREE.PathActions.LINE_TO:

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case THREE.PathActions.QUADRATIC_CURVE_TO:

      cpx  = args[ 2 ];
      cpy  = args[ 3 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }

      for ( j = 1; j <= divisions; j ++ ) {

        t = j / divisions;

        tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
        ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case THREE.PathActions.BEZIER_CURVE_TO:

      cpx  = args[ 4 ];
      cpy  = args[ 5 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      cpx2 = args[ 2 ];
      cpy2 = args[ 3 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }


      for ( j = 1; j <= divisions; j ++ ) {

        t = j / divisions;

        tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
        ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case THREE.PathActions.CSPLINE_THRU:

      laste = this.actions[ i - 1 ].args;

      var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
      var spts = [ last ];

      var n = divisions * args[ 0 ].length;

      spts = spts.concat( args[ 0 ] );

      var spline = new THREE.SplineCurve( spts );

      for ( j = 1; j <= n; j ++ ) {

        points.push( spline.getPointAt( j / n ) ) ;

      }

      break;

    case THREE.PathActions.ARC:

      var aX = args[ 0 ], aY = args[ 1 ],
        aRadius = args[ 2 ],
        aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
        aClockwise = !! args[ 5 ];

      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      for ( j = 1; j <= tdivisions; j ++ ) {

        t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + aRadius * Math.cos( angle );
        ty = aY + aRadius * Math.sin( angle );

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;
      
    case THREE.PathActions.ELLIPSE:

      var aX = args[ 0 ], aY = args[ 1 ],
        xRadius = args[ 2 ],
        yRadius = args[ 3 ],
        aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
        aClockwise = !! args[ 6 ];


      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      for ( j = 1; j <= tdivisions; j ++ ) {

        t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + xRadius * Math.cos( angle );
        ty = aY + yRadius * Math.sin( angle );

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    } // end switch

  }



  // Normalize to remove the closing point by default.
  var lastPoint = points[ points.length - 1];
  var EPSILON = 0.0000000001;
  if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
       Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
    points.splice( points.length - 1, 1);
  if ( closedPath ) {

    points.push( points[ 0 ] );

  }

  return points;

};

//
// Breaks path into shapes
//
//  Assumptions (if parameter isCCW==true the opposite holds):
//  - solid shapes are defined clockwise (CW)
//  - holes are defined counterclockwise (CCW)
//
//  If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

  function extractSubpaths( inActions ) {

    var i, il, item, action, args;

    var subPaths = [], lastPath = new THREE.Path();

    for ( i = 0, il = inActions.length; i < il; i ++ ) {

      item = inActions[ i ];

      args = item.args;
      action = item.action;

      if ( action == THREE.PathActions.MOVE_TO ) {

        if ( lastPath.actions.length != 0 ) {

          subPaths.push( lastPath );
          lastPath = new THREE.Path();

        }

      }

      lastPath[ action ].apply( lastPath, args );

    }

    if ( lastPath.actions.length != 0 ) {

      subPaths.push( lastPath );

    }

    // console.log(subPaths);

    return  subPaths;
  }

  function toShapesNoHoles( inSubpaths ) {

    var shapes = [];

    for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

      var tmpPath = inSubpaths[ i ];

      var tmpShape = new THREE.Shape();
      tmpShape.actions = tmpPath.actions;
      tmpShape.curves = tmpPath.curves;

      shapes.push( tmpShape );
    }

    //console.log("shape", shapes);

    return shapes;
  };

  function isPointInsidePolygon( inPt, inPolygon ) {
    var EPSILON = 0.0000000001;

    var polyLen = inPolygon.length;

    // inPt on polygon contour => immediate success    or
    // toggling of inside/outside at every single! intersection point of an edge
    //  with the horizontal line through inPt, left of inPt
    //  not counting lowerY endpoints of edges and whole edges on that line
    var inside = false;
    for( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
      var edgeLowPt  = inPolygon[ p ];
      var edgeHighPt = inPolygon[ q ];

      var edgeDx = edgeHighPt.x - edgeLowPt.x;
      var edgeDy = edgeHighPt.y - edgeLowPt.y;

      if ( Math.abs(edgeDy) > EPSILON ) {     // not parallel
        if ( edgeDy < 0 ) {
          edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
          edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
        }
        if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) )    continue;

        if ( inPt.y == edgeLowPt.y ) {
          if ( inPt.x == edgeLowPt.x )    return  true;   // inPt is on contour ?
          // continue;        // no intersection or edgeLowPt => doesn't count !!!
        } else {
          var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
          if ( perpEdge == 0 )        return  true;   // inPt is on contour ?
          if ( perpEdge < 0 )         continue;
          inside = ! inside;    // true intersection left of inPt
        }
      } else {    // parallel or colinear
        if ( inPt.y != edgeLowPt.y )    continue;     // parallel
        // egde lies on the same horizontal line as inPt
        if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
           ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )    return  true; // inPt: Point on contour !
        // continue;
      }
    }

    return  inside;
  }


  var subPaths = extractSubpaths( this.actions );
  if ( subPaths.length == 0 ) return [];

  if ( noHoles === true ) return  toShapesNoHoles( subPaths );


  var solid, tmpPath, tmpShape, shapes = [];

  if ( subPaths.length == 1) {

    tmpPath = subPaths[0];
    tmpShape = new THREE.Shape();
    tmpShape.actions = tmpPath.actions;
    tmpShape.curves = tmpPath.curves;
    shapes.push( tmpShape );
    return shapes;

  }

  var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
  holesFirst = isCCW ? ! holesFirst : holesFirst;

  // console.log("Holes first", holesFirst);
  
  var betterShapeHoles = [];
  var newShapes = [];
  var newShapeHoles = [];
  var mainIdx = 0;
  var tmpPoints;

  newShapes[mainIdx] = undefined;
  newShapeHoles[mainIdx] = [];

  var i, il;

  for ( i = 0, il = subPaths.length; i < il; i ++ ) {

    tmpPath = subPaths[ i ];
    tmpPoints = tmpPath.getPoints();
    solid = THREE.Shape.Utils.isClockWise( tmpPoints );
    solid = isCCW ? ! solid : solid;

    if ( solid ) {

      if ( (! holesFirst ) && ( newShapes[mainIdx] ) )  mainIdx ++;

      newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
      newShapes[mainIdx].s.actions = tmpPath.actions;
      newShapes[mainIdx].s.curves = tmpPath.curves;
      
      if ( holesFirst ) mainIdx ++;
      newShapeHoles[mainIdx] = [];

      //console.log('cw', i);

    } else {

      newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

      //console.log('ccw', i);

    }

  }

  // only Holes? -> probably all Shapes with wrong orientation
  if ( ! newShapes[0] ) return  toShapesNoHoles( subPaths );


  if ( newShapes.length > 1 ) {
    var ambigious = false;
    var toChange = [];

    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
      betterShapeHoles[sIdx] = [];
    }
    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
      var sh = newShapes[sIdx];
      var sho = newShapeHoles[sIdx];
      for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
        var ho = sho[hIdx];
        var hole_unassigned = true;
        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
          if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
            if ( sIdx != s2Idx )    toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
            if ( hole_unassigned ) {
              hole_unassigned = false;
              betterShapeHoles[s2Idx].push( ho );
            } else {
              ambigious = true;
            }
          }
        }
        if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
      }
    }
    // console.log("ambigious: ", ambigious);
    if ( toChange.length > 0 ) {
      // console.log("to change: ", toChange);
      if (! ambigious)  newShapeHoles = betterShapeHoles;
    }
  }

  var tmpHoles, j, jl;
  for ( i = 0, il = newShapes.length; i < il; i ++ ) {
    tmpShape = newShapes[i].s;
    shapes.push( tmpShape );
    tmpHoles = newShapeHoles[i];
    for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
      tmpShape.holes.push( tmpHoles[j].h );
    }
  }

  //console.log("shape", shapes);

  return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

  THREE.Path.apply( this, arguments );
  this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

  var extruded = new THREE.ExtrudeGeometry( this, options );
  return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

  var geometry = new THREE.ShapeGeometry( this, options );
  return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

  var i, il = this.holes.length, holesPts = [];

  for ( i = 0; i < il; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

  }

  return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

  var i, il = this.holes.length, holesPts = [];

  for ( i = 0; i < il; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

  }

  return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

  return {

    shape: this.getTransformedPoints( divisions ),
    holes: this.getPointsHoles( divisions )

  };

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

  if (this.useSpacedPoints) {
    return this.extractAllSpacedPoints(divisions);
  }

  return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
//  return {
//
//    shape: this.transform( bend, divisions ),
//    holes: this.getPointsHoles( divisions, bend )
//
//  };
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

  return {

    shape: this.getTransformedSpacedPoints( divisions ),
    holes: this.getSpacedPointsHoles( divisions )

  };

};

/**************************************************************
 *  Utils
 **************************************************************/

THREE.Shape.Utils = {

  triangulateShape: function ( contour, holes ) {

    function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
      // inOtherPt needs to be colinear to the inSegment
      if ( inSegPt1.x != inSegPt2.x ) {
        if ( inSegPt1.x < inSegPt2.x ) {
          return  ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
        } else {
          return  ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
        }
      } else {
        if ( inSegPt1.y < inSegPt2.y ) {
          return  ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
        } else {
          return  ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
        }
      }
    }

    function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
      var EPSILON = 0.0000000001;

      var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
      var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

      var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
      var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

      var limit   = seg1dy * seg2dx - seg1dx * seg2dy;
      var perpSeg1  = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

      if ( Math.abs(limit) > EPSILON ) {      // not parallel

        var perpSeg2;
        if ( limit > 0 ) {
          if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) )     return [];
        } else {
          if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) )     return [];
        }

        // i.e. to reduce rounding errors
        // intersection at endpoint of segment#1?
        if ( perpSeg2 == 0 ) {
          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )   return [];
          return  [ inSeg1Pt1 ];
        }
        if ( perpSeg2 == limit ) {
          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )   return [];
          return  [ inSeg1Pt2 ];
        }
        // intersection at endpoint of segment#2?
        if ( perpSeg1 == 0 )    return  [ inSeg2Pt1 ];
        if ( perpSeg1 == limit )  return  [ inSeg2Pt2 ];

        // return real intersection point
        var factorSeg1 = perpSeg2 / limit;
        return  [ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

      } else {    // parallel or colinear
        if ( ( perpSeg1 != 0 ) ||
           ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) )       return [];

        // they are collinear or degenerate
        var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );  // segment1 ist just a point?
        var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );  // segment2 ist just a point?
        // both segments are points
        if ( seg1Pt && seg2Pt ) {
          if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
             (inSeg1Pt1.y != inSeg2Pt1.y) )   return [];    // they are distinct  points
          return  [ inSeg1Pt1 ];                          // they are the same point
        }
        // segment#1  is a single point
        if ( seg1Pt ) {
          if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )    return [];    // but not in segment#2
          return  [ inSeg1Pt1 ];
        }
        // segment#2  is a single point
        if ( seg2Pt ) {
          if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )    return [];    // but not in segment#1
          return  [ inSeg2Pt1 ];
        }

        // they are collinear segments, which might overlap
        var seg1min, seg1max, seg1minVal, seg1maxVal;
        var seg2min, seg2max, seg2minVal, seg2maxVal;
        if (seg1dx != 0) {    // the segments are NOT on a vertical line
          if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
          } else {
            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
          }
          if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
          } else {
            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
          }
        } else {        // the segments are on a vertical line
          if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
          } else {
            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
          }
          if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
          } else {
            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
          }
        }
        if ( seg1minVal <= seg2minVal ) {
          if ( seg1maxVal <  seg2minVal ) return [];
          if ( seg1maxVal == seg2minVal ) {
            if ( inExcludeAdjacentSegs )    return [];
            return [ seg2min ];
          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
          return  [ seg2min, seg2max ];
        } else {
          if ( seg1minVal >  seg2maxVal ) return [];
          if ( seg1minVal == seg2maxVal ) {
            if ( inExcludeAdjacentSegs )    return [];
            return [ seg1min ];
          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
          return  [ seg1min, seg2max ];
        }
      }
    }

    function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
      // The order of legs is important

      var EPSILON = 0.0000000001;

      // translation of all points, so that Vertex is at (0,0)
      var legFromPtX  = inLegFromPt.x - inVertex.x,  legFromPtY = inLegFromPt.y - inVertex.y;
      var legToPtX  = inLegToPt.x - inVertex.x,  legToPtY   = inLegToPt.y - inVertex.y;
      var otherPtX  = inOtherPt.x - inVertex.x,  otherPtY   = inOtherPt.y - inVertex.y;

      // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
      var from2toAngle  = legFromPtX * legToPtY - legFromPtY * legToPtX;
      var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

      if ( Math.abs(from2toAngle) > EPSILON ) {     // angle != 180 deg.

        var other2toAngle   = otherPtX * legToPtY - otherPtY * legToPtX;
        // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

        if ( from2toAngle > 0 ) {       // main angle < 180 deg.
          return  ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
        } else {                // main angle > 180 deg.
          return  ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
        }
      } else {                    // angle == 180 deg.
        // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
        return  ( from2otherAngle > 0 );
      }
    }


    function removeHoles( contour, holes ) {

      var shape = contour.concat(); // work on this shape
      var hole;

      function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
        // Check if hole point lies within angle around shape point
        var lastShapeIdx = shape.length - 1;

        var prevShapeIdx = inShapeIdx - 1;
        if ( prevShapeIdx < 0 )     prevShapeIdx = lastShapeIdx;

        var nextShapeIdx = inShapeIdx + 1;
        if ( nextShapeIdx > lastShapeIdx )  nextShapeIdx = 0;

        var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
        if (! insideAngle ) {
          // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
          return  false;
        }

        // Check if shape point lies within angle around hole point
        var lastHoleIdx = hole.length - 1;

        var prevHoleIdx = inHoleIdx - 1;
        if ( prevHoleIdx < 0 )      prevHoleIdx = lastHoleIdx;

        var nextHoleIdx = inHoleIdx + 1;
        if ( nextHoleIdx > lastHoleIdx )  nextHoleIdx = 0;

        insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
        if (! insideAngle ) {
          // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
          return  false;
        }

        return  true;
      }

      function intersectsShapeEdge( inShapePt, inHolePt ) {
        // checks for intersections with shape edges
        var sIdx, nextIdx, intersection;
        for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
          nextIdx = sIdx+1; nextIdx %= shape.length;
          intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
          if ( intersection.length > 0 )    return  true;
        }

        return  false;
      }

      var indepHoles = [];

      function intersectsHoleEdge( inShapePt, inHolePt ) {
        // checks for intersections with hole edges
        var ihIdx, chkHole,
          hIdx, nextIdx, intersection;
        for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
          chkHole = holes[indepHoles[ihIdx]];
          for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
            nextIdx = hIdx+1; nextIdx %= chkHole.length;
            intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
            if ( intersection.length > 0 )    return  true;
          }
        }
        return  false;
      }

      var holeIndex, shapeIndex,
        shapePt, holePt,
        holeIdx, cutKey, failedCuts = [],
        tmpShape1, tmpShape2,
        tmpHole1, tmpHole2;

      for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

        indepHoles.push( h );

      }

      var minShapeIndex = 0;
      var counter = indepHoles.length * 2;
      while ( indepHoles.length > 0 ) {
        counter --;
        if ( counter < 0 ) {
          console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
          break;
        }

        // search for shape-vertex and hole-vertex,
        // which can be connected without intersections
        for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

          shapePt = shape[ shapeIndex ];
          holeIndex = - 1;

          // search for hole which can be reached without intersections
          for ( var h = 0; h < indepHoles.length; h ++ ) {
            holeIdx = indepHoles[h];

            // prevent multiple checks
            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
            if ( failedCuts[cutKey] !== undefined )     continue;

            hole = holes[holeIdx];
            for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
              holePt = hole[ h2 ];
              if (! isCutLineInsideAngles( shapeIndex, h2 ) )   continue;
              if ( intersectsShapeEdge( shapePt, holePt ) )   continue;
              if ( intersectsHoleEdge( shapePt, holePt ) )    continue;

              holeIndex = h2;
              indepHoles.splice(h,1);

              tmpShape1 = shape.slice( 0, shapeIndex+1 );
              tmpShape2 = shape.slice( shapeIndex );
              tmpHole1 = hole.slice( holeIndex );
              tmpHole2 = hole.slice( 0, holeIndex+1 );

              shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

              minShapeIndex = shapeIndex;

              // Debug only, to show the selected cuts
              // glob_CutLines.push( [ shapePt, holePt ] );

              break;
            }
            if ( holeIndex >= 0 ) break;    // hole-vertex found

            failedCuts[cutKey] = true;      // remember failure
          }
          if ( holeIndex >= 0 ) break;    // hole-vertex found
        }
      }

      return shape;       /* shape with no holes */
    }


    var i, il, f, face,
      key, index,
      allPointsMap = {};

    // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    var allpoints = contour.concat();

    for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

      Array.prototype.push.apply( allpoints, holes[h] );

    }

    //console.log( "allpoints",allpoints, allpoints.length );

    // prepare all points map

    for ( i = 0, il = allpoints.length; i < il; i ++ ) {

      key = allpoints[ i ].x + ":" + allpoints[ i ].y;

      if ( allPointsMap[ key ] !== undefined ) {

        console.log( "Duplicate point", key );

      }

      allPointsMap[ key ] = i;

    }

    // remove holes by cutting paths to holes and adding them to the shape
    var shapeWithoutHoles = removeHoles( contour, holes );

    var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    //console.log( "triangles",triangles, triangles.length );

    // check all face vertices against all points map

    for ( i = 0, il = triangles.length; i < il; i ++ ) {

      face = triangles[ i ];

      for ( f = 0; f < 3; f ++ ) {

        key = face[ f ].x + ":" + face[ f ].y;

        index = allPointsMap[ key ];

        if ( index !== undefined ) {

          face[ f ] = index;

        }

      }

    }

    return triangles.concat();

  },

  isClockWise: function ( pts ) {

    return THREE.FontUtils.Triangulate.area( pts ) < 0;

  },

  // Bezier Curves formulas obtained from
  // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

  // Quad Bezier Functions

  b2p0: function ( t, p ) {

    var k = 1 - t;
    return k * k * p;

  },

  b2p1: function ( t, p ) {

    return 2 * ( 1 - t ) * t * p;

  },

  b2p2: function ( t, p ) {

    return t * t * p;

  },

  b2: function ( t, p0, p1, p2 ) {

    return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

  },

  // Cubic Bezier Functions

  b3p0: function ( t, p ) {

    var k = 1 - t;
    return k * k * k * p;

  },

  b3p1: function ( t, p ) {

    var k = 1 - t;
    return 3 * k * k * t * p;

  },

  b3p2: function ( t, p ) {

    var k = 1 - t;
    return 3 * k * t * t * p;

  },

  b3p3: function ( t, p ) {

    return t * t * t * p;

  },

  b3: function ( t, p0, p1, p2, p3 ) {

    return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

  }

};


// File:src/extras/curves/LineCurve.js

/**************************************************************
 *  Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

  this.v1 = v1;
  this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

  var point = this.v2.clone().sub(this.v1);
  point.multiplyScalar( t ).add( this.v1 );

  return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

  return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

  var tangent = this.v2.clone().sub(this.v1);

  return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *  Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

  var vector = new THREE.Vector2();

  vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
  vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

  return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

  var vector = new THREE.Vector2();

  vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
  vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

  // returns unit vector

  return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *  Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

  var tx, ty;

  tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
  ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

  return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

  var tx, ty;

  tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
  ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

  var tangent = new THREE.Vector2( tx, ty );
  tangent.normalize();

  return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *  Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

  this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

  var points = this.points;
  var point = ( points.length - 1 ) * t;

  var intPoint = Math.floor( point );
  var weight = point - intPoint;

  var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
  var point1 = points[ intPoint ]
  var point2 = points[ intPoint > points.length - 2 ? points.length -1 : intPoint + 1 ]
  var point3 = points[ intPoint > points.length - 3 ? points.length -1 : intPoint + 2 ]

  var vector = new THREE.Vector2();

  vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
  vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

  return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *  Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

  this.aX = aX;
  this.aY = aY;

  this.xRadius = xRadius;
  this.yRadius = yRadius;

  this.aStartAngle = aStartAngle;
  this.aEndAngle = aEndAngle;

  this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

  var deltaAngle = this.aEndAngle - this.aStartAngle;

  if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
  if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

  var angle;

  if ( this.aClockwise === true ) {

    angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

  } else {

    angle = this.aStartAngle + t * deltaAngle;

  }
  
  var vector = new THREE.Vector2();

  vector.x = this.aX + this.xRadius * Math.cos( angle );
  vector.y = this.aY + this.yRadius * Math.sin( angle );

  return vector;

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *  Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *  Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

  function ( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.subVectors( this.v2, this.v1 ); // diff
    vector.multiplyScalar( t );
    vector.add( this.v1 );

    return vector;

  }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *  Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
    vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

    return vector;

  }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *  Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
    vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

    return vector;

  }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *  Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */) {

    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var vector = new THREE.Vector3();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
    vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

    return vector;

  }

);

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *  Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */) {

    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    var point0 = points[ ( intPoint - 1 ) % points.length ];
    var point1 = points[ ( intPoint     ) % points.length ];
    var point2 = points[ ( intPoint + 1 ) % points.length ];
    var point3 = points[ ( intPoint + 2 ) % points.length ];

    var vector = new THREE.Vector3();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
    vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

    return vector;

  }

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

  LINEAR: 0,
  CATMULLROM: 1,
  CATMULLROM_FORWARD: 2,

  //

  add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
  get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
  remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

  //

  animations: [],

  init: function ( data ) {

    if ( data.initialized === true ) return;

    // loop through all keys

    for ( var h = 0; h < data.hierarchy.length; h ++ ) {

      for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

        // remove minus times

        if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

           data.hierarchy[ h ].keys[ k ].time = 0;

        }

        // create quaternions

        if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
          ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

          var quat = data.hierarchy[ h ].keys[ k ].rot;
          data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

        }

      }

      // prepare morph target keys

      if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

        // get all used

        var usedMorphTargets = {};

        for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

          for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

            var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
            usedMorphTargets[ morphTargetName ] = - 1;

          }

        }

        data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


        // set all used on all frames

        for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

          var influences = {};

          for ( var morphTargetName in usedMorphTargets ) {

            for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

              if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

                influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
                break;

              }

            }

            if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

              influences[ morphTargetName ] = 0;

            }

          }

          data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

        }

      }


      // remove all keys that are on the same time

      for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

        if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

          data.hierarchy[ h ].keys.splice( k, 1 );
          k --;

        }

      }


      // set index

      for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

        data.hierarchy[ h ].keys[ k ].index = k;

      }

    }

    data.initialized = true;

    return data;

  },

  parse: function ( root ) {

    var parseRecurseHierarchy = function ( root, hierarchy ) {

      hierarchy.push( root );

      for ( var c = 0; c < root.children.length; c ++ )
        parseRecurseHierarchy( root.children[ c ], hierarchy );

    };

    // setup hierarchy

    var hierarchy = [];

    if ( root instanceof THREE.SkinnedMesh ) {

      for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

        hierarchy.push( root.skeleton.bones[ b ] );

      }

    } else {

      parseRecurseHierarchy( root, hierarchy );

    }

    return hierarchy;

  },

  play: function ( animation ) {

    if ( this.animations.indexOf( animation ) === - 1 ) {

      this.animations.push( animation );

    }

  },

  stop: function ( animation ) {

    var index = this.animations.indexOf( animation );

    if ( index !== - 1 ) {

      this.animations.splice( index, 1 );

    }

  },

  update: function ( deltaTimeMS ) {

    for ( var i = 0; i < this.animations.length; i ++ ) {

      this.animations[ i ].resetBlendWeights( );

    }

    for ( var i = 0; i < this.animations.length; i ++ ) {

      this.animations[ i ].update( deltaTimeMS );

    }

  }

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, data ) {

  this.root = root;
  this.data = THREE.AnimationHandler.init( data );
  this.hierarchy = THREE.AnimationHandler.parse( root );

  this.currentTime = 0;
  this.timeScale = 1;

  this.isPlaying = false;
  this.loop = true;
  this.weight = 0;

  this.interpolationType = THREE.AnimationHandler.LINEAR;

};


THREE.Animation.prototype.keyTypes = [ "pos", "rot", "scl" ];


THREE.Animation.prototype.play = function ( startTime, weight ) {

  this.currentTime = startTime !== undefined ? startTime : 0;
  this.weight = weight !== undefined ? weight: 1;

  this.isPlaying = true;

  this.reset();

  THREE.AnimationHandler.play( this );

};


THREE.Animation.prototype.stop = function() {

  this.isPlaying = false;

  THREE.AnimationHandler.stop( this );

};

THREE.Animation.prototype.reset = function () {

  for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

    var object = this.hierarchy[ h ];

    object.matrixAutoUpdate = true;

    if ( object.animationCache === undefined ) {

      object.animationCache = {
        animations: {},
        blending: {
          positionWeight: 0.0,
          quaternionWeight: 0.0,
          scaleWeight: 0.0
        }
      };
    }

    if ( object.animationCache.animations[this.data.name] === undefined ) {

      object.animationCache.animations[this.data.name] = {};
      object.animationCache.animations[this.data.name].prevKey = { pos: 0, rot: 0, scl: 0 };
      object.animationCache.animations[this.data.name].nextKey = { pos: 0, rot: 0, scl: 0 };
      object.animationCache.animations[this.data.name].originalMatrix = object.matrix;

    }

    var animationCache = object.animationCache.animations[this.data.name];

    // Get keys to match our current time

    for ( var t = 0; t < 3; t ++ ) {

      var type = this.keyTypes[ t ];

      var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
      var nextKey = this.getNextKeyWith( type, h, 1 );

      while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

        prevKey = nextKey;
        nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

      }

      animationCache.prevKey[ type ] = prevKey;
      animationCache.nextKey[ type ] = nextKey;

    }

  }

};

THREE.Animation.prototype.resetBlendWeights = function () {

  for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

    var object = this.hierarchy[ h ];

    if ( object.animationCache !== undefined ) {

      object.animationCache.blending.positionWeight = 0.0;
      object.animationCache.blending.quaternionWeight = 0.0;
      object.animationCache.blending.scaleWeight = 0.0;

    }

  }

};

THREE.Animation.prototype.update = (function(){

  var points = [];
  var target = new THREE.Vector3();
  var newVector = new THREE.Vector3();
  var newQuat = new THREE.Quaternion();

  // Catmull-Rom spline

  var interpolateCatmullRom = function ( points, scale ) {

    var c = [], v3 = [],
    point, intPoint, weight, w2, w3,
    pa, pb, pc, pd;

    point = ( points.length - 1 ) * scale;
    intPoint = Math.floor( point );
    weight = point - intPoint;

    c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    c[ 1 ] = intPoint;
    c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
    c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

    pa = points[ c[ 0 ] ];
    pb = points[ c[ 1 ] ];
    pc = points[ c[ 2 ] ];
    pd = points[ c[ 3 ] ];

    w2 = weight * weight;
    w3 = weight * w2;

    v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
    v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
    v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

    return v3;

  };

  var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

    var v0 = ( p2 - p0 ) * 0.5,
      v1 = ( p3 - p1 ) * 0.5;

    return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  };

  return function ( delta ) {

    if ( this.isPlaying === false ) return;

    this.currentTime += delta * this.timeScale;

    if ( this.weight === 0 )
      return;

    //

    var duration = this.data.length;

    if ( this.currentTime > duration || this.currentTime < 0 ) {

      if ( this.loop ) {

        this.currentTime %= duration;

        if ( this.currentTime < 0 )
          this.currentTime += duration;

        this.reset();

      } else {

        this.stop();
        return;

      }

    }

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];
      var animationCache = object.animationCache.animations[this.data.name];
      var blending = object.animationCache.blending;

      // loop through pos/rot/scl

      for ( var t = 0; t < 3; t ++ ) {

        // get keys

        var type    = this.keyTypes[ t ];
        var prevKey = animationCache.prevKey[ type ];
        var nextKey = animationCache.nextKey[ type ];

        if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
          ( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

          prevKey = this.data.hierarchy[ h ].keys[ 0 ];
          nextKey = this.getNextKeyWith( type, h, 1 );

          while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

            prevKey = nextKey;
            nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

          }

          animationCache.prevKey[ type ] = prevKey;
          animationCache.nextKey[ type ] = nextKey;

        }

        object.matrixAutoUpdate = true;
        object.matrixWorldNeedsUpdate = true;

        var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

        var prevXYZ = prevKey[ type ];
        var nextXYZ = nextKey[ type ];

        if ( scale < 0 ) scale = 0;
        if ( scale > 1 ) scale = 1;

        // interpolate

        if ( type === "pos" ) {

          if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

            newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
            newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
            newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

            // blend
            var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
            object.position.lerp( newVector, proportionalWeight );
            blending.positionWeight += this.weight;

          } else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
                this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

            points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
            points[ 1 ] = prevXYZ;
            points[ 2 ] = nextXYZ;
            points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

            scale = scale * 0.33 + 0.33;

            var currentPoint = interpolateCatmullRom( points, scale );
            var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
            blending.positionWeight += this.weight;

            // blend

            var vector = object.position;
            
            vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
            vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
            vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

            if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

              var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

              target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
              target.sub( vector );
              target.y = 0;
              target.normalize();

              var angle = Math.atan2( target.x, target.z );
              object.rotation.set( 0, angle, 0 );

            }

          }

        } else if ( type === "rot" ) {

          THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

          // Avoid paying the cost of an additional slerp if we don't have to
          if ( blending.quaternionWeight === 0 ) {

            object.quaternion.copy(newQuat);
            blending.quaternionWeight = this.weight;

          } else {

            var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
            THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
            blending.quaternionWeight += this.weight;

          }

        } else if ( type === "scl" ) {

          newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
          newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
          newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

          var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
          object.scale.lerp( newVector, proportionalWeight );
          blending.scaleWeight += this.weight;

        }

      }

    }

    return true;

  };

})();





// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

  var keys = this.data.hierarchy[ h ].keys;

  if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
     this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

    key = key < keys.length - 1 ? key : keys.length - 1;

  } else {

    key = key % keys.length;

  }

  for ( ; key < keys.length; key ++ ) {

    if ( keys[ key ][ type ] !== undefined ) {

      return keys[ key ];

    }

  }

  return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

  var keys = this.data.hierarchy[ h ].keys;

  if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

    key = key > 0 ? key : 0;

  } else {

    key = key >= 0 ? key : key + keys.length;

  }


  for ( ; key >= 0; key -- ) {

    if ( keys[ key ][ type ] !== undefined ) {

      return keys[ key ];

    }

  }

  return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( data ) {

  this.root = data.node;
  this.data = THREE.AnimationHandler.init( data );
  this.hierarchy = THREE.AnimationHandler.parse( this.root );
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = false;
  this.isPaused = true;
  this.loop = true;

  // initialize to first keyframes

  for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

    var keys = this.data.hierarchy[h].keys,
      sids = this.data.hierarchy[h].sids,
      obj = this.hierarchy[h];

    if ( keys.length && sids ) {

      for ( var s = 0; s < sids.length; s ++ ) {

        var sid = sids[ s ],
          next = this.getNextKeyWith( sid, h, 0 );

        if ( next ) {

          next.apply( sid );

        }

      }

      obj.matrixAutoUpdate = false;
      this.data.hierarchy[h].node.updateMatrix();
      obj.matrixWorldNeedsUpdate = true;

    }

  }

};


THREE.KeyFrameAnimation.prototype.play = function ( startTime ) {

  this.currentTime = startTime !== undefined ? startTime : 0;

  if ( this.isPlaying === false ) {

    this.isPlaying = true;

    // reset key cache

    var h, hl = this.hierarchy.length,
      object,
      node;

    for ( h = 0; h < hl; h ++ ) {

      object = this.hierarchy[ h ];
      node = this.data.hierarchy[ h ];

      if ( node.animationCache === undefined ) {

        node.animationCache = {};
        node.animationCache.prevKey = null;
        node.animationCache.nextKey = null;
        node.animationCache.originalMatrix = object.matrix;

      }

      var keys = this.data.hierarchy[h].keys;

      if (keys.length) {

        node.animationCache.prevKey = keys[ 0 ];
        node.animationCache.nextKey = keys[ 1 ];

        this.startTime = Math.min( keys[0].time, this.startTime );
        this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

      }

    }

    this.update( 0 );

  }

  this.isPaused = false;

  THREE.AnimationHandler.play( this );

};


THREE.KeyFrameAnimation.prototype.stop = function() {

  this.isPlaying = false;
  this.isPaused  = false;

  THREE.AnimationHandler.stop( this );

  // reset JIT matrix and remove cache

  for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {
    
    var obj = this.hierarchy[ h ];
    var node = this.data.hierarchy[ h ];

    if ( node.animationCache !== undefined ) {

      var original = node.animationCache.originalMatrix;

      original.copy( obj.matrix );
      obj.matrix = original;

      delete node.animationCache;

    }

  }

};


// Update

THREE.KeyFrameAnimation.prototype.update = function ( delta ) {

  if ( this.isPlaying === false ) return;

  this.currentTime += delta * this.timeScale;

  //

  var duration = this.data.length;

  if ( this.loop === true && this.currentTime > duration ) {

    this.currentTime %= duration;

  }

  this.currentTime = Math.min( this.currentTime, duration );

  for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

    var object = this.hierarchy[ h ];
    var node = this.data.hierarchy[ h ];

    var keys = node.keys,
      animationCache = node.animationCache;


    if ( keys.length ) {

      var prevKey = animationCache.prevKey;
      var nextKey = animationCache.nextKey;

      if ( nextKey.time <= this.currentTime ) {

        while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

          prevKey = nextKey;
          nextKey = keys[ prevKey.index + 1 ];

        }

        animationCache.prevKey = prevKey;
        animationCache.nextKey = nextKey;

      }

      if ( nextKey.time >= this.currentTime ) {

        prevKey.interpolate( nextKey, this.currentTime );

      } else {

        prevKey.interpolate( nextKey, nextKey.time );

      }

      this.data.hierarchy[ h ].node.updateMatrix();
      object.matrixWorldNeedsUpdate = true;

    }

  }

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

  var keys = this.data.hierarchy[ h ].keys;
  key = key % keys.length;

  for ( ; key < keys.length; key ++ ) {

    if ( keys[ key ].hasTarget( sid ) ) {

      return keys[ key ];

    }

  }

  return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

  var keys = this.data.hierarchy[ h ].keys;
  key = key >= 0 ? key : key + keys.length;

  for ( ; key >= 0; key -- ) {

    if ( keys[ key ].hasTarget( sid ) ) {

      return keys[ key ];

    }

  }

  return keys[ keys.length - 1 ];

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 */

THREE.MorphAnimation = function ( mesh ) {

  this.mesh = mesh;
  this.frames = mesh.morphTargetInfluences.length;
  this.currentTime = 0;
  this.duration = 1000;
  this.loop = true;

  this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

  play: function () {

    this.isPlaying = true;

  },

  pause: function () {

    this.isPlaying = false;

  },

  update: ( function () {

    var lastFrame = 0;
    var currentFrame = 0;

    return function ( delta ) {

      if ( this.isPlaying === false ) return;

      this.currentTime += delta;

      if ( this.loop === true && this.currentTime > this.duration ) {

        this.currentTime %= this.duration;

      }

      this.currentTime = Math.min( this.currentTime, this.duration );

      var interpolation = this.duration / this.frames;
      var frame = Math.floor( this.currentTime / interpolation );

      if ( frame != currentFrame ) {

        this.mesh.morphTargetInfluences[ lastFrame ] = 0;
        this.mesh.morphTargetInfluences[ currentFrame ] = 1;
        this.mesh.morphTargetInfluences[ frame ] = 0;

        lastFrame = currentFrame;
        currentFrame = frame;

      }

      this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
      this.mesh.morphTargetInfluences[ lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];

    }

  } )()

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  THREE.Geometry.call( this );

  this.type = 'BoxGeometry';

  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };

  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  this.depthSegments = depthSegments || 1;

  var scope = this;

  var width_half = width / 2;
  var height_half = height / 2;
  var depth_half = depth / 2;

  buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
  buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
  buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
  buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
  buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
  buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

  function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

    var w, ix, iy,
    gridX = scope.widthSegments,
    gridY = scope.heightSegments,
    width_half = width / 2,
    height_half = height / 2,
    offset = scope.vertices.length;

    if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

      w = 'z';

    } else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

      w = 'y';
      gridY = scope.depthSegments;

    } else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

      w = 'x';
      gridX = scope.depthSegments;

    }

    var gridX1 = gridX + 1,
    gridY1 = gridY + 1,
    segment_width = width / gridX,
    segment_height = height / gridY,
    normal = new THREE.Vector3();

    normal[ w ] = depth > 0 ? 1 : - 1;

    for ( iy = 0; iy < gridY1; iy ++ ) {

      for ( ix = 0; ix < gridX1; ix ++ ) {

        var vector = new THREE.Vector3();
        vector[ u ] = ( ix * segment_width - width_half ) * udir;
        vector[ v ] = ( iy * segment_height - height_half ) * vdir;
        vector[ w ] = depth;

        scope.vertices.push( vector );

      }

    }

    for ( iy = 0; iy < gridY; iy ++ ) {

      for ( ix = 0; ix < gridX; ix ++ ) {

        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * ( iy + 1 );
        var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
        var d = ( ix + 1 ) + gridX1 * iy;

        var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
        var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
        var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
        var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

        var face = new THREE.Face3( a + offset, b + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
        face.materialIndex = materialIndex;

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

        face = new THREE.Face3( b + offset, c + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
        face.materialIndex = materialIndex;

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

      }

    }

  }

  this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CircleGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  var i, uvs = [],
  center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

  this.vertices.push(center);
  uvs.push( centerUV );

  for ( i = 0; i <= segments; i ++ ) {

    var vertex = new THREE.Vector3();
    var segment = thetaStart + i / segments * thetaLength;

    vertex.x = radius * Math.cos( segment );
    vertex.y = radius * Math.sin( segment );

    this.vertices.push( vertex );
    uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 1; i <= segments; i ++ ) {

    this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
    this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/CubeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  console.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
  return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );

 };

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

  THREE.Geometry.call( this );

  this.type = 'CylinderGeometry';

  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded
  };

  radiusTop = radiusTop !== undefined ? radiusTop : 20;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  height = height !== undefined ? height : 100;

  radialSegments = radialSegments || 8;
  heightSegments = heightSegments || 1;

  openEnded = openEnded !== undefined ? openEnded : false;

  var heightHalf = height / 2;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    var v = y / heightSegments;
    var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    for ( x = 0; x <= radialSegments; x ++ ) {

      var u = x / radialSegments;

      var vertex = new THREE.Vector3();
      vertex.x = radius * Math.sin( u * Math.PI * 2 );
      vertex.y = - v * height + heightHalf;
      vertex.z = radius * Math.cos( u * Math.PI * 2 );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  var tanTheta = ( radiusBottom - radiusTop ) / height;
  var na, nb;

  for ( x = 0; x < radialSegments; x ++ ) {

    if ( radiusTop !== 0 ) {

      na = this.vertices[ vertices[ 0 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

    } else {

      na = this.vertices[ vertices[ 1 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

    }

    na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
    nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

    for ( y = 0; y < heightSegments; y ++ ) {

      var v1 = vertices[ y ][ x ];
      var v2 = vertices[ y + 1 ][ x ];
      var v3 = vertices[ y + 1 ][ x + 1 ];
      var v4 = vertices[ y ][ x + 1 ];

      var n1 = na.clone();
      var n2 = na.clone();
      var n3 = nb.clone();
      var n4 = nb.clone();

      var uv1 = uvs[ y ][ x ].clone();
      var uv2 = uvs[ y + 1 ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
      var uv4 = uvs[ y ][ x + 1 ].clone();

      this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

      this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

    }

  }

  // top cap

  if ( openEnded === false && radiusTop > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ 0 ][ x ];
      var v2 = vertices[ 0 ][ x + 1 ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, 1, 0 );
      var n2 = new THREE.Vector3( 0, 1, 0 );
      var n3 = new THREE.Vector3( 0, 1, 0 );

      var uv1 = uvs[ 0 ][ x ].clone();
      var uv2 = uvs[ 0 ][ x + 1 ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 0 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  // bottom cap

  if ( openEnded === false && radiusBottom > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ y ][ x + 1 ];
      var v2 = vertices[ y ][ x ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, - 1, 0 );
      var n2 = new THREE.Vector3( 0, - 1, 0 );
      var n3 = new THREE.Vector3( 0, - 1, 0 );

      var uv1 = uvs[ y ][ x + 1 ].clone();
      var uv2 = uvs[ y ][ x ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 1 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

  if ( typeof( shapes ) === "undefined" ) {
    shapes = [];
    return;
  }

  THREE.Geometry.call( this );

  this.type = 'ExtrudeGeometry';

  shapes = shapes instanceof Array ? shapes : [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

  // can't really use automatic vertex normals
  // as then front and back sides get smoothed too
  // should do separate smoothing just for sides

  //this.computeVertexNormals();

  //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
  var sl = shapes.length;

  for ( var s = 0; s < sl; s ++ ) {
    var shape = shapes[ s ];
    this.addShape( shape, options );
  }
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

  var amount = options.amount !== undefined ? options.amount : 100;

  var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
  var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
  var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var steps = options.steps !== undefined ? options.steps : 1;

  var extrudePath = options.extrudePath;
  var extrudePts, extrudeByPath = false;

  var material = options.material;
  var extrudeMaterial = options.extrudeMaterial;

  // Use default WorldUVGenerator if no UV generators are specified.
  var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

  var splineTube, binormal, normal, position2;
  if ( extrudePath ) {

    extrudePts = extrudePath.getSpacedPoints( steps );

    extrudeByPath = true;
    bevelEnabled = false; // bevels not supported for path extrusion

    // SETUP TNB variables

    // Reuse TNB from TubeGeomtry for now.
    // TODO1 - have a .isClosed in spline?

    splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

    // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    binormal = new THREE.Vector3();
    normal = new THREE.Vector3();
    position2 = new THREE.Vector3();

  }

  // Safeguards if bevels are not enabled

  if ( ! bevelEnabled ) {

    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;

  }

  // Variables initalization

  var ahole, h, hl; // looping of holes
  var scope = this;
  var bevelPoints = [];

  var shapesOffset = this.vertices.length;

  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe ...

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];

      if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

        holes[ h ] = ahole.reverse();

      }

    }

    reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

  }


  var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

  /* Vertices */

  var contour = vertices; // vertices has all points but contour has only points of circumference

  for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

    ahole = holes[ h ];

    vertices = vertices.concat( ahole );

  }


  function scalePt2 ( pt, vec, size ) {

    if ( ! vec ) console.log( "die" );

    return vec.clone().multiplyScalar( size ).add( pt );

  }

  var b, bs, t, z,
    vert, vlen = vertices.length,
    face, flen = faces.length,
    cont, clen = contour.length;


  // Find directions for point movement

  var RAD_TO_DEGREES = 180 / Math.PI;


  function getBevelVec( inPt, inPrev, inNext ) {

    var EPSILON = 0.0000000001;
    
    // computes for inPt the corresponding point inPt' on a new contour
    //   shiftet by 1 unit (length of normalized vector) to the left
    // if we walk along contour clockwise, this new contour is outside the old one
    //
    // inPt' is the intersection of the two lines parallel to the two
    //  adjacent edges of inPt at a distance of 1 unit on the left side.
    
    var v_trans_x, v_trans_y, shrink_by = 1;    // resulting translation vector for inPt

    // good reading for geometry algorithms (here: line-line intersection)
    // http://geomalgorithms.com/a05-_intersect-1.html

    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
    
    var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
    
    // check for colinear edges
    var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
    
    if ( Math.abs( colinear0 ) > EPSILON ) {    // not colinear
      
      // length of vectors for normalizing
  
      var v_prev_len = Math.sqrt( v_prev_lensq );
      var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
      
      // shift adjacent points by unit vectors to the left
  
      var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
      var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
      
      var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
      var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
  
      // scaling factor for v_prev to intersection point
  
      var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
            ( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
            ( v_prev_x * v_next_y - v_prev_y * v_next_x );
  
      // vector from inPt to intersection point
  
      v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
      v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
  
      // Don't normalize!, otherwise sharp corners become ugly
      //  but prevent crazy spikes
      var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
      if ( v_trans_lensq <= 2 ) {
        return  new THREE.Vector2( v_trans_x, v_trans_y );
      } else {
        shrink_by = Math.sqrt( v_trans_lensq / 2 );
      }
      
    } else {    // handle special case of colinear edges

      var direction_eq = false;   // assumes: opposite
      if ( v_prev_x > EPSILON ) {
        if ( v_next_x > EPSILON ) { direction_eq = true; }
      } else {
        if ( v_prev_x < - EPSILON ) {
          if ( v_next_x < - EPSILON ) { direction_eq = true; }
        } else {
          if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
        }
      }

      if ( direction_eq ) {
        // console.log("Warning: lines are a straight sequence");
        v_trans_x = - v_prev_y;
        v_trans_y =  v_prev_x;
        shrink_by = Math.sqrt( v_prev_lensq );
      } else {
        // console.log("Warning: lines are a straight spike");
        v_trans_x = v_prev_x;
        v_trans_y = v_prev_y;
        shrink_by = Math.sqrt( v_prev_lensq / 2 );
      }

    }

    return  new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  }


  var contourMovements = [];

  for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    if ( j === il ) j = 0;
    if ( k === il ) k = 0;

    //  (j)---(i)---(k)
    // console.log('i,j,k', i, j , k)

    var pt_i = contour[ i ];
    var pt_j = contour[ j ];
    var pt_k = contour[ k ];

    contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  }

  var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    oneHoleMovements = [];

    for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

      if ( j === il ) j = 0;
      if ( k === il ) k = 0;

      //  (j)---(i)---(k)
      oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    }

    holesMovements.push( oneHoleMovements );
    verticesMovements = verticesMovements.concat( oneHoleMovements );

  }


  // Loop bevelSegments, 1 for the front, 1 for the back

  for ( b = 0; b < bevelSegments; b ++ ) {
  //for ( b = bevelSegments; b > 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );

    //z = bevelThickness * t;
    bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
    //bs = bevelSize * t ; // linear

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

      v( vert.x, vert.y,  - z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        v( vert.x, vert.y,  - z );

      }

    }

  }

  bs = bevelSize;

  // Back facing vertices

  for ( i = 0; i < vlen; i ++ ) {

    vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    if ( ! extrudeByPath ) {

      v( vert.x, vert.y, 0 );

    } else {

      // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

      normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
      binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

      position2.copy( extrudePts[0] ).add(normal).add(binormal);

      v( position2.x, position2.y, position2.z );

    }

  }

  // Add stepped vertices...
  // Including front facing vertices

  var s;

  for ( s = 1; s <= steps; s ++ ) {

    for ( i = 0; i < vlen; i ++ ) {

      vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

      if ( ! extrudeByPath ) {

        v( vert.x, vert.y, amount / steps * s );

      } else {

        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

        normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
        binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

        position2.copy( extrudePts[s] ).add( normal ).add( binormal );

        v( position2.x, position2.y, position2.z );

      }

    }

  }


  // Add bevel segments planes

  //for ( b = 1; b <= bevelSegments; b ++ ) {
  for ( b = bevelSegments - 1; b >= 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );
    //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
    bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
      v( vert.x, vert.y,  amount + z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        if ( ! extrudeByPath ) {

          v( vert.x, vert.y,  amount + z );

        } else {

          v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

        }

      }

    }

  }

  /* Faces */

  // Top and bottom faces

  buildLidFaces();

  // Sides faces

  buildSideFaces();


  /////  Internal functions

  function buildLidFaces() {

    if ( bevelEnabled ) {

      var layer = 0 ; // steps + 1
      var offset = vlen * layer;

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset );

      }

      layer = steps + bevelSegments * 2;
      offset = vlen * layer;

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

      }

    } else {

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ], face[ 1 ], face[ 0 ] );

      }

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

      }
    }

  }

  // Create faces for the z-sides of the shape

  function buildSideFaces() {

    var layeroffset = 0;
    sidewalls( contour, layeroffset );
    layeroffset += contour.length;

    for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

      ahole = holes[ h ];
      sidewalls( ahole, layeroffset );

      //, true
      layeroffset += ahole.length;

    }

  }

  function sidewalls( contour, layeroffset ) {

    var j, k;
    i = contour.length;

    while ( --i >= 0 ) {

      j = i;
      k = i - 1;
      if ( k < 0 ) k = contour.length - 1;

      //console.log('b', i,j, i-1, k,vertices.length);

      var s = 0, sl = steps  + bevelSegments * 2;

      for ( s = 0; s < sl; s ++ ) {

        var slen1 = vlen * s;
        var slen2 = vlen * ( s + 1 );

        var a = layeroffset + j + slen1,
          b = layeroffset + k + slen1,
          c = layeroffset + k + slen2,
          d = layeroffset + j + slen2;

        f4( a, b, c, d, contour, s, sl, j, k );

      }
    }

  }


  function v( x, y, z ) {

    scope.vertices.push( new THREE.Vector3( x, y, z ) );

  }

  function f3( a, b, c ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;

    // normal, color, material
    scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

    var uvs = uvgen.generateTopUV( scope, a, b, c );

    scope.faceVertexUvs[ 0 ].push( uvs );

  }

  function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    d += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
    scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

    var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

  }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

  generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];

    return [
      new THREE.Vector2( a.x, a.y ),
      new THREE.Vector2( b.x, b.y ),
      new THREE.Vector2( c.x, c.y )
    ];

  },

  generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];
    var d = vertices[ indexD ];

    if ( Math.abs( a.y - b.y ) < 0.01 ) {
      return [
        new THREE.Vector2( a.x, 1 - a.z ),
        new THREE.Vector2( b.x, 1 - b.z ),
        new THREE.Vector2( c.x, 1 - c.z ),
        new THREE.Vector2( d.x, 1 - d.z )
      ];
    } else {
      return [
        new THREE.Vector2( a.y, 1 - a.z ),
        new THREE.Vector2( b.y, 1 - b.z ),
        new THREE.Vector2( c.y, 1 - c.z ),
        new THREE.Vector2( d.y, 1 - d.z )
      ];
    }
  }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *  material: <int> // material index for front and back faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

  THREE.Geometry.call( this );

  this.type = 'ShapeGeometry';

  if ( shapes instanceof Array === false ) shapes = [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

  for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    this.addShape( shapes[ i ], options );

  }

  return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

  if ( options === undefined ) options = {};
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var material = options.material;
  var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

  //

  var i, l, hole, s;

  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe...

    for ( i = 0, l = holes.length; i < l; i ++ ) {

      hole = holes[ i ];

      if ( THREE.Shape.Utils.isClockWise( hole ) ) {

        holes[ i ] = hole.reverse();

      }

    }

    reverse = false;

  }

  var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

  // Vertices

  var contour = vertices;

  for ( i = 0, l = holes.length; i < l; i ++ ) {

    hole = holes[ i ];
    vertices = vertices.concat( hole );

  }

  //

  var vert, vlen = vertices.length;
  var face, flen = faces.length;
  var cont, clen = contour.length;

  for ( i = 0; i < vlen; i ++ ) {

    vert = vertices[ i ];

    this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

  }

  for ( i = 0; i < flen; i ++ ) {

    face = faces[ i ];

    var a = face[ 0 ] + shapesOffset;
    var b = face[ 1 ] + shapesOffset;
    var c = face[ 2 ] + shapesOffset;

    this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
    this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

  }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

  THREE.Geometry.call( this );

  this.type = 'LatheGeometry';

  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };

  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  var inversePointLength = 1.0 / ( points.length - 1 );
  var inverseSegments = 1.0 / segments;

  for ( var i = 0, il = segments; i <= il; i ++ ) {

    var phi = phiStart + i * inverseSegments * phiLength;

    var c = Math.cos( phi ),
      s = Math.sin( phi );

    for ( var j = 0, jl = points.length; j < jl; j ++ ) {

      var pt = points[ j ];

      var vertex = new THREE.Vector3();

      vertex.x = c * pt.x - s * pt.y;
      vertex.y = s * pt.x + c * pt.y;
      vertex.z = pt.z;

      this.vertices.push( vertex );

    }

  }

  var np = points.length;

  for ( var i = 0, il = segments; i < il; i ++ ) {

    for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

      var base = j + np * i;
      var a = base;
      var b = base + np;
      var c = base + 1 + np;
      var d = base + 1;

      var u0 = i * inverseSegments;
      var v0 = j * inversePointLength;
      var u1 = u0 + inverseSegments;
      var v1 = v0 + inversePointLength;

      this.faces.push( new THREE.Face3( a, b, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u0, v0 ),
        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u0, v1 )

      ] );

      this.faces.push( new THREE.Face3( b, c, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u1, v1 ),
        new THREE.Vector2( u0, v1 )

      ] );


    }

  }

  this.mergeVertices();
  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

  console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

  THREE.Geometry.call( this );

  this.type = 'PlaneGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

  THREE.BufferGeometry.call( this );

  this.type = 'PlaneBufferGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  var width_half = width / 2;
  var height_half = height / 2;

  var gridX = widthSegments || 1;
  var gridY = heightSegments || 1;

  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;

  var segment_width = width / gridX;
  var segment_height = height / gridY;

  var vertices = new Float32Array( gridX1 * gridY1 * 3 );
  var normals = new Float32Array( gridX1 * gridY1 * 3 );
  var uvs = new Float32Array( gridX1 * gridY1 * 2 );

  var offset = 0;
  var offset2 = 0;

  for ( var iy = 0; iy < gridY1; iy ++ ) {

    var y = iy * segment_height - height_half;

    for ( var ix = 0; ix < gridX1; ix ++ ) {

      var x = ix * segment_width - width_half;

      vertices[ offset     ] = x;
      vertices[ offset + 1 ] = - y;

      normals[ offset + 2 ] = 1;

      uvs[ offset2     ] = ix / gridX;
      uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

      offset += 3;
      offset2 += 2;

    }

  }

  offset = 0;

  var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

  for ( var iy = 0; iy < gridY; iy ++ ) {

    for ( var ix = 0; ix < gridX; ix ++ ) {

      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * ( iy + 1 );
      var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
      var d = ( ix + 1 ) + gridX1 * iy;

      indices[ offset     ] = a;
      indices[ offset + 1 ] = b;
      indices[ offset + 2 ] = d;

      indices[ offset + 3 ] = b;
      indices[ offset + 4 ] = c;
      indices[ offset + 5 ] = d;

      offset += 6;

    }

  }

  this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'RingGeometry';

  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  innerRadius = innerRadius || 0;
  outerRadius = outerRadius || 50;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

  var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

  for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

    for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

      var vertex = new THREE.Vector3();
      var segment = thetaStart + o / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos( segment );
      vertex.y = radius * Math.sin( segment );

      this.vertices.push( vertex );
      uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
    }

    radius += radiusStep;

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

    var thetaSegment = i * (thetaSegments + 1);

    for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

      var segment = o + thetaSegment;

      var v1 = segment;
      var v2 = segment + thetaSegments + 1;
      var v3 = segment + thetaSegments + 2;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

      v1 = segment;
      v2 = segment + thetaSegments + 2;
      v3 = segment + 1;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

    }
  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );


// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'SphereGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength 
  };

  radius = radius || 50;

  widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    for ( x = 0; x <= widthSegments; x ++ ) {

      var u = x / widthSegments;
      var v = y / heightSegments;

      var vertex = new THREE.Vector3();
      vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
      vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
      vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  for ( y = 0; y < heightSegments; y ++ ) {

    for ( x = 0; x < widthSegments; x ++ ) {

      var v1 = vertices[ y ][ x + 1 ];
      var v2 = vertices[ y ][ x ];
      var v3 = vertices[ y + 1 ][ x ];
      var v4 = vertices[ y + 1 ][ x + 1 ];

      var n1 = this.vertices[ v1 ].clone().normalize();
      var n2 = this.vertices[ v2 ].clone().normalize();
      var n3 = this.vertices[ v3 ].clone().normalize();
      var n4 = this.vertices[ v4 ].clone().normalize();

      var uv1 = uvs[ y ][ x + 1 ].clone();
      var uv2 = uvs[ y ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x ].clone();
      var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

      if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

        uv1.x = ( uv1.x + uv2.x ) / 2;
        this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

      } else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

        uv3.x = ( uv3.x + uv4.x ) / 2;
        this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

      } else {

        this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

        this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

      }

    }

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size:       <float>,  // size of the text
 *  height:     <float>,  // thickness to extrude text
 *  curveSegments:  <int>,    // number of points on the curves
 *
 *  font:       <string>,   // font name
 *  weight:     <string>,   // font weight (normal, bold)
 *  style:      <string>,   // font style  (normal, italics)
 *
 *  bevelEnabled: <bool>,     // turn on bevel
 *  bevelThickness: <float>,    // how deep into text bevel goes
 *  bevelSize:    <float>,    // how far from text outline is bevel
 *  }
 *
 */

/*  Usage Examples

  // TextGeometry wrapper

  var text3d = new TextGeometry( text, options );

  // Complete manner

  var textShapes = THREE.FontUtils.generateShapes( text, options );
  var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

  parameters = parameters || {};

  var textShapes = THREE.FontUtils.generateShapes( text, parameters );

  // translate parameters to ExtrudeGeometry API

  parameters.amount = parameters.height !== undefined ? parameters.height : 50;

  // defaults

  if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
  if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
  if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

  THREE.ExtrudeGeometry.call( this, textShapes, parameters );

  this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

  THREE.Geometry.call( this );

  this.type = 'TorusGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 8;
  tubularSegments = tubularSegments || 6;
  arc = arc || Math.PI * 2;

  var center = new THREE.Vector3(), uvs = [], normals = [];

  for ( var j = 0; j <= radialSegments; j ++ ) {

    for ( var i = 0; i <= tubularSegments; i ++ ) {

      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2;

      center.x = radius * Math.cos( u );
      center.y = radius * Math.sin( u );

      var vertex = new THREE.Vector3();
      vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
      vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
      vertex.z = tube * Math.sin( v );

      this.vertices.push( vertex );

      uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
      normals.push( vertex.clone().sub( center ).normalize() );

    }

  }

  for ( var j = 1; j <= radialSegments; j ++ ) {

    for ( var i = 1; i <= tubularSegments; i ++ ) {

      var a = ( tubularSegments + 1 ) * j + i - 1;
      var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
      var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
      var d = ( tubularSegments + 1 ) * j + i;

      var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

      face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

    }

  }

  this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

  THREE.Geometry.call( this );

  this.type = 'TorusKnotGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    p: p,
    q: q,
    heightScale: heightScale
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 64;
  tubularSegments = tubularSegments || 8;
  p = p || 2;
  q = q || 3;
  heightScale = heightScale || 1;
  
  var grid = new Array( radialSegments );
  var tang = new THREE.Vector3();
  var n = new THREE.Vector3();
  var bitan = new THREE.Vector3();

  for ( var i = 0; i < radialSegments; ++ i ) {

    grid[ i ] = new Array( tubularSegments );
    var u = i / radialSegments * 2 * p * Math.PI;
    var p1 = getPos( u, q, p, radius, heightScale );
    var p2 = getPos( u + 0.01, q, p, radius, heightScale );
    tang.subVectors( p2, p1 );
    n.addVectors( p2, p1 );

    bitan.crossVectors( tang, n );
    n.crossVectors( bitan, tang );
    bitan.normalize();
    n.normalize();

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var v = j / tubularSegments * 2 * Math.PI;
      var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      var cy = tube * Math.sin( v );

      var pos = new THREE.Vector3();
      pos.x = p1.x + cx * n.x + cy * bitan.x;
      pos.y = p1.y + cx * n.y + cy * bitan.y;
      pos.z = p1.z + cx * n.z + cy * bitan.z;

      grid[ i ][ j ] = this.vertices.push( pos ) - 1;

    }

  }

  for ( var i = 0; i < radialSegments; ++ i ) {

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var ip = ( i + 1 ) % radialSegments;
      var jp = ( j + 1 ) % tubularSegments;

      var a = grid[ i ][ j ];
      var b = grid[ ip ][ j ];
      var c = grid[ ip ][ jp ];
      var d = grid[ i ][ jp ];

      var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
      var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
      var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
      var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }
  }

  this.computeFaceNormals();
  this.computeVertexNormals();

  function getPos( u, in_q, in_p, radius, heightScale ) {

    var cu = Math.cos( u );
    var su = Math.sin( u );
    var quOverP = in_q / in_p * u;
    var cs = Math.cos( quOverP );

    var tx = radius * ( 2 + cs ) * 0.5 * cu;
    var ty = radius * ( 2 + cs ) * su * 0.5;
    var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

    return new THREE.Vector3( tx, ty, tz );

  }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed ) {

  THREE.Geometry.call( this );

  this.type = 'TubeGeometry';

  this.parameters = {
    path: path,
    segments: segments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };

  segments = segments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;

  var grid = [];

  var scope = this,

    tangent,
    normal,
    binormal,

    numpoints = segments + 1,

    x, y, z,
    tx, ty, tz,
    u, v,

    cx, cy,
    pos, pos2 = new THREE.Vector3(),
    i, j,
    ip, jp,
    a, b, c, d,
    uva, uvb, uvc, uvd;

  var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
    tangents = frames.tangents,
    normals = frames.normals,
    binormals = frames.binormals;

  // proxy internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  function vert( x, y, z ) {

    return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

  }

  // consruct the grid

  for ( i = 0; i < numpoints; i ++ ) {

    grid[ i ] = [];

    u = i / ( numpoints - 1 );

    pos = path.getPointAt( u );

    tangent = tangents[ i ];
    normal = normals[ i ];
    binormal = binormals[ i ];

    for ( j = 0; j < radialSegments; j ++ ) {

      v = j / radialSegments * 2 * Math.PI;

      cx = - radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      cy = radius * Math.sin( v );

      pos2.copy( pos );
      pos2.x += cx * normal.x + cy * binormal.x;
      pos2.y += cx * normal.y + cy * binormal.y;
      pos2.z += cx * normal.z + cy * binormal.z;

      grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    }
  }


  // construct the mesh

  for ( i = 0; i < segments; i ++ ) {

    for ( j = 0; j < radialSegments; j ++ ) {

      ip = ( closed ) ? (i + 1) % segments : i + 1;
      jp = (j + 1) % radialSegments;

      a = grid[ i ][ j ];   // *** NOT NECESSARILY PLANAR ! ***
      b = grid[ ip ][ j ];
      c = grid[ ip ][ jp ];
      d = grid[ i ][ jp ];

      uva = new THREE.Vector2( i / segments, j / radialSegments );
      uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
      uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
      uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }
  }

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

  var tangent = new THREE.Vector3(),
    normal = new THREE.Vector3(),
    binormal = new THREE.Vector3(),

    tangents = [],
    normals = [],
    binormals = [],

    vec = new THREE.Vector3(),
    mat = new THREE.Matrix4(),

    numpoints = segments + 1,
    theta,
    epsilon = 0.0001,
    smallest,

    tx, ty, tz,
    i, u, v;


  // expose internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  // compute the tangent vectors for each segment on the path

  for ( i = 0; i < numpoints; i ++ ) {

    u = i / ( numpoints - 1 );

    tangents[ i ] = path.getTangentAt( u );
    tangents[ i ].normalize();

  }

  initialNormal3();

  /*
  function initialNormal1(lastBinormal) {
    // fixed start binormal. Has dangers of 0 vectors
    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
  }

  function initialNormal2() {

    // This uses the Frenet-Serret formula for deriving binormal
    var t2 = path.getTangentAt( epsilon );

    normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

  }
  */

  function initialNormal3() {
    // select an initial normal vector perpenicular to the first tangent vector,
    // and in the direction of the smallest tangent xyz component

    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    smallest = Number.MAX_VALUE;
    tx = Math.abs( tangents[ 0 ].x );
    ty = Math.abs( tangents[ 0 ].y );
    tz = Math.abs( tangents[ 0 ].z );

    if ( tx <= smallest ) {
      smallest = tx;
      normal.set( 1, 0, 0 );
    }

    if ( ty <= smallest ) {
      smallest = ty;
      normal.set( 0, 1, 0 );
    }

    if ( tz <= smallest ) {
      normal.set( 0, 0, 1 );
    }

    vec.crossVectors( tangents[ 0 ], normal ).normalize();

    normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
  }


  // compute the slowly-varying normal and binormal vectors for each segment on the path

  for ( i = 1; i < numpoints; i ++ ) {

    normals[ i ] = normals[ i-1 ].clone();

    binormals[ i ] = binormals[ i-1 ].clone();

    vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

    if ( vec.length() > epsilon ) {

      vec.normalize();

      theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

      normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    }

    binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  }


  // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  if ( closed ) {

    theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), - 1, 1 ) );
    theta /= ( numpoints - 1 );

    if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

      theta = - theta;

    }

    for ( i = 1; i < numpoints; i ++ ) {

      // twist a little...
      normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
      binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }

  }
};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

  THREE.Geometry.call( this );

  this.type = 'PolyhedronGeometry';

  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };

  radius = radius || 1;
  detail = detail || 0;

  var that = this;

  for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

  }

  var midpoints = [], p = this.vertices;

  var faces = [];

  for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    var v1 = p[ indices[ i     ] ];
    var v2 = p[ indices[ i + 1 ] ];
    var v3 = p[ indices[ i + 2 ] ];

    faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

  }

  var centroid = new THREE.Vector3();

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    subdivide( faces[ i ], detail );

  }


  // Handle case when face straddles the seam

  for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    var uvs = this.faceVertexUvs[ 0 ][ i ];

    var x0 = uvs[ 0 ].x;
    var x1 = uvs[ 1 ].x;
    var x2 = uvs[ 2 ].x;

    var max = Math.max( x0, Math.max( x1, x2 ) );
    var min = Math.min( x0, Math.min( x1, x2 ) );

    if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

      if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
      if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
      if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    }

  }


  // Apply radius

  for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    this.vertices[ i ].multiplyScalar( radius );

  }


  // Merge vertices

  this.mergeVertices();

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


  // Project vector onto sphere's surface

  function prepare( vector ) {

    var vertex = vector.normalize().clone();
    vertex.index = that.vertices.push( vertex ) - 1;

    // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    var v = inclination( vector ) / Math.PI + 0.5;
    vertex.uv = new THREE.Vector2( u, 1 - v );

    return vertex;

  }


  // Approximate a curved face with recursively sub-divided triangles.

  function make( v1, v2, v3 ) {

    var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
    that.faces.push( face );

    centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    var azi = azimuth( centroid );

    that.faceVertexUvs[ 0 ].push( [
      correctUV( v1.uv, v1, azi ),
      correctUV( v2.uv, v2, azi ),
      correctUV( v3.uv, v3, azi )
    ] );

  }


  // Analytically subdivide a face to the required detail level.

  function subdivide( face, detail ) {

    var cols = Math.pow(2, detail);
    var cells = Math.pow(4, detail);
    var a = prepare( that.vertices[ face.a ] );
    var b = prepare( that.vertices[ face.b ] );
    var c = prepare( that.vertices[ face.c ] );
    var v = [];

    // Construct all of the vertices for this subdivision.

    for ( var i = 0 ; i <= cols; i ++ ) {

      v[ i ] = [];

      var aj = prepare( a.clone().lerp( c, i / cols ) );
      var bj = prepare( b.clone().lerp( c, i / cols ) );
      var rows = cols - i;

      for ( var j = 0; j <= rows; j ++) {

        if ( j == 0 && i == cols ) {

          v[ i ][ j ] = aj;

        } else {

          v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

        }

      }

    }

    // Construct all of the faces.

    for ( var i = 0; i < cols ; i ++ ) {

      for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

        var k = Math.floor( j / 2 );

        if ( j % 2 == 0 ) {

          make(
            v[ i ][ k + 1],
            v[ i + 1 ][ k ],
            v[ i ][ k ]
          );

        } else {

          make(
            v[ i ][ k + 1 ],
            v[ i + 1][ k + 1],
            v[ i + 1 ][ k ]
          );

        }

      }

    }

  }


  // Angle around the Y axis, counter-clockwise when looking from above.

  function azimuth( vector ) {

    return Math.atan2( vector.z, - vector.x );

  }


  // Angle above the XZ plane.

  function inclination( vector ) {

    return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  }


  // Texture fixing helper. Spheres have some odd behaviours.

  function correctUV( uv, vector, azimuth ) {

    if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
    if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    return uv.clone();

  }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

  this.parameters = {
    radius: radius,
    detail: detail
  };

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  var r = 1 / t;

  var vertices = [

    // (Â±1, Â±1, Â±1)
    -1, -1, -1,    -1, -1,  1,
    -1,  1, -1,    -1,  1,  1,
     1, -1, -1,     1, -1,  1,
     1,  1, -1,     1,  1,  1,

    // (0, Â±1/Ï†, Â±Ï†)
     0, -r, -t,     0, -r,  t,
     0,  r, -t,     0,  r,  t,

    // (Â±1/Ï†, Â±Ï†, 0)
    -r, -t,  0,    -r,  t,  0,
     r, -t,  0,     r,  t,  0,

    // (Â±Ï†, 0, Â±1/Ï†)
    -t,  0, -r,     t,  0, -r,
    -t,  0,  r,     t,  0,  r
  ];

  var indices = [
     3, 11,  7,      3,  7, 15,      3, 15, 13,
     7, 19, 17,      7, 17,  6,      7,  6, 15,
    17,  4,  8,     17,  8, 10,     17, 10,  6,
     8,  0, 16,      8, 16,  2,      8,  2, 10,
     0, 12,  1,      0,  1, 18,      0, 18, 16,
     6, 10,  2,      6,  2, 13,      6, 13, 15,
     2, 16, 18,      2, 18,  3,      2,  3, 13,
    18,  1,  9,     18,  9, 11,     18, 11,  3,
     4, 14, 12,      4, 12,  0,      4,  0,  8,
    11,  9,  5,     11,  5, 19,     11, 19,  7,
    19,  5, 14,     19, 14,  4,     19,  4, 17,
     1, 12, 14,      1, 14,  5,      1,  5,  9
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  var vertices = [
    - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
     0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
     t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
  ];

  var indices = [
     0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
     1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
     3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
     4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'IcosahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };
};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

  this.parameters = {
    radius: radius,
    detail: detail
  };

  var vertices = [
    1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
  ];

  var indices = [
    0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'OctahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

  var vertices = [
     1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
  ];

  var indices = [
     2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'TetrahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

  THREE.Geometry.call( this );

  this.type = 'ParametricGeometry';

  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };

  var verts = this.vertices;
  var faces = this.faces;
  var uvs = this.faceVertexUvs[ 0 ];

  var i, il, j, p;
  var u, v;

  var stackCount = stacks + 1;
  var sliceCount = slices + 1;

  for ( i = 0; i <= stacks; i ++ ) {

    v = i / stacks;

    for ( j = 0; j <= slices; j ++ ) {

      u = j / slices;

      p = func( u, v );
      verts.push( p );

    }
  }

  var a, b, c, d;
  var uva, uvb, uvc, uvd;

  for ( i = 0; i < stacks; i ++ ) {

    for ( j = 0; j < slices; j ++ ) {

      a = i * sliceCount + j;
      b = i * sliceCount + j + 1;
      c = (i + 1) * sliceCount + j + 1;
      d = (i + 1) * sliceCount + j;

      uva = new THREE.Vector2( j / slices, i / stacks );
      uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
      uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
      uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

      faces.push( new THREE.Face3( a, b, d ) );
      uvs.push( [ uva, uvb, uvd ] );

      faces.push( new THREE.Face3( b, c, d ) );
      uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  // console.log(this);

  // magic bullet
  // var diff = this.mergeVertices();
  // console.log('removed ', diff, ' vertices by merging');

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

  size = size || 1;

  var vertices = new Float32Array( [
    0, 0, 0,  size, 0, 0,
    0, 0, 0,  0, size, 0,
    0, 0, 0,  0, 0, size
  ] );

  var colors = new Float32Array( [
    1, 0, 0,  1, 0.6, 0,
    0, 1, 0,  0.6, 1, 0,
    0, 0, 1,  0, 0.6, 1
  ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

  var lineGeometry = new THREE.Geometry();
  lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

  var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
  coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

  return function ( dir, origin, length, color, headLength, headWidth ) {

    // dir is assumed to be normalized

    THREE.Object3D.call( this );

    if ( color === undefined ) color = 0xffff00;
    if ( length === undefined ) length = 1;
    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    this.position.copy( origin );

    this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
    this.line.matrixAutoUpdate = false;
    this.add( this.line );

    this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
    this.cone.matrixAutoUpdate = false;
    this.add( this.cone );

    this.setDirection( dir );
    this.setLength( length, headLength, headWidth );

  }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = ( function () {

  var axis = new THREE.Vector3();
  var radians;

  return function ( dir ) {

    // dir is assumed to be normalized

    if ( dir.y > 0.99999 ) {

      this.quaternion.set( 0, 0, 0, 1 );

    } else if ( dir.y < - 0.99999 ) {

      this.quaternion.set( 1, 0, 0, 0 );

    } else {

      axis.set( dir.z, 0, - dir.x ).normalize();

      radians = Math.acos( dir.y );

      this.quaternion.setFromAxisAngle( axis, radians );

    }

  };

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

  if ( headLength === undefined ) headLength = 0.2 * length;
  if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  this.line.scale.set( 1, length, 1 );
  this.line.updateMatrix();

  this.cone.scale.set( headWidth, headLength, headWidth );
  this.cone.position.y = length;
  this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

  this.line.material.color.set( color );
  this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

  THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

  if ( object !== undefined ) {

    this.update( object );

  }

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

THREE.BoxHelper.prototype.update = function ( object ) {

  var geometry = object.geometry;

  if ( geometry.boundingBox === null ) {

    geometry.computeBoundingBox();

  }

  var min = geometry.boundingBox.min;
  var max = geometry.boundingBox.max;

  /*
    5____4
  1/___0/|
  | 6__|_7
  2/___3/

  0: max.x, max.y, max.z
  1: min.x, max.y, max.z
  2: min.x, min.y, max.z
  3: max.x, min.y, max.z
  4: max.x, max.y, min.z
  5: min.x, max.y, min.z
  6: min.x, min.y, min.z
  7: max.x, min.y, min.z
  */

  var vertices = this.geometry.attributes.position.array;

  vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
  vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

  vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
  vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

  vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
  vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

  vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
  vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

  //

  vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
  vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

  vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
  vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

  vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
  vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

  vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
  vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

  //

  vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
  vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

  vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
  vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

  vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
  vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

  vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
  vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

  this.geometry.attributes.position.needsUpdate = true;

  this.geometry.computeBoundingSphere();

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0x888888;

  this.object = object;

  this.box = new THREE.Box3();

  THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.BoundingBoxHelper.prototype.update = function () {

  this.box.setFromObject( this.object );

  this.box.size( this.scale );

  this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *  - shows frustum, line of sight and up of the camera
 *  - suitable for fast updates
 *  - based on frustum visualization in lightgl.js shadowmap example
 *    http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

  var pointMap = {};

  // colors

  var hexFrustum = 0xffaa00;
  var hexCone = 0xff0000;
  var hexUp = 0x00aaff;
  var hexTarget = 0xffffff;
  var hexCross = 0x333333;

  // near

  addLine( "n1", "n2", hexFrustum );
  addLine( "n2", "n4", hexFrustum );
  addLine( "n4", "n3", hexFrustum );
  addLine( "n3", "n1", hexFrustum );

  // far

  addLine( "f1", "f2", hexFrustum );
  addLine( "f2", "f4", hexFrustum );
  addLine( "f4", "f3", hexFrustum );
  addLine( "f3", "f1", hexFrustum );

  // sides

  addLine( "n1", "f1", hexFrustum );
  addLine( "n2", "f2", hexFrustum );
  addLine( "n3", "f3", hexFrustum );
  addLine( "n4", "f4", hexFrustum );

  // cone

  addLine( "p", "n1", hexCone );
  addLine( "p", "n2", hexCone );
  addLine( "p", "n3", hexCone );
  addLine( "p", "n4", hexCone );

  // up

  addLine( "u1", "u2", hexUp );
  addLine( "u2", "u3", hexUp );
  addLine( "u3", "u1", hexUp );

  // target

  addLine( "c", "t", hexTarget );
  addLine( "p", "c", hexCross );

  // cross

  addLine( "cn1", "cn2", hexCross );
  addLine( "cn3", "cn4", hexCross );

  addLine( "cf1", "cf2", hexCross );
  addLine( "cf3", "cf4", hexCross );

  function addLine( a, b, hex ) {

    addPoint( a, hex );
    addPoint( b, hex );

  }

  function addPoint( id, hex ) {

    geometry.vertices.push( new THREE.Vector3() );
    geometry.colors.push( new THREE.Color( hex ) );

    if ( pointMap[ id ] === undefined ) {

      pointMap[ id ] = [];

    }

    pointMap[ id ].push( geometry.vertices.length - 1 );

  }

  THREE.Line.call( this, geometry, material, THREE.LinePieces );

  this.camera = camera;
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;

  this.pointMap = pointMap;

  this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

  var geometry, pointMap;
  
  var vector = new THREE.Vector3();
  var camera = new THREE.Camera();

  var setPoint = function ( point, x, y, z ) {

    vector.set( x, y, z ).unproject( camera );

    var points = pointMap[ point ];

    if ( points !== undefined ) {

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        geometry.vertices[ points[ i ] ].copy( vector );

      }

    }

  };

  return function () {

    geometry = this.geometry;
    pointMap = this.pointMap;

    var w = 1, h = 1;

    // we need just camera projection matrix
    // world matrix must be identity

    camera.projectionMatrix.copy( this.camera.projectionMatrix );

    // center / target

    setPoint( "c", 0, 0, - 1 );
    setPoint( "t", 0, 0,  1 );

    // near

    setPoint( "n1", - w, - h, - 1 );
    setPoint( "n2",   w, - h, - 1 );
    setPoint( "n3", - w,   h, - 1 );
    setPoint( "n4",   w,   h, - 1 );

    // far

    setPoint( "f1", - w, - h, 1 );
    setPoint( "f2",   w, - h, 1 );
    setPoint( "f3", - w,   h, 1 );
    setPoint( "f4",   w,   h, 1 );

    // up

    setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    setPoint( "u3",         0, h * 2,   - 1 );

    // cross

    setPoint( "cf1", - w,   0, 1 );
    setPoint( "cf2",   w,   0, 1 );
    setPoint( "cf3",   0, - h, 1 );
    setPoint( "cf4",   0,   h, 1 );

    setPoint( "cn1", - w,   0, - 1 );
    setPoint( "cn2",   w,   0, - 1 );
    setPoint( "cn3",   0, - h, - 1 );
    setPoint( "cn4",   0,   h, - 1 );

    geometry.verticesNeedUpdate = true;

  };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  size = size || 1;

  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3( - size,   size, 0 ),
    new THREE.Vector3(   size,   size, 0 ),
    new THREE.Vector3(   size, - size, 0 ),
    new THREE.Vector3( - size, - size, 0 ),
    new THREE.Vector3( - size,   size, 0 )
  );

  var material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.lightPlane = new THREE.Line( geometry, material );
  this.add( this.lightPlane );

  geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(),
    new THREE.Vector3()
  );

  material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.targetLine = new THREE.Line( geometry, material );
  this.add( this.targetLine );

  this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.dispose = function () {

  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var v3 = new THREE.Vector3();

  return function () {

    v1.setFromMatrixPosition( this.light.matrixWorld );
    v2.setFromMatrixPosition( this.light.target.matrixWorld );
    v3.subVectors( v2, v1 );

    this.lightPlane.lookAt( v3 );
    this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine.geometry.vertices[ 1 ].copy( v3 );
    this.targetLine.geometry.verticesNeedUpdate = true;
    this.targetLine.material.color.copy( this.lightPlane.material.color );

  };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  var edge = [ 0, 0 ], hash = {};
  var sortFunction = function ( a, b ) { return a - b };

  var keys = [ 'a', 'b', 'c' ];
  var geometry = new THREE.BufferGeometry();

  var geometry2 = object.geometry.clone();

  geometry2.mergeVertices();
  geometry2.computeFaceNormals();

  var vertices = geometry2.vertices;
  var faces = geometry2.faces;
  var numEdges = 0;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0; j < 3; j ++ ) {

      edge[ 0 ] = face[ keys[ j ] ];
      edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
      edge.sort( sortFunction );

      var key = edge.toString();

      if ( hash[ key ] === undefined ) {

        hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
        numEdges ++;

      } else {

        hash[ key ].face2 = i;

      }

    }

  }

  var coords = new Float32Array( numEdges * 2 * 3 );

  var index = 0;

  for ( var key in hash ) {

    var h = hash[ key ];

    if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

      var vertex = vertices[ h.vert1 ];
      coords[ index ++ ] = vertex.x;
      coords[ index ++ ] = vertex.y;
      coords[ index ++ ] = vertex.z;

      vertex = vertices[ h.vert2 ];
      coords[ index ++ ] = vertex.x;
      coords[ index ++ ] = vertex.y;
      coords[ index ++ ] = vertex.z;

    }

  }

  geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

  THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xffff00;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var faces = this.object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

  }

  THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

  this.matrixAutoUpdate = false;

  this.normalMatrix = new THREE.Matrix3();

  this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.FaceNormalsHelper.prototype.update = function () {

  var vertices = this.geometry.vertices;

  var object = this.object;
  var objectVertices = object.geometry.vertices;
  var objectFaces = object.geometry.faces;
  var objectWorldMatrix = object.matrixWorld;

  object.updateMatrixWorld( true );

  this.normalMatrix.getNormalMatrix( objectWorldMatrix );

  for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

    var face = objectFaces[ i ];

    vertices[ i2 ].copy( objectVertices[ face.a ] )
      .add( objectVertices[ face.b ] )
      .add( objectVertices[ face.c ] )
      .divideScalar( 3 )
      .applyMatrix4( objectWorldMatrix );

    vertices[ i2 + 1 ].copy( face.normal )
      .applyMatrix3( this.normalMatrix )
      .normalize()
      .multiplyScalar( this.size )
      .add( vertices[ i2 ] );

  }

  this.geometry.verticesNeedUpdate = true;

  return this;

};


// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  this.color1 = new THREE.Color( 0x444444 );
  this.color2 = new THREE.Color( 0x888888 );

  for ( var i = - size; i <= size; i += step ) {

    geometry.vertices.push(
      new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
      new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
    );

    var color = i === 0 ? this.color1 : this.color2;

    geometry.colors.push( color, color, color, color );

  }

  THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

  this.color1.set( colorCenterLine );
  this.color2.set( colorGrid );

  this.geometry.colorsNeedUpdate = true;

}

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  this.colors = [ new THREE.Color(), new THREE.Color() ];

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

  for ( var i = 0, il = 8; i < il; i ++ ) {

    geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

  }

  var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

  this.lightSphere = new THREE.Mesh( geometry, material );
  this.add( this.lightSphere );

  this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.dispose = function () {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();

  return function () {

    this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    this.lightSphere.geometry.colorsNeedUpdate = true;

  }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

  this.light = light;
  this.light.updateMatrixWorld();

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  THREE.Mesh.call( this, geometry, material );

  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;

  /*
  var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
  var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  var d = light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.scale.set( d, d, d );

  }

  this.add( this.lightDistance );
  */

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.PointLightHelper.prototype.dispose = function () {

  this.geometry.dispose();
  this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

  this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  /*
  var d = this.light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.visible = true;
    this.lightDistance.scale.set( d, d, d );

  }
  */

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

  this.bones = this.getBoneList( object );

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      geometry.vertices.push( new THREE.Vector3() );
      geometry.vertices.push( new THREE.Vector3() );
      geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
      geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

    }

  }

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

  THREE.Line.call( this, geometry, material, THREE.LinePieces );

  this.root = object;

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

  this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

  var boneList = [];

  if ( object instanceof THREE.Bone ) {

    boneList.push( object );

  }

  for ( var i = 0; i < object.children.length; i ++ ) {

    boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

  }

  return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

  var geometry = this.geometry;

  var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

  var boneMatrix = new THREE.Matrix4();

  var j = 0;

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
      geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
      geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

      j += 2;

    }

  }

  geometry.verticesNeedUpdate = true;

  geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

  geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

  this.cone = new THREE.Mesh( geometry, material );
  this.add( this.cone );

  this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();
  var vector2 = new THREE.Vector3();

  return function () {

    var coneLength = this.light.distance ? this.light.distance : 10000;
    var coneWidth = coneLength * Math.tan( this.light.angle );

    this.cone.scale.set( coneWidth, coneWidth, coneLength );

    vector.setFromMatrixPosition( this.light.matrixWorld );
    vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    this.cone.lookAt( vector2.sub( vector ) );

    this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xff0000;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var vertices = object.geometry.vertices;

  var faces = object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

      geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

    }

  }

  THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

  this.matrixAutoUpdate = false;

  this.normalMatrix = new THREE.Matrix3();

  this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

  var v1 = new THREE.Vector3();

  return function( object ) {

    var keys = [ 'a', 'b', 'c', 'd' ];

    this.object.updateMatrixWorld( true );

    this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

    var vertices = this.geometry.vertices;

    var verts = this.object.geometry.vertices;

    var faces = this.object.geometry.faces;

    var worldMatrix = this.object.matrixWorld;

    var idx = 0;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

        var vertexId = face[ keys[ j ] ];
        var vertex = verts[ vertexId ];

        var normal = face.vertexNormals[ j ];

        vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

        v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

        v1.add( vertices[ idx ] );
        idx = idx + 1;

        vertices[ idx ].copy( v1 );
        idx = idx + 1;

      }

    }

    this.geometry.verticesNeedUpdate = true;

    return this;

  }

}());

// File:src/extras/helpers/VertexTangentsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0x0000ff;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var vertices = object.geometry.vertices;

  var faces = object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

      geometry.vertices.push( new THREE.Vector3() );
      geometry.vertices.push( new THREE.Vector3() );

    }

  }

  THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

  this.matrixAutoUpdate = false;

  this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

  var v1 = new THREE.Vector3();

  return function( object ) {

    var keys = [ 'a', 'b', 'c', 'd' ];

    this.object.updateMatrixWorld( true );

    var vertices = this.geometry.vertices;

    var verts = this.object.geometry.vertices;

    var faces = this.object.geometry.faces;

    var worldMatrix = this.object.matrixWorld;

    var idx = 0;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

        var vertexId = face[ keys[ j ] ];
        var vertex = verts[ vertexId ];

        var tangent = face.vertexTangents[ j ];

        vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

        v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

        v1.add( vertices[ idx ] );
        idx = idx + 1;

        vertices[ idx ].copy( v1 );
        idx = idx + 1;

      }

    }

    this.geometry.verticesNeedUpdate = true;

    return this;

  }

}());

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  var edge = [ 0, 0 ], hash = {};
  var sortFunction = function ( a, b ) { return a - b };

  var keys = [ 'a', 'b', 'c' ];
  var geometry = new THREE.BufferGeometry();

  if ( object.geometry instanceof THREE.Geometry ) {

    var vertices = object.geometry.vertices;
    var faces = object.geometry.faces;
    var numEdges = 0;

    // allocate maximal size
    var edges = new Uint32Array( 6 * faces.length );

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0; j < 3; j ++ ) {

        edge[ 0 ] = face[ keys[ j ] ];
        edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
        edge.sort( sortFunction );

        var key = edge.toString();

        if ( hash[ key ] === undefined ) {

          edges[ 2 * numEdges ] = edge[ 0 ];
          edges[ 2 * numEdges + 1 ] = edge[ 1 ];
          hash[ key ] = true;
          numEdges ++;

        }

      }

    }

    var coords = new Float32Array( numEdges * 2 * 3 );

    for ( var i = 0, l = numEdges; i < l; i ++ ) {

      for ( var j = 0; j < 2; j ++ ) {

        var vertex = vertices[ edges [ 2 * i + j] ];

        var index = 6 * i + 3 * j;
        coords[ index + 0 ] = vertex.x;
        coords[ index + 1 ] = vertex.y;
        coords[ index + 2 ] = vertex.z;

      }

    }

    geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

  } else if ( object.geometry instanceof THREE.BufferGeometry ) {

    if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

      var vertices = object.geometry.attributes.position.array;
      var indices = object.geometry.attributes.index.array;
      var drawcalls = object.geometry.drawcalls;
      var numEdges = 0;

      if ( drawcalls.length === 0 ) {

        drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

      }

      // allocate maximal size
      var edges = new Uint32Array( 2 * indices.length );

      for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

        var start = drawcalls[ o ].start;
        var count = drawcalls[ o ].count;
        var index = drawcalls[ o ].index;

        for ( var i = start, il = start + count; i < il; i += 3 ) {

          for ( var j = 0; j < 3; j ++ ) {

            edge[ 0 ] = index + indices[ i + j ];
            edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

              edges[ 2 * numEdges ] = edge[ 0 ];
              edges[ 2 * numEdges + 1 ] = edge[ 1 ];
              hash[ key ] = true;
              numEdges ++;

            }

          }

        }

      }

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numEdges; i < l; i ++ ) {

        for ( var j = 0; j < 2; j ++ ) {

          var index = 6 * i + 3 * j;
          var index2 = 3 * edges[ 2 * i + j];
          coords[ index + 0 ] = vertices[ index2 ];
          coords[ index + 1 ] = vertices[ index2 + 1 ];
          coords[ index + 2 ] = vertices[ index2 + 2 ];

        }

      }

      geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    } else { // non-indexed BufferGeometry

      var vertices = object.geometry.attributes.position.array;
      var numEdges = vertices.length / 3;
      var numTris = numEdges / 3;

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numTris; i < l; i ++ ) {

        for ( var j = 0; j < 3; j ++ ) {

          var index = 18 * i + 6 * j;

          var index1 = 9 * i + 3 * j;
          coords[ index + 0 ] = vertices[ index1 ];
          coords[ index + 1 ] = vertices[ index1 + 1 ];
          coords[ index + 2 ] = vertices[ index1 + 2 ];

          var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
          coords[ index + 3 ] = vertices[ index2 ];
          coords[ index + 4 ] = vertices[ index2 + 1 ];
          coords[ index + 5 ] = vertices[ index2 + 2 ];

        }

      }

      geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    }

  }

  THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

  THREE.Object3D.call( this );

  this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.animationsMap = {};
  this.animationsList = [];

  // prepare default animation
  // (all frames played together in 1 second)

  var numFrames = this.geometry.morphTargets.length;

  var name = "__default";

  var startFrame = 0;
  var endFrame = numFrames - 1;

  var fps = numFrames / 1;

  this.createAnimation( name, startFrame, endFrame, fps );
  this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

  var animation = {

    startFrame: start,
    endFrame: end,

    length: end - start + 1,

    fps: fps,
    duration: ( end - start ) / fps,

    lastFrame: 0,
    currentFrame: 0,

    active: false,

    time: 0,
    direction: 1,
    weight: 1,

    directionBackwards: false,
    mirroredLoop: false

  };

  this.animationsMap[ name ] = animation;
  this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

  var pattern = /([a-z]+)_?(\d+)/;

  var firstAnimation, frameRanges = {};

  var geometry = this.geometry;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var chunks = morph.name.match( pattern );

    if ( chunks && chunks.length > 1 ) {

      var name = chunks[ 1 ];
      var num = chunks[ 2 ];

      if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

      var range = frameRanges[ name ];

      if ( i < range.start ) range.start = i;
      if ( i > range.end ) range.end = i;

      if ( ! firstAnimation ) firstAnimation = name;

    }

  }

  for ( var name in frameRanges ) {

    var range = frameRanges[ name ];
    this.createAnimation( name, range.start, range.end, fps );

  }

  this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = 1;
    animation.directionBackwards = false;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = - 1;
    animation.directionBackwards = true;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.fps = fps;
    animation.duration = ( animation.end - animation.start ) / animation.fps;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.duration = duration;
    animation.fps = ( animation.end - animation.start ) / animation.duration;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.weight = weight;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = time;

  }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

  var time = 0;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    time = animation.time;

  }

  return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

  var duration = - 1;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    duration = animation.duration;

  }

  return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = 0;
    animation.active = true;

  } else {

    console.warn( "animation[" + name + "] undefined" );

  }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.active = false;

  }

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

  for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    var animation = this.animationsList[ i ];

    if ( ! animation.active ) continue;

    var frameTime = animation.duration / animation.length;

    animation.time += animation.direction * delta;

    if ( animation.mirroredLoop ) {

      if ( animation.time > animation.duration || animation.time < 0 ) {

        animation.direction *= - 1;

        if ( animation.time > animation.duration ) {

          animation.time = animation.duration;
          animation.directionBackwards = true;

        }

        if ( animation.time < 0 ) {

          animation.time = 0;
          animation.directionBackwards = false;

        }

      }

    } else {

      animation.time = animation.time % animation.duration;

      if ( animation.time < 0 ) animation.time += animation.duration;

    }

    var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    var weight = animation.weight;

    if ( keyframe !== animation.currentFrame ) {

      this.morphTargetInfluences[ animation.lastFrame ] = 0;
      this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

      this.morphTargetInfluences[ keyframe ] = 0;

      animation.lastFrame = animation.currentFrame;
      animation.currentFrame = keyframe;

    }

    var mix = ( animation.time % frameTime ) / frameTime;

    if ( animation.directionBackwards ) mix = 1 - mix;

    this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
    this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

  }

};


/**
 * @author bhouston / http://exocortex.com/
 * @author zz85 / http://github.com/zz85
 */

THREE.ColorConverter = {

  setHSV: function ( color, h, s, v ) {

    // https://gist.github.com/xpansive/1337890#file-index-js
    return color.setHSL( h, ( s * v ) / ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) ), h * 0.5 );

  },

  getHSV: function( color ) {

    var hsl = color.getHSL();

    // based on https://gist.github.com/xpansive/1337890#file-index-js
    hsl.s *= ( hsl.l < 0.5 ) ? hsl.l : ( 1 - hsl.l );

    return {
      h: hsl.h,
      s: 2 * hsl.s / ( hsl.l + hsl.s ),
      v: hsl.l + hsl.s
    };
  },

  // where c, m, y, k is between 0 and 1
  
  setCMYK: function ( color, c, m, y, k ) {

    var r = ( 1 - c ) * ( 1 - k );
    var g = ( 1 - m ) * ( 1 - k );
    var b = ( 1 - y ) * ( 1 - k );

    return color.setRGB( r, g, b );

  },

  getCMYK: function ( color ) {

    var r = color.r;
    var g = color.g;
    var b = color.b;
    var k = 1 - Math.max(r, g, b);
    var c = ( 1 - r - k ) / ( 1 - k );
    var m = ( 1 - g - k ) / ( 1 - k );
    var y = ( 1 - b - k ) / ( 1 - k );

    return {
      c: c, m: m, y: y, k: k
    };

  }


};
d3 = function() {
  var d3 = {
    version: "3.3.13"
  };
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = document, d3_documentElement = d3_document.documentElement, d3_window = window;
  try {
    d3_array(d3_documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = function(list) {
      var i = list.length, array = new Array(i);
      while (i--) array[i] = list[i];
      return array;
    };
  }
  try {
    d3_document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_element_prototype = d3_window.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_element_prototype.setAttribute = function(name, value) {
      d3_element_setAttribute.call(this, name, value + "");
    };
    d3_element_prototype.setAttributeNS = function(space, local, value) {
      d3_element_setAttributeNS.call(this, space, local, value + "");
    };
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  d3.ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  };
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n && !((a = c = array[i]) != null && a <= a)) a = c = undefined;
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n && !((a = c = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (!isNaN(a = +array[i])) s += a;
    } else {
      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  function d3_number(x) {
    return x != null && !isNaN(x);
  }
  d3.mean = function(array, f) {
    var n = array.length, a, m = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
    } else {
      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
    }
    return j ? m : undefined;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    if (arguments.length > 1) array = array.map(f);
    array = array.filter(d3_number);
    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
  };
  d3.bisector = function(f) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  };
  var d3_bisector = d3.bisector(function(d) {
    return d;
  });
  d3.bisectLeft = d3_bisector.left;
  d3.bisect = d3.bisectRight = d3_bisector.right;
  d3.shuffle = function(array) {
    var m = array.length, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m], array[m] = array[i], array[i] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    try {
      for (var key in properties) {
        Object.defineProperty(ctor.prototype, key, {
          value: properties[key],
          enumerable: false
        });
      }
    } catch (e) {
      ctor.prototype = properties;
    }
  }
  d3.map = function(object) {
    var map = new d3_Map();
    if (object instanceof d3_Map) object.forEach(function(key, value) {
      map.set(key, value);
    }); else for (var key in object) map.set(key, object[key]);
    return map;
  };
  function d3_Map() {}
  d3_class(d3_Map, {
    has: function(key) {
      return d3_map_prefix + key in this;
    },
    get: function(key) {
      return this[d3_map_prefix + key];
    },
    set: function(key, value) {
      return this[d3_map_prefix + key] = value;
    },
    remove: function(key) {
      key = d3_map_prefix + key;
      return key in this && delete this[key];
    },
    keys: function() {
      var keys = [];
      this.forEach(function(key) {
        keys.push(key);
      });
      return keys;
    },
    values: function() {
      var values = [];
      this.forEach(function(key, value) {
        values.push(value);
      });
      return values;
    },
    entries: function() {
      var entries = [];
      this.forEach(function(key, value) {
        entries.push({
          key: key,
          value: value
        });
      });
      return entries;
    },
    forEach: function(f) {
      for (var key in this) {
        if (key.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, key.substring(1), this[key]);
        }
      }
    }
  });
  var d3_map_prefix = "\x00", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {}
  d3_class(d3_Set, {
    has: function(value) {
      return d3_map_prefix + value in this;
    },
    add: function(value) {
      this[d3_map_prefix + value] = true;
      return value;
    },
    remove: function(value) {
      value = d3_map_prefix + value;
      return value in this && delete this[value];
    },
    values: function() {
      var values = [];
      this.forEach(function(value) {
        values.push(value);
      });
      return values;
    },
    forEach: function(f) {
      for (var value in this) {
        if (value.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, value.substring(1));
        }
      }
    }
  });
  d3.behavior = {};
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.substring(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.substring(i + 1);
      type = type.substring(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatcher = d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")], d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = function(s, n) {
      return Sizzle.uniqueSort(Sizzle(s, n));
    };
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3_selectionRoot;
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.substring(0, i);
        name = name.substring(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return name.trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? function() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    } : function() {
      return this.ownerDocument.createElementNS(this.namespaceURI, name);
    };
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(function() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    });
  };
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
        for (i = -1; ++i < n; ) {
          keyValue = key.call(node = group[i], node.__data__, i);
          if (nodeByKeyValue.has(keyValue)) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues.push(keyValue);
        }
        for (i = -1; ++i < m; ) {
          keyValue = key.call(groupData, nodeData = groupData[i], i);
          if (node = nodeByKeyValue.get(keyValue)) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          } else if (!dataByKeyValue.has(keyValue)) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
          dataByKeyValue.set(keyValue, nodeData);
          nodeByKeyValue.remove(keyValue);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValues[i])) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3.ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    this.each(function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3_selectionPrototype.transition = function() {
    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_selectionPrototype.interrupt = function() {
    return this.each(d3_selection_interrupt);
  };
  function d3_selection_interrupt() {
    var lock = this.__transition__;
    if (lock) ++lock.active;
  }
  d3.select = function(node) {
    var group = [ typeof node === "string" ? d3_select(node, d3_document) : node ];
    group.parentNode = d3_documentElement;
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
    group.parentNode = d3_documentElement;
    return d3_selection([ group ]);
  };
  var d3_selectionRoot = d3.select(d3_documentElement);
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.substring(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  d3_selection_onFilters.forEach(function(k) {
    if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
  });
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect = "onselectstart" in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect"), d3_event_dragId = 0;
  function d3_event_dragSuppress() {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect) {
      var style = d3_documentElement.style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        function off() {
          w.on(click, null);
        }
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
        svg = d3.select("body").append("svg").style({
          position: "absolute",
          top: 0,
          left: 0,
          margin: 0,
          padding: 0,
          border: "none"
        }, "important");
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, "mousemove", "mouseup"), touchstart = dragstart(touchid, touchposition, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function touchid() {
      return d3.event.changedTouches[0].identifier;
    }
    function touchposition(parent, id) {
      return d3.touches(parent).filter(function(p) {
        return p.identifier === id;
      })[0];
    }
    function dragstart(id, position, move, end) {
      return function() {
        var target = this, parent = target.parentNode, event_ = event.of(target, arguments), eventTarget = d3.event.target, eventId = id(), drag = eventId == null ? "drag" : "drag-" + eventId, origin_ = position(parent, eventId), dragged = 0, offset, w = d3.select(d3_window).on(move + "." + drag, moved).on(end + "." + drag, ended), dragRestore = d3_event_dragSuppress();
        if (origin) {
          offset = origin.apply(target, arguments);
          offset = [ offset.x - origin_[0], offset.y - origin_[1] ];
        } else {
          offset = [ 0, 0 ];
        }
        event_({
          type: "dragstart"
        });
        function moved() {
          var p = position(parent, eventId), dx = p[0] - origin_[0], dy = p[1] - origin_[1];
          dragged |= dx | dy;
          origin_ = p;
          event_({
            type: "drag",
            x: p[0] + offset[0],
            y: p[1] + offset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          w.on(move + "." + drag, null).on(end + "." + drag, null);
          dragRestore(dragged && d3.event.target === eventTarget);
          event_({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  var Ï€ = Math.PI, Ï„ = 2 * Ï€, halfÏ€ = Ï€ / 2, Îµ = 1e-6, Îµ2 = Îµ * Îµ, d3_radians = Ï€ / 180, d3_degrees = 180 / Ï€;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? Ï€ : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfÏ€ : x < -1 ? -halfÏ€ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var Ï = Math.SQRT2, Ï2 = 2, Ï4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + Ï4 * d2) / (2 * w0 * Ï2 * d1), b1 = (w1 * w1 - w0 * w0 - Ï4 * d2) / (2 * w1 * Ï2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / Ï;
    function interpolate(t) {
      var s = t * S;
      if (dr) {
        var coshr0 = d3_cosh(r0), u = w0 / (Ï2 * d1) * (coshr0 * d3_tanh(Ï * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(Ï * s + r0) ];
      }
      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(Ï * s) ];
    }
    interpolate.duration = S * 1e3;
    return interpolate;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on(mousemove, mousewheelreset).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(event_);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = dx / 2, cy = dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(event_);
            };
          }).each("end.zoom", function() {
            zoomended(event_);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(event_);
          zoomed(event_);
          zoomended(event_);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: +_
      };
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(event) {
      event({
        type: "zoomstart"
      });
    }
    function zoomed(event) {
      rescale();
      event({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(event) {
      event({
        type: "zoomend"
      });
    }
    function mousedowned() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, dragged = 0, w = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended), l = location(d3.mouse(target)), dragRestore = d3_event_dragSuppress();
      d3_selection_interrupt.call(target);
      zoomstarted(event_);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(target), l);
        zoomed(event_);
      }
      function ended() {
        w.on(mousemove, d3_window === target ? mousewheelreset : null).on(mouseup, null);
        dragRestore(dragged && d3.event.target === eventTarget);
        zoomended(event_);
      }
    }
    function touchstarted() {
      var target = this, event_ = event.of(target, arguments), locations0 = {}, distance0 = 0, scale0, eventId = d3.event.changedTouches[0].identifier, touchmove = "touchmove.zoom-" + eventId, touchend = "touchend.zoom-" + eventId, w = d3.select(d3_window).on(touchmove, moved).on(touchend, ended), t = d3.select(target).on(mousedown, null).on(touchstart, started), dragRestore = d3_event_dragSuppress();
      d3_selection_interrupt.call(target);
      started();
      zoomstarted(event_);
      function relocate() {
        var touches = d3.touches(target);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0], l = locations0[p.identifier];
            scaleTo(view.k * 2);
            translateTo(p, l);
            d3_eventPreventDefault();
            zoomed(event_);
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(target), p0, l0, p1, l1;
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(event_);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        w.on(touchmove, null).on(touchend, null);
        t.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(event_);
      }
    }
    function mousewheeled() {
      var event_ = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      zoomstarted(event_);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(event_);
      }, 50);
      d3_eventPreventDefault();
      var point = center || d3.mouse(this);
      if (!translate0) translate0 = location(point);
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(point, translate0);
      zoomed(event_);
    }
    function mousewheelreset() {
      translate0 = null;
    }
    function dblclicked() {
      var event_ = event.of(this, arguments), p = d3.mouse(this), l = location(p), k = Math.log(view.k) / Math.LN2;
      zoomstarted(event_);
      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
      translateTo(p, l);
      zoomed(event_);
      zoomended(event_);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ];
  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
  }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
    return d3.event.wheelDelta;
  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
    return -d3.event.detail;
  }, "MozMousePixelScroll");
  function d3_Color() {}
  d3_Color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = function(h, s, l) {
    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
  };
  function d3_hsl(h, s, l) {
    return new d3_Hsl(h, s, l);
  }
  function d3_Hsl(h, s, l) {
    this.h = h;
    this.s = s;
    this.l = l;
  }
  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = function(h, c, l) {
    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
  };
  function d3_hcl(h, c, l) {
    return new d3_Hcl(h, c, l);
  }
  function d3_Hcl(h, c, l) {
    this.h = h;
    this.c = c;
    this.l = l;
  }
  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();
  d3_hclPrototype.brighter = function(k) {
    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = function(l, a, b) {
    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
  };
  function d3_lab(l, a, b) {
    return new d3_Lab(l, a, b);
  }
  function d3_Lab(l, a, b) {
    this.l = l;
    this.a = a;
    this.b = b;
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_Lab.prototype = new d3_Color();
  d3_labPrototype.brighter = function(k) {
    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = function(r, g, b) {
    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
  };
  function d3_rgbNumber(value) {
    return d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  function d3_rgb(r, g, b) {
    return new d3_Rgb(r, g, b);
  }
  function d3_Rgb(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return d3_rgb(Math.min(255, ~~(r / k)), Math.min(255, ~~(g / k)), Math.min(255, ~~(b / k)));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_rgb(~~(k * this.r), ~~(k * this.g), ~~(k * this.b));
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, name;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);
    if (format != null && format.charAt(0) === "#") {
      if (format.length === 4) {
        r = format.charAt(1);
        r += r;
        g = format.charAt(2);
        g += g;
        b = format.charAt(3);
        b += b;
      } else if (format.length === 7) {
        r = format.substring(1, 3);
        g = format.substring(3, 5);
        b = format.substring(5, 7);
      }
      r = parseInt(r, 16);
      g = parseInt(g, 16);
      b = parseInt(b, 16);
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  function d3_identity(d) {
    return d;
  }
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (d3_window.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && request.responseText || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.substring(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.substring(j, I - k);
        }
        return text.substring(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && !(a = f(a, n++))) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv(" ", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      f: false,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now();
    d3_timer_active = d3_timer_queueHead;
    while (d3_timer_active) {
      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
      d3_timer_active = d3_timer_active.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.f) {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      } else {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  var d3_format_decimalPoint = ".", d3_format_thousandsSeparator = ",", d3_format_grouping = [ 3, 3 ], d3_format_currencySymbol = "$";
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  d3.format = function(specifier) {
    var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = "", integer = false;
    if (precision) precision = +precision.substring(1);
    if (zfill || fill === "0" && align === "=") {
      zfill = fill = "0";
      align = "=";
      if (comma) width -= Math.floor((width - 1) / 4);
    }
    switch (type) {
     case "n":
      comma = true;
      type = "g";
      break;

     case "%":
      scale = 100;
      suffix = "%";
      type = "f";
      break;

     case "p":
      scale = 100;
      suffix = "%";
      type = "r";
      break;

     case "b":
     case "o":
     case "x":
     case "X":
      if (symbol === "#") symbol = "0" + type.toLowerCase();

     case "c":
     case "d":
      integer = true;
      precision = 0;
      break;

     case "s":
      scale = -1;
      type = "r";
      break;
    }
    if (symbol === "#") symbol = ""; else if (symbol === "$") symbol = d3_format_currencySymbol;
    if (type == "r" && !precision) type = "g";
    if (precision != null) {
      if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
    }
    type = d3_format_types.get(type) || d3_format_typeDefault;
    var zcomma = zfill && comma;
    return function(value) {
      if (integer && value % 1) return "";
      var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
      if (scale < 0) {
        var prefix = d3.formatPrefix(value, precision);
        value = prefix.scale(value);
        suffix = prefix.symbol;
      } else {
        value *= scale;
      }
      value = type(value, precision);
      var i = value.lastIndexOf("."), before = i < 0 ? value : value.substring(0, i), after = i < 0 ? "" : d3_format_decimalPoint + value.substring(i + 1);
      if (!zfill && comma) before = d3_format_group(before);
      var length = symbol.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
      if (zcomma) before = d3_format_group(padding + before);
      negative += symbol;
      value = before + after;
      return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;
    };
  };
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_format_group = d3_identity;
  if (d3_format_grouping) {
    var d3_format_groupingLength = d3_format_grouping.length;
    d3_format_group = function(value) {
      var i = value.length, t = [], j = 0, g = d3_format_grouping[0];
      while (i > 0 && g > 0) {
        t.push(value.substring(i -= g, i + g));
        g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];
      }
      return t.reverse().join(d3_format_thousandsSeparator);
    };
  }
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * Ï€;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * Ï€ + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var Î»00, Ï†00, Î»0, cosÏ†0, sinÏ†0;
    d3_geo_area.point = function(Î», Ï†) {
      d3_geo_area.point = nextPoint;
      Î»0 = (Î»00 = Î») * d3_radians, cosÏ†0 = Math.cos(Ï† = (Ï†00 = Ï†) * d3_radians / 2 + Ï€ / 4), 
      sinÏ†0 = Math.sin(Ï†);
    };
    function nextPoint(Î», Ï†) {
      Î» *= d3_radians;
      Ï† = Ï† * d3_radians / 2 + Ï€ / 4;
      var dÎ» = Î» - Î»0, cosÏ† = Math.cos(Ï†), sinÏ† = Math.sin(Ï†), k = sinÏ†0 * sinÏ†, u = cosÏ†0 * cosÏ† + k * Math.cos(dÎ»), v = k * Math.sin(dÎ»);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      Î»0 = Î», cosÏ†0 = cosÏ†, sinÏ†0 = sinÏ†;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(Î»00, Ï†00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var Î» = spherical[0], Ï† = spherical[1], cosÏ† = Math.cos(Ï†);
    return [ cosÏ† * Math.cos(Î»), cosÏ† * Math.sin(Î»), Math.sin(Ï†) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < Îµ && abs(a[1] - b[1]) < Îµ;
  }
  d3.geo.bounds = function() {
    var Î»0, Ï†0, Î»1, Ï†1, Î»_, Î»__, Ï†__, p0, dÎ»Sum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dÎ»Sum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) Î»0 = -(Î»1 = 180), Ï†0 = -(Ï†1 = 90); else if (dÎ»Sum > Îµ) Ï†1 = 90; else if (dÎ»Sum < -Îµ) Ï†0 = -90;
        range[0] = Î»0, range[1] = Î»1;
      }
    };
    function point(Î», Ï†) {
      ranges.push(range = [ Î»0 = Î», Î»1 = Î» ]);
      if (Ï† < Ï†0) Ï†0 = Ï†;
      if (Ï† > Ï†1) Ï†1 = Ï†;
    }
    function linePoint(Î», Ï†) {
      var p = d3_geo_cartesian([ Î» * d3_radians, Ï† * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dÎ» = Î» - Î»_, s = dÎ» > 0 ? 1 : -1, Î»i = inflection[0] * d3_degrees * s, antimeridian = abs(dÎ») > 180;
        if (antimeridian ^ (s * Î»_ < Î»i && Î»i < s * Î»)) {
          var Ï†i = inflection[1] * d3_degrees;
          if (Ï†i > Ï†1) Ï†1 = Ï†i;
        } else if (Î»i = (Î»i + 360) % 360 - 180, antimeridian ^ (s * Î»_ < Î»i && Î»i < s * Î»)) {
          var Ï†i = -inflection[1] * d3_degrees;
          if (Ï†i < Ï†0) Ï†0 = Ï†i;
        } else {
          if (Ï† < Ï†0) Ï†0 = Ï†;
          if (Ï† > Ï†1) Ï†1 = Ï†;
        }
        if (antimeridian) {
          if (Î» < Î»_) {
            if (angle(Î»0, Î») > angle(Î»0, Î»1)) Î»1 = Î»;
          } else {
            if (angle(Î», Î»1) > angle(Î»0, Î»1)) Î»0 = Î»;
          }
        } else {
          if (Î»1 >= Î»0) {
            if (Î» < Î»0) Î»0 = Î»;
            if (Î» > Î»1) Î»1 = Î»;
          } else {
            if (Î» > Î»_) {
              if (angle(Î»0, Î») > angle(Î»0, Î»1)) Î»1 = Î»;
            } else {
              if (angle(Î», Î»1) > angle(Î»0, Î»1)) Î»0 = Î»;
            }
          }
        }
      } else {
        point(Î», Ï†);
      }
      p0 = p, Î»_ = Î»;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = Î»0, range[1] = Î»1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(Î», Ï†) {
      if (p0) {
        var dÎ» = Î» - Î»_;
        dÎ»Sum += abs(dÎ») > 180 ? dÎ» + (dÎ» > 0 ? 360 : -360) : dÎ»;
      } else Î»__ = Î», Ï†__ = Ï†;
      d3_geo_area.point(Î», Ï†);
      linePoint(Î», Ï†);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(Î»__, Ï†__);
      d3_geo_area.lineEnd();
      if (abs(dÎ»Sum) > Îµ) Î»0 = -(Î»1 = 180);
      range[0] = Î»0, range[1] = Î»1;
      p0 = null;
    }
    function angle(Î»0, Î»1) {
      return (Î»1 -= Î»0) < 0 ? Î»1 + 360 : Î»1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      Ï†1 = Î»1 = -(Î»0 = Ï†0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dÎ»;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dÎ» = angle(a[1], b[0])) > best) best = dÎ», Î»0 = b[0], Î»1 = a[1];
        }
      }
      ranges = range = null;
      return Î»0 === Infinity || Ï†0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ Î»0, Ï†0 ], [ Î»1, Ï†1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < Îµ2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < Îµ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < Îµ2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(Î», Ï†) {
    Î» *= d3_radians;
    var cosÏ† = Math.cos(Ï† *= d3_radians);
    d3_geo_centroidPointXYZ(cosÏ† * Math.cos(Î»), cosÏ† * Math.sin(Î»), Math.sin(Ï†));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(Î», Ï†) {
      Î» *= d3_radians;
      var cosÏ† = Math.cos(Ï† *= d3_radians);
      x0 = cosÏ† * Math.cos(Î»);
      y0 = cosÏ† * Math.sin(Î»);
      z0 = Math.sin(Ï†);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(Î», Ï†) {
      Î» *= d3_radians;
      var cosÏ† = Math.cos(Ï† *= d3_radians), x = cosÏ† * Math.cos(Î»), y = cosÏ† * Math.sin(Î»), z = Math.sin(Ï†), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var Î»00, Ï†00, x0, y0, z0;
    d3_geo_centroid.point = function(Î», Ï†) {
      Î»00 = Î», Ï†00 = Ï†;
      d3_geo_centroid.point = nextPoint;
      Î» *= d3_radians;
      var cosÏ† = Math.cos(Ï† *= d3_radians);
      x0 = cosÏ† * Math.cos(Î»);
      y0 = cosÏ† * Math.sin(Î»);
      z0 = Math.sin(Ï†);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(Î»00, Ï†00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(Î», Ï†) {
      Î» *= d3_radians;
      var cosÏ† = Math.cos(Ï† *= d3_radians), x = cosÏ† * Math.cos(Î»), y = cosÏ† * Math.sin(Î»), z = Math.sin(Ï†), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
          listener.polygonStart();
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          listener.polygonEnd();
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(Î», Ï†) {
        var point = rotate(Î», Ï†);
        if (pointVisible(Î» = point[0], Ï† = point[1])) listener.point(Î», Ï†);
      }
      function pointLine(Î», Ï†) {
        var point = rotate(Î», Ï†);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygon, ring;
      function pointRing(Î», Ï†) {
        ring.push([ Î», Ï† ]);
        var point = rotate(Î», Ï†);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          listener.lineStart();
          while (++i < n) listener.point((point = segment[i])[0], point[1]);
          listener.lineEnd();
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(Î», Ï†) {
        line.push([ Î», Ï† ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfÏ€ - Îµ : halfÏ€ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfÏ€ - Îµ : halfÏ€ - b[1]);
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], Î»0 = point0[0], Ï†0 = point0[1] / 2 + Ï€ / 4, sinÏ†0 = Math.sin(Ï†0), cosÏ†0 = Math.cos(Ï†0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var Î» = point[0], Ï† = point[1] / 2 + Ï€ / 4, sinÏ† = Math.sin(Ï†), cosÏ† = Math.cos(Ï†), dÎ» = Î» - Î»0, antimeridian = abs(dÎ») > Ï€, k = sinÏ†0 * sinÏ†;
        d3_geo_areaRingSum.add(Math.atan2(k * Math.sin(dÎ»), cosÏ†0 * cosÏ† + k * Math.cos(dÎ»)));
        polarAngle += antimeridian ? dÎ» + (dÎ» >= 0 ? Ï„ : -Ï„) : dÎ»;
        if (antimeridian ^ Î»0 >= meridian ^ Î» >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var Ï†arc = (antimeridian ^ dÎ» >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > Ï†arc || parallel === Ï†arc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dÎ» >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        Î»0 = Î», sinÏ†0 = sinÏ†, cosÏ†0 = cosÏ†, point0 = point;
      }
    }
    return (polarAngle < -Îµ || polarAngle < Îµ && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -Ï€, -Ï€ / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var Î»0 = NaN, Ï†0 = NaN, sÎ»0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(Î»1, Ï†1) {
        var sÎ»1 = Î»1 > 0 ? Ï€ : -Ï€, dÎ» = abs(Î»1 - Î»0);
        if (abs(dÎ» - Ï€) < Îµ) {
          listener.point(Î»0, Ï†0 = (Ï†0 + Ï†1) / 2 > 0 ? halfÏ€ : -halfÏ€);
          listener.point(sÎ»0, Ï†0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sÎ»1, Ï†0);
          listener.point(Î»1, Ï†0);
          clean = 0;
        } else if (sÎ»0 !== sÎ»1 && dÎ» >= Ï€) {
          if (abs(Î»0 - sÎ»0) < Îµ) Î»0 -= sÎ»0 * Îµ;
          if (abs(Î»1 - sÎ»1) < Îµ) Î»1 -= sÎ»1 * Îµ;
          Ï†0 = d3_geo_clipAntimeridianIntersect(Î»0, Ï†0, Î»1, Ï†1);
          listener.point(sÎ»0, Ï†0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sÎ»1, Ï†0);
          clean = 0;
        }
        listener.point(Î»0 = Î»1, Ï†0 = Ï†1);
        sÎ»0 = sÎ»1;
      },
      lineEnd: function() {
        listener.lineEnd();
        Î»0 = Ï†0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(Î»0, Ï†0, Î»1, Ï†1) {
    var cosÏ†0, cosÏ†1, sinÎ»0_Î»1 = Math.sin(Î»0 - Î»1);
    return abs(sinÎ»0_Î»1) > Îµ ? Math.atan((Math.sin(Ï†0) * (cosÏ†1 = Math.cos(Ï†1)) * Math.sin(Î»1) - Math.sin(Ï†1) * (cosÏ†0 = Math.cos(Ï†0)) * Math.sin(Î»0)) / (cosÏ†0 * cosÏ†1 * sinÎ»0_Î»1)) : (Ï†0 + Ï†1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var Ï†;
    if (from == null) {
      Ï† = direction * halfÏ€;
      listener.point(-Ï€, Ï†);
      listener.point(0, Ï†);
      listener.point(Ï€, Ï†);
      listener.point(Ï€, 0);
      listener.point(Ï€, -Ï†);
      listener.point(0, -Ï†);
      listener.point(-Ï€, -Ï†);
      listener.point(-Ï€, 0);
      listener.point(-Ï€, Ï†);
    } else if (abs(from[0] - to[0]) > Îµ) {
      var s = from[0] < to[0] ? Ï€ : -Ï€;
      Ï† = direction * s / 2;
      listener.point(-s, Ï†);
      listener.point(0, Ï†);
      listener.point(s, Ï†);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > Îµ, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -Ï€, radius - Ï€ ]);
    function visible(Î», Ï†) {
      return Math.cos(Î») * Math.cos(Ï†) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(Î», Ï†) {
          var point1 = [ Î», Ï† ], point2, v = visible(Î», Ï†), c = smallRadius ? v ? 0 : code(Î», Ï†) : v ? code(Î» + (Î» < 0 ? Ï€ : -Ï€), Ï†) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += Îµ;
              point1[1] += Îµ;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var Î»0 = a[0], Î»1 = b[0], Ï†0 = a[1], Ï†1 = b[1], z;
      if (Î»1 < Î»0) z = Î»0, Î»0 = Î»1, Î»1 = z;
      var Î´Î» = Î»1 - Î»0, polar = abs(Î´Î» - Ï€) < Îµ, meridian = polar || Î´Î» < Îµ;
      if (!polar && Ï†1 < Ï†0) z = Ï†0, Ï†0 = Ï†1, Ï†1 = z;
      if (meridian ? polar ? Ï†0 + Ï†1 > 0 ^ q[1] < (abs(q[0] - Î»0) < Îµ ? Ï†0 : Ï†1) : Ï†0 <= q[1] && q[1] <= Ï†1 : Î´Î» > Ï€ ^ (Î»0 <= q[0] && q[0] <= Î»1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(Î», Ï†) {
      var r = smallRadius ? radius : Ï€ - radius, code = 0;
      if (Î» < -r) code |= 1; else if (Î» > r) code |= 2;
      if (Ï† < -r) code |= 4; else if (Ï† > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && isLeft(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && isLeft(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function isLeft(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < Îµ ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < Îµ ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < Îµ ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_geo_conic(projectAt) {
    var Ï†0 = 0, Ï†1 = Ï€ / 3, m = d3_geo_projectionMutator(projectAt), p = m(Ï†0, Ï†1);
    p.parallels = function(_) {
      if (!arguments.length) return [ Ï†0 / Ï€ * 180, Ï†1 / Ï€ * 180 ];
      return m(Ï†0 = _[0] * Ï€ / 180, Ï†1 = _[1] * Ï€ / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(Ï†0, Ï†1) {
    var sinÏ†0 = Math.sin(Ï†0), n = (sinÏ†0 + Math.sin(Ï†1)) / 2, C = 1 + sinÏ†0 * (2 * n - sinÏ†0), Ï0 = Math.sqrt(C) / n;
    function forward(Î», Ï†) {
      var Ï = Math.sqrt(C - 2 * n * Math.sin(Ï†)) / n;
      return [ Ï * Math.sin(Î» *= n), Ï0 - Ï * Math.cos(Î») ];
    }
    forward.invert = function(x, y) {
      var Ï0_y = Ï0 - y;
      return [ Math.atan2(x, Ï0_y) / n, d3_asin((C - (x * x + Ï0_y * Ï0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + Îµ, y + .12 * k + Îµ ], [ x - .214 * k - Îµ, y + .234 * k - Îµ ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + Îµ, y + .166 * k + Îµ ], [ x - .115 * k - Îµ, y + .234 * k - Îµ ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x, y);
      context.arc(x, y, pointRadius, 0, Ï„);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var Î´2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var Î»00, Ï†00, x00, y00, a00, b00, c00, Î»0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(Î», Ï†) {
        var c = d3_geo_cartesian([ Î», Ï† ]), p = project(Î», Ï†);
        resampleLineTo(x0, y0, Î»0, a0, b0, c0, x0 = p[0], y0 = p[1], Î»0 = Î», a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(Î», Ï†) {
        linePoint(Î»00 = Î», Ï†00 = Ï†), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, Î»0, a0, b0, c0, x00, y00, Î»00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, Î»0, a0, b0, c0, x1, y1, Î»1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * Î´2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), Ï†2 = Math.asin(c /= m), Î»2 = abs(abs(c) - 1) < Îµ || abs(Î»0 - Î»1) < Îµ ? (Î»0 + Î»1) / 2 : Math.atan2(b, a), p = project(Î»2, Ï†2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > Î´2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, Î»0, a0, b0, c0, x2, y2, Î»2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, Î»2, a, b, c, x1, y1, Î»1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(Î´2);
      maxDepth = (Î´2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + Î´x, Î´y - x[1] * k ];
    }), k = 150, x = 480, y = 250, Î» = 0, Ï† = 0, Î´Î» = 0, Î´Ï† = 0, Î´Î³ = 0, Î´x, Î´y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + Î´x, Î´y - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - Î´x) / k, (Î´y - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ Î» * d3_degrees, Ï† * d3_degrees ];
      Î» = _[0] % 360 * d3_radians;
      Ï† = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ Î´Î» * d3_degrees, Î´Ï† * d3_degrees, Î´Î³ * d3_degrees ];
      Î´Î» = _[0] % 360 * d3_radians;
      Î´Ï† = _[1] % 360 * d3_radians;
      Î´Î³ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(Î´Î», Î´Ï†, Î´Î³), project);
      var center = project(Î», Ï†);
      Î´x = x - center[0] * k;
      Î´y = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(Î», Ï†) {
    return [ Î», Ï† ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(Î», Ï†) {
    return [ Î» > Ï€ ? Î» - Ï„ : Î» < -Ï€ ? Î» + Ï„ : Î», Ï† ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(Î´Î», Î´Ï†, Î´Î³) {
    return Î´Î» ? Î´Ï† || Î´Î³ ? d3_geo_compose(d3_geo_rotationÎ»(Î´Î»), d3_geo_rotationÏ†Î³(Î´Ï†, Î´Î³)) : d3_geo_rotationÎ»(Î´Î») : Î´Ï† || Î´Î³ ? d3_geo_rotationÏ†Î³(Î´Ï†, Î´Î³) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationÎ»(Î´Î») {
    return function(Î», Ï†) {
      return Î» += Î´Î», [ Î» > Ï€ ? Î» - Ï„ : Î» < -Ï€ ? Î» + Ï„ : Î», Ï† ];
    };
  }
  function d3_geo_rotationÎ»(Î´Î») {
    var rotation = d3_geo_forwardRotationÎ»(Î´Î»);
    rotation.invert = d3_geo_forwardRotationÎ»(-Î´Î»);
    return rotation;
  }
  function d3_geo_rotationÏ†Î³(Î´Ï†, Î´Î³) {
    var cosÎ´Ï† = Math.cos(Î´Ï†), sinÎ´Ï† = Math.sin(Î´Ï†), cosÎ´Î³ = Math.cos(Î´Î³), sinÎ´Î³ = Math.sin(Î´Î³);
    function rotation(Î», Ï†) {
      var cosÏ† = Math.cos(Ï†), x = Math.cos(Î») * cosÏ†, y = Math.sin(Î») * cosÏ†, z = Math.sin(Ï†), k = z * cosÎ´Ï† + x * sinÎ´Ï†;
      return [ Math.atan2(y * cosÎ´Î³ - k * sinÎ´Î³, x * cosÎ´Ï† - z * sinÎ´Ï†), d3_asin(k * cosÎ´Î³ + y * sinÎ´Î³) ];
    }
    rotation.invert = function(Î», Ï†) {
      var cosÏ† = Math.cos(Ï†), x = Math.cos(Î») * cosÏ†, y = Math.sin(Î») * cosÏ†, z = Math.sin(Ï†), k = z * cosÎ´Î³ - y * sinÎ´Î³;
      return [ Math.atan2(y * cosÎ´Î³ + z * sinÎ´Î³, x * cosÎ´Ï† + k * sinÎ´Ï†), d3_asin(k * cosÎ´Ï† - x * sinÎ´Ï†) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * Ï„;
      } else {
        from = radius + direction * Ï„;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - Îµ) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Î”Î» = (b[0] - a[0]) * d3_radians, Ï†0 = a[1] * d3_radians, Ï†1 = b[1] * d3_radians, sinÎ”Î» = Math.sin(Î”Î»), cosÎ”Î» = Math.cos(Î”Î»), sinÏ†0 = Math.sin(Ï†0), cosÏ†0 = Math.cos(Ï†0), sinÏ†1 = Math.sin(Ï†1), cosÏ†1 = Math.cos(Ï†1), t;
    return Math.atan2(Math.sqrt((t = cosÏ†1 * sinÎ”Î») * t + (t = cosÏ†0 * sinÏ†1 - sinÏ†0 * cosÏ†1 * cosÎ”Î») * t), sinÏ†0 * sinÏ†1 + cosÏ†0 * cosÏ†1 * cosÎ”Î»);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > Îµ;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > Îµ;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + Îµ ], [ 180, 90 - Îµ ] ]).minorExtent([ [ -180, -80 - Îµ ], [ 180, 80 + Îµ ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - Îµ, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - Îµ, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var Î»0, sinÏ†0, cosÏ†0;
    d3_geo_length.point = function(Î», Ï†) {
      Î»0 = Î» * d3_radians, sinÏ†0 = Math.sin(Ï† *= d3_radians), cosÏ†0 = Math.cos(Ï†);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(Î», Ï†) {
      var sinÏ† = Math.sin(Ï† *= d3_radians), cosÏ† = Math.cos(Ï†), t = abs((Î» *= d3_radians) - Î»0), cosÎ”Î» = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosÏ† * Math.sin(t)) * t + (t = cosÏ†0 * sinÏ† - sinÏ†0 * cosÏ† * cosÎ”Î») * t), sinÏ†0 * sinÏ† + cosÏ†0 * cosÏ† * cosÎ”Î»);
      Î»0 = Î», sinÏ†0 = sinÏ†, cosÏ†0 = cosÏ†;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(Î», Ï†) {
      var cosÎ» = Math.cos(Î»), cosÏ† = Math.cos(Ï†), k = scale(cosÎ» * cosÏ†);
      return [ k * cosÏ† * Math.sin(Î»), k * Math.sin(Ï†) ];
    }
    azimuthal.invert = function(x, y) {
      var Ï = Math.sqrt(x * x + y * y), c = angle(Ï), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, Ï * cosc), Math.asin(Ï && y * sinc / Ï) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosÎ»cosÏ†) {
    return Math.sqrt(2 / (1 + cosÎ»cosÏ†));
  }, function(Ï) {
    return 2 * Math.asin(Ï / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosÎ»cosÏ†) {
    var c = Math.acos(cosÎ»cosÏ†);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(Ï†0, Ï†1) {
    var cosÏ†0 = Math.cos(Ï†0), t = function(Ï†) {
      return Math.tan(Ï€ / 4 + Ï† / 2);
    }, n = Ï†0 === Ï†1 ? Math.sin(Ï†0) : Math.log(cosÏ†0 / Math.cos(Ï†1)) / Math.log(t(Ï†1) / t(Ï†0)), F = cosÏ†0 * Math.pow(t(Ï†0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(Î», Ï†) {
      var Ï = abs(abs(Ï†) - halfÏ€) < Îµ ? 0 : F / Math.pow(t(Ï†), n);
      return [ Ï * Math.sin(n * Î»), F - Ï * Math.cos(n * Î») ];
    }
    forward.invert = function(x, y) {
      var Ï0_y = F - y, Ï = d3_sgn(n) * Math.sqrt(x * x + Ï0_y * Ï0_y);
      return [ Math.atan2(x, Ï0_y) / n, 2 * Math.atan(Math.pow(F / Ï, 1 / n)) - halfÏ€ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(Ï†0, Ï†1) {
    var cosÏ†0 = Math.cos(Ï†0), n = Ï†0 === Ï†1 ? Math.sin(Ï†0) : (cosÏ†0 - Math.cos(Ï†1)) / (Ï†1 - Ï†0), G = cosÏ†0 / n + Ï†0;
    if (abs(n) < Îµ) return d3_geo_equirectangular;
    function forward(Î», Ï†) {
      var Ï = G - Ï†;
      return [ Ï * Math.sin(n * Î»), G - Ï * Math.cos(n * Î») ];
    }
    forward.invert = function(x, y) {
      var Ï0_y = G - y;
      return [ Math.atan2(x, Ï0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + Ï0_y * Ï0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosÎ»cosÏ†) {
    return 1 / cosÎ»cosÏ†;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(Î», Ï†) {
    return [ Î», Math.log(Math.tan(Ï€ / 4 + Ï† / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfÏ€ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = Ï€ * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosÎ»cosÏ†) {
    return 1 / (1 + cosÎ»cosÏ†);
  }, function(Ï) {
    return 2 * Math.atan(Ï);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(Î», Ï†) {
    return [ Math.log(Math.tan(Ï€ / 4 + Ï† / 2)), -Î» ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfÏ€ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ -_[1], _[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return projection.rotate([ 0, 0 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), n = data.length, vertices, plen = n - 1, points = [], stack = [], d, i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;
      if (fx === d3_geom_pointX && y === d3_geom_pointY) vertices = data; else for (i = 0, 
      vertices = []; i < n; ++i) {
        vertices.push([ +fx.call(this, d = data[i], i), +fy.call(this, d, i) ]);
      }
      for (i = 1; i < n; ++i) {
        if (vertices[i][1] < vertices[h][1] || vertices[i][1] == vertices[h][1] && vertices[i][0] < vertices[h][0]) h = i;
      }
      for (i = 0; i < n; ++i) {
        if (i === h) continue;
        y1 = vertices[i][1] - vertices[h][1];
        x1 = vertices[i][0] - vertices[h][0];
        points.push({
          angle: Math.atan2(y1, x1),
          index: i
        });
      }
      points.sort(function(a, b) {
        return a.angle - b.angle;
      });
      a = points[0].angle;
      v = points[0].index;
      u = 0;
      for (i = 1; i < plen; ++i) {
        j = points[i].index;
        if (a == points[i].angle) {
          x1 = vertices[v][0] - vertices[h][0];
          y1 = vertices[v][1] - vertices[h][1];
          x2 = vertices[j][0] - vertices[h][0];
          y2 = vertices[j][1] - vertices[h][1];
          if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
            points[i].index = -1;
            continue;
          } else {
            points[u].index = -1;
          }
        }
        a = points[i].angle;
        u = i;
        v = j;
      }
      stack.push(h);
      for (i = 0, j = 0; i < 2; ++j) {
        if (points[j].index > -1) {
          stack.push(points[j].index);
          i++;
        }
      }
      sp = stack.length;
      for (;j < plen; ++j) {
        if (points[j].index < 0) continue;
        while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {
          --sp;
        }
        stack[sp++] = points[j].index;
      }
      var poly = [];
      for (i = sp - 1; i >= 0; --i) poly.push(data[stack[i]]);
      return poly;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullCCW(i1, i2, i3, v) {
    var t, a, b, c, d, e, f;
    t = v[i1];
    a = t[0];
    b = t[1];
    t = v[i2];
    c = t[0];
    d = t[1];
    t = v[i3];
    e = t[0];
    f = t[1];
    return (f - b) * (c - a) - (d - b) * (e - a) > 0;
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < Îµ && abs(y - lArc.circle.cy) < Îµ) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < Îµ && abs(y - rArc.circle.cy) < Îµ) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > Îµ) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > Îµ) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -Îµ) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -Îµ) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > Îµ || abs(y3 - y2) > Îµ) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < Îµ && y1 - y3 > Îµ ? {
            x: x0,
            y: abs(x2 - x0) < Îµ ? y2 : y1
          } : abs(y3 - y1) < Îµ && x1 - x3 > Îµ ? {
            x: abs(y2 - y1) < Îµ ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < Îµ && y3 - y0 > Îµ ? {
            x: x1,
            y: abs(x2 - x1) < Îµ ? y2 : y0
          } : abs(y3 - y0) < Îµ && x3 - x0 > Îµ ? {
            x: abs(y2 - y0) < Îµ ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -Îµ2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < Îµ && abs(e.a.y - e.b.y) < Îµ) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / Îµ) * Îµ,
          y: Math.round(fy(d, i) / Îµ) * Îµ,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = x >= sx, bottom = y >= sy, i = (bottom << 1) + right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = sx; else x2 = sx;
        if (bottom) y1 = sy; else y2 = sy;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    b -= a = +a;
    return function(t) {
      return a + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
    a = a + "", b = b + "";
    d3_interpolate_number.lastIndex = 0;
    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
      if (m.index) s.push(b.substring(s0, s1 = m.index));
      q.push({
        i: s.length,
        x: m[0]
      });
      s.push(null);
      s0 = d3_interpolate_number.lastIndex;
    }
    if (s0 < b.length) s.push(b.substring(s0));
    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
      o = q[i];
      if (o.x == m[0]) {
        if (o.i) {
          if (s[o.i + 1] == null) {
            s[o.i - 1] += o.x;
            s.splice(o.i, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          } else {
            s[o.i - 1] += o.x + s[o.i + 1];
            s.splice(o.i, 2);
            for (j = i + 1; j < n; ++j) q[j].i -= 2;
          }
        } else {
          if (s[o.i + 1] == null) {
            s[o.i] = o.x;
          } else {
            s[o.i] = o.x + s[o.i + 1];
            s.splice(o.i + 1, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          }
        }
        q.splice(i, 1);
        n--;
        i--;
      } else {
        o.x = d3_interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
      }
    }
    while (i < n) {
      o = q.pop();
      if (s[o.i + 1] == null) {
        s[o.i] = o.x;
      } else {
        s[o.i] = o.x + s[o.i + 1];
        s.splice(o.i + 1, 1);
      }
      n--;
    }
    if (s.length === 1) {
      return s[0] == null ? (o = q[0].x, function(t) {
        return o(t) + "";
      }) : function() {
        return b;
      };
    }
    return function(t) {
      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_Color ? d3_interpolateRgb : t === "object" ? Array.isArray(b) ? d3_interpolateArray : d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfÏ€);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / Ï„ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * Ï„ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransform(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return (x - a) * b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) * b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (Ï„ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);
          if ((x2 - x1) * dn < theta) {
            var k = quad.charge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
            return true;
          }
          if (quad.point && isFinite(dn)) {
            var k = quad.pointCharge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return theta;
      theta = +x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, m = candidates.length, x;
        while (++j < m) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function recurse(node, depth, nodes) {
      var childs = children.call(hierarchy, node, depth);
      node.depth = depth;
      nodes.push(node);
      if (childs && (n = childs.length)) {
        var i = -1, n, c = node.children = new Array(n), v = 0, j = depth + 1, d;
        while (++i < n) {
          d = c[i] = recurse(childs[i], j, nodes);
          d.parent = node;
          v += d.value;
        }
        if (sort) c.sort(sort);
        if (value) node.value = v;
      } else {
        delete node.children;
        if (value) {
          node.value = +value.call(hierarchy, node, depth) || 0;
        }
      }
      return node;
    }
    function revalue(node, depth) {
      var children = node.children, v = 0;
      if (children && (n = children.length)) {
        var i = -1, n, j = depth + 1;
        while (++i < n) v += revalue(children[i], j);
      } else if (value) {
        v = +value.call(hierarchy, node, depth) || 0;
      }
      if (value) node.value = v;
      return v;
    }
    function hierarchy(d) {
      var nodes = [];
      recurse(d, 0, nodes);
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      revalue(root, 0);
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = Ï„;
    function pie(data) {
      var values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      });
      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a) / d3.sum(values);
      var index = d3.range(data.length);
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      var arcs = [];
      index.forEach(function(i) {
        var d;
        arcs[i] = {
          data: data[i],
          value: d = values[i],
          startAngle: a,
          endAngle: a += d * k
        };
      });
      return arcs;
    }
    pie.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return pie;
    };
    pie.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return pie;
    };
    pie.startAngle = function(x) {
      if (!arguments.length) return startAngle;
      startAngle = x;
      return pie;
    };
    pie.endAngle = function(x) {
      if (!arguments.length) return endAngle;
      endAngle = x;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var n = series.length, m = series[0].length, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      function firstWalk(node, previousSibling) {
        var children = node.children, layout = node._tree;
        if (children && (n = children.length)) {
          var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
          while (++i < n) {
            child = children[i];
            firstWalk(child, previousChild);
            ancestor = apportion(child, previousChild, ancestor);
            previousChild = child;
          }
          d3_layout_treeShift(node);
          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
            layout.mod = layout.prelim - midpoint;
          } else {
            layout.prelim = midpoint;
          }
        } else {
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          }
        }
      }
      function secondWalk(node, x) {
        node.x = node._tree.prelim + x;
        var children = node.children;
        if (children && (n = children.length)) {
          var i = -1, n;
          x += node._tree.mod;
          while (++i < n) {
            secondWalk(children[i], x);
          }
        }
      }
      function apportion(node, previousSibling, ancestor) {
        if (previousSibling) {
          var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
            vom = d3_layout_treeLeft(vom);
            vop = d3_layout_treeRight(vop);
            vop._tree.ancestor = node;
            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
            if (shift > 0) {
              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim._tree.mod;
            sip += vip._tree.mod;
            som += vom._tree.mod;
            sop += vop._tree.mod;
          }
          if (vim && !d3_layout_treeRight(vop)) {
            vop._tree.thread = vim;
            vop._tree.mod += sim - sop;
          }
          if (vip && !d3_layout_treeLeft(vom)) {
            vom._tree.thread = vip;
            vom._tree.mod += sip - som;
            ancestor = node;
          }
        }
        return ancestor;
      }
      d3_layout_treeVisitAfter(root, function(node, previousSibling) {
        node._tree = {
          ancestor: node,
          prelim: 0,
          mod: 0,
          change: 0,
          shift: 0,
          number: previousSibling ? previousSibling._tree.number + 1 : 0
        };
      });
      firstWalk(root);
      secondWalk(root, -root._tree.prelim);
      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;
      d3_layout_treeVisitAfter(root, nodeSize ? function(node) {
        node.x *= size[0];
        node.y = node.depth * size[1];
        delete node._tree;
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = node.depth / y1 * size[1];
        delete node._tree;
      });
      return nodes;
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(node) {
    var children = node.children;
    return children && children.length ? children[0] : node._tree.thread;
  }
  function d3_layout_treeRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? children[n - 1] : node._tree.thread;
  }
  function d3_layout_treeSearch(node, compare) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child, n, i = -1;
      while (++i < n) {
        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
          node = child;
        }
      }
    }
    return node;
  }
  function d3_layout_treeRightmost(a, b) {
    return a.x - b.x;
  }
  function d3_layout_treeLeftmost(a, b) {
    return b.x - a.x;
  }
  function d3_layout_treeDeepest(a, b) {
    return a.depth - b.depth;
  }
  function d3_layout_treeVisitAfter(node, callback) {
    function visit(node, previousSibling) {
      var children = node.children;
      if (children && (n = children.length)) {
        var child, previousChild = null, i = -1, n;
        while (++i < n) {
          child = children[i];
          visit(child, previousChild);
          previousChild = child;
        }
      }
      callback(node, previousSibling);
    }
    visit(node, null);
  }
  function d3_layout_treeShift(node) {
    var shift = 0, change = 0, children = node.children, i = children.length, child;
    while (--i >= 0) {
      child = children[i]._tree;
      child.prelim += shift;
      child.mod += shift;
      shift += child.shift + (change += child.change);
    }
  }
  function d3_layout_treeMove(ancestor, node, shift) {
    ancestor = ancestor._tree;
    node = node._tree;
    var change = shift / (node.number - ancestor.number);
    ancestor.change += change;
    node.change -= change;
    node.shift += shift;
    node.prelim += shift;
    node.mod += shift;
  }
  function d3_layout_treeAncestor(vim, node, ancestor) {
    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_treeVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_treeVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
        d3_layout_treeVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_treeVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_treeVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(Âµ, Ïƒ) {
      var n = arguments.length;
      if (n < 2) Ïƒ = 1;
      if (n < 1) Âµ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return Âµ + Ïƒ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    return d3.format(format ? format.replace(d3_format_re, function(a, b, c, d, e, f, g, h, i, j) {
      return [ b, c, d, e, f, g, h, i || "." + d3_scale_linearFormatPrecision(j, range), j ].join("");
    }) : ",." + d3_scale_linearPrecision(range[2]) + "f");
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(Math.abs(range[0]), Math.abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
      Math.floor), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || ranger.t === "range" && index.set(x, domain.push(x))) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
      range = steps(start + Math.round(error / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.filter(function(d) {
        return !isNaN(d);
      }).sort(d3.ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function arc() {
      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
      a0 = a1, a1 = da), a1 - a0), df = da < Ï€ ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcOffset = -halfÏ€, d3_svg_arcMax = Ï„ - Îµ;
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < Îµ) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] + d3_svg_arcOffset;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > Ï€) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / Ï€);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  function d3_transition(groups, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection) {
    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, id, node.__transition__[id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node.__transition__[id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id;
    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node.__transition__[id].tween.remove(name);
    } : function(node) {
      node.__transition__[id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node.__transition__[id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    return this.each("end.transition", function() {
      var p;
      if (this.__transition__.count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node.__transition__[id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node.__transition__[id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node.__transition__[id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      d3_transitionInheritId = id;
      d3_selection_each(this, function(node, i, j) {
        d3_transitionInherit = node.__transition__[id];
        type.call(node, node.__data__, i, j);
      });
      d3_transitionInherit = inherit;
      d3_transitionInheritId = inheritId;
    } else {
      d3_selection_each(this, function(node) {
        var transition = node.__transition__[id];
        (transition.event || (transition.event = d3.dispatch("start", "end"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = Object.create(node.__transition__[id0]);
          transition.delay += transition.duration;
          d3_transitionNode(node, i, id1, transition);
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id1);
  };
  function d3_transitionNode(node, i, id, inherit) {
    var lock = node.__transition__ || (node.__transition__ = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        ease: inherit.ease,
        delay: inherit.delay,
        duration: inherit.duration
      };
      ++lock.count;
      d3.timer(function(elapsed) {
        var d = node.__data__, ease = transition.ease, delay = transition.delay, duration = transition.duration, timer = d3_timer_active, tweened = [];
        timer.t = delay + time;
        if (delay <= elapsed) return start(elapsed - delay);
        timer.c = start;
        function start(elapsed) {
          if (lock.active > id) return stop();
          lock.active = id;
          transition.event && transition.event.start.call(node, d, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, d, i)) {
              tweened.push(value);
            }
          });
          d3.timer(function() {
            timer.c = tick(elapsed || 1) ? d3_true : tick;
            return 1;
          }, 0, time);
        }
        function tick(elapsed) {
          if (lock.active !== id) return stop();
          var t = elapsed / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, d, i);
            return stop();
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node.__transition__;
          return 1;
        }
      }, 0, time);
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", Îµ), tickExit = d3.transition(tick.exit()).style("opacity", Îµ).remove(), tickUpdate = d3.transition(tick).style("opacity", 1), tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
        switch (orient) {
         case "bottom":
          {
            tickTransform = d3_svg_axisX;
            lineEnter.attr("y2", innerTickSize);
            textEnter.attr("y", Math.max(innerTickSize, 0) + tickPadding);
            lineUpdate.attr("x2", 0).attr("y2", innerTickSize);
            textUpdate.attr("x", 0).attr("y", Math.max(innerTickSize, 0) + tickPadding);
            text.attr("dy", ".71em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize);
            break;
          }

         case "top":
          {
            tickTransform = d3_svg_axisX;
            lineEnter.attr("y2", -innerTickSize);
            textEnter.attr("y", -(Math.max(innerTickSize, 0) + tickPadding));
            lineUpdate.attr("x2", 0).attr("y2", -innerTickSize);
            textUpdate.attr("x", 0).attr("y", -(Math.max(innerTickSize, 0) + tickPadding));
            text.attr("dy", "0em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize);
            break;
          }

         case "left":
          {
            tickTransform = d3_svg_axisY;
            lineEnter.attr("x2", -innerTickSize);
            textEnter.attr("x", -(Math.max(innerTickSize, 0) + tickPadding));
            lineUpdate.attr("x2", -innerTickSize).attr("y2", 0);
            textUpdate.attr("x", -(Math.max(innerTickSize, 0) + tickPadding)).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "end");
            pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize);
            break;
          }

         case "right":
          {
            tickTransform = d3_svg_axisY;
            lineEnter.attr("x2", innerTickSize);
            textEnter.attr("x", Math.max(innerTickSize, 0) + tickPadding);
            lineUpdate.attr("x2", innerTickSize).attr("y2", 0);
            textUpdate.attr("x", Math.max(innerTickSize, 0) + tickPadding).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "start");
            pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize);
            break;
          }
        }
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1);
        }
        tickEnter.call(tickTransform, scale0);
        tickUpdate.call(tickTransform, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x) {
    selection.attr("transform", function(d) {
      return "translate(" + x(d) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y) {
    selection.attr("transform", function(d) {
      return "translate(0," + y(d) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time = d3.time = {}, d3_date = Date, d3_time_daySymbols = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  var d3_time_formatDateTime = "%a %b %e %X %Y", d3_time_formatDate = "%m/%d/%Y", d3_time_formatTime = "%H:%M:%S";
  var d3_time_days = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], d3_time_dayAbbreviations = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], d3_time_months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], d3_time_monthAbbreviations = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  d3_time_daySymbols.forEach(function(day, i) {
    day = day.toLowerCase();
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  d3_time.format = d3_time_format;
  function d3_time_format(template) {
    var n = template.length;
    function format(date) {
      var string = [], i = -1, j = 0, c, p, f;
      while (++i < n) {
        if (template.charCodeAt(i) === 37) {
          string.push(template.substring(j, i));
          if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
          if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(template.substring(j, i));
      return string.join("");
    }
    format.parse = function(string) {
      var d = {
        y: 1900,
        m: 0,
        d: 1,
        H: 0,
        M: 0,
        S: 0,
        L: 0,
        Z: null
      }, i = d3_time_parse(d, template, string, 0);
      if (i != string.length) return null;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
      if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
        date.setFullYear(d.y, 0, 1);
        date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
      } else date.setFullYear(d.y, d.m, d.d);
      date.setHours(d.H + Math.floor(d.Z / 100), d.M + d.Z % 100, d.S, d.L);
      return localZ ? date._ : date;
    };
    format.toString = function() {
      return template;
    };
    return format;
  }
  function d3_time_parse(date, template, string, j) {
    var c, p, t, i = 0, n = template.length, m = string.length;
    while (i < n) {
      if (j >= m) return -1;
      c = template.charCodeAt(i++);
      if (c === 37) {
        t = template.charAt(i++);
        p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
        if (!p || (j = p(date, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayLookup = d3_time_formatLookup(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_dayAbbrevLookup = d3_time_formatLookup(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations), d3_time_percentRe = /^%/;
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  };
  var d3_time_formats = {
    a: function(d) {
      return d3_time_dayAbbreviations[d.getDay()];
    },
    A: function(d) {
      return d3_time_days[d.getDay()];
    },
    b: function(d) {
      return d3_time_monthAbbreviations[d.getMonth()];
    },
    B: function(d) {
      return d3_time_months[d.getMonth()];
    },
    c: d3_time_format(d3_time_formatDateTime),
    d: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    e: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    H: function(d, p) {
      return d3_time_formatPad(d.getHours(), p, 2);
    },
    I: function(d, p) {
      return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
    },
    j: function(d, p) {
      return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
    },
    L: function(d, p) {
      return d3_time_formatPad(d.getMilliseconds(), p, 3);
    },
    m: function(d, p) {
      return d3_time_formatPad(d.getMonth() + 1, p, 2);
    },
    M: function(d, p) {
      return d3_time_formatPad(d.getMinutes(), p, 2);
    },
    p: function(d) {
      return d.getHours() >= 12 ? "PM" : "AM";
    },
    S: function(d, p) {
      return d3_time_formatPad(d.getSeconds(), p, 2);
    },
    U: function(d, p) {
      return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
    },
    w: function(d) {
      return d.getDay();
    },
    W: function(d, p) {
      return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
    },
    x: d3_time_format(d3_time_formatDate),
    X: d3_time_format(d3_time_formatTime),
    y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 100, p, 2);
    },
    Y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
    },
    Z: d3_time_zone,
    "%": function() {
      return "%";
    }
  };
  var d3_time_parsers = {
    a: d3_time_parseWeekdayAbbrev,
    A: d3_time_parseWeekday,
    b: d3_time_parseMonthAbbrev,
    B: d3_time_parseMonth,
    c: d3_time_parseLocaleFull,
    d: d3_time_parseDay,
    e: d3_time_parseDay,
    H: d3_time_parseHour24,
    I: d3_time_parseHour24,
    j: d3_time_parseDayOfYear,
    L: d3_time_parseMilliseconds,
    m: d3_time_parseMonthNumber,
    M: d3_time_parseMinutes,
    p: d3_time_parseAmPm,
    S: d3_time_parseSeconds,
    U: d3_time_parseWeekNumberSunday,
    w: d3_time_parseWeekdayNumber,
    W: d3_time_parseWeekNumberMonday,
    x: d3_time_parseLocaleDate,
    X: d3_time_parseLocaleTime,
    y: d3_time_parseYear,
    Y: d3_time_parseFullYear,
    Z: d3_time_parseZone,
    "%": d3_time_parseLiteralPercent
  };
  function d3_time_parseWeekdayAbbrev(date, string, i) {
    d3_time_dayAbbrevRe.lastIndex = 0;
    var n = d3_time_dayAbbrevRe.exec(string.substring(i));
    return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function d3_time_parseWeekday(date, string, i) {
    d3_time_dayRe.lastIndex = 0;
    var n = d3_time_dayRe.exec(string.substring(i));
    return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMonthAbbrev(date, string, i) {
    d3_time_monthAbbrevRe.lastIndex = 0;
    var n = d3_time_monthAbbrevRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function d3_time_parseMonth(date, string, i) {
    d3_time_monthRe.lastIndex = 0;
    var n = d3_time_monthRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function d3_time_parseLocaleFull(date, string, i) {
    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
  }
  function d3_time_parseLocaleDate(date, string, i) {
    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
  }
  function d3_time_parseLocaleTime(date, string, i) {
    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.substring(i, i + 5)) ? (date.Z = +string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  var d3_time_numberRe = /^\s*\d+/;
  function d3_time_parseAmPm(date, string, i) {
    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
    return n == null ? -1 : (date.p = n, i);
  }
  var d3_time_amPmLookup = d3.map({
    am: 0,
    pm: 1
  });
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(abs(z) / 60), zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.substring(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  d3_time_format.utc = d3_time_formatUtc;
  function d3_time_formatUtc(template) {
    var local = d3_time_format(template);
    function format(date) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date();
        utc._ = date;
        return local(utc);
      } finally {
        d3_date = Date;
      }
    }
    format.parse = function(string) {
      try {
        d3_date = d3_date_utc;
        var date = local.parse(string);
        return date && date._;
      } finally {
        d3_date = Date;
      }
    };
    format.toString = local.toString;
    return format;
  }
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  function d3_time_scaleFormat(formats) {
    return function(date) {
      var i = formats.length - 1, f = formats[i];
      while (!f[1](date)) f = formats[--i];
      return f[0](date);
    };
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormats = [ [ d3_time_format("%Y"), d3_true ], [ d3_time_format("%B"), function(d) {
    return d.getMonth();
  } ], [ d3_time_format("%b %d"), function(d) {
    return d.getDate() != 1;
  } ], [ d3_time_format("%a %d"), function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ d3_time_format("%I %p"), function(d) {
    return d.getHours();
  } ], [ d3_time_format("%I:%M"), function(d) {
    return d.getMinutes();
  } ], [ d3_time_format(":%S"), function(d) {
    return d.getSeconds();
  } ], [ d3_time_format(".%L"), function(d) {
    return d.getMilliseconds();
  } ] ];
  var d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(+start, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUTCFormats = [ [ d3_time_formatUtc("%Y"), d3_true ], [ d3_time_formatUtc("%B"), function(d) {
    return d.getUTCMonth();
  } ], [ d3_time_formatUtc("%b %d"), function(d) {
    return d.getUTCDate() != 1;
  } ], [ d3_time_formatUtc("%a %d"), function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ d3_time_formatUtc("%I %p"), function(d) {
    return d.getUTCHours();
  } ], [ d3_time_formatUtc("%I:%M"), function(d) {
    return d.getUTCMinutes();
  } ], [ d3_time_formatUtc(":%S"), function(d) {
    return d.getUTCSeconds();
  } ], [ d3_time_formatUtc(".%L"), function(d) {
    return d.getUTCMilliseconds();
  } ] ];
  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
  d3_time_scaleUTCMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  return d3;
}();
/*! catiline 2.9.3 2013-10-25*/
/*!Â©2013 Calvin Metcalf @license MIT https://github.com/calvinmetcalf/catiline */
if (typeof document === 'undefined') {
  self._noTransferable=true;
  self.onmessage=function(e){
    /*jslint evil: true */
    eval(e.data);
  };
} else {
(function(global){
  'use strict';
//overall structure based on when
//https://github.com/cujojs/when/blob/master/when.js#L805-L852
var nextTick;
var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
/*if (typeof setImmediate === 'function') {
  nextTick = setImmediate.bind(global,drainQueue);
}else */if(MutationObserver){
  //based on RSVP
  //https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/async.js
  var observer = new MutationObserver(drainQueue);
  var element = document.createElement('div');
  observer.observe(element, { attributes: true });

  // Chrome Memory Leak: https://bugs.webkit.org/show_bug.cgi?id=93661
  addEventListener('unload', function () {
    observer.disconnect();
    observer = null;
  }, false);
  nextTick =   function () {
    element.setAttribute('drainQueue', 'drainQueue');
  };
}else{
  var codeWord = 'com.catiline.setImmediate' + Math.random();
  addEventListener('message', function (event) {
    // This will catch all incoming messages (even from other windows!), so we need to try reasonably hard to
    // avoid letting anyone else trick us into firing off. We test the origin is still this window, and that a
    // (randomly generated) unpredictable identifying prefix is present.
    if (event.source === window && event.data === codeWord) {
      drainQueue();
    }
  }, false);
  nextTick =  function() {
    postMessage(codeWord, '*');
  };
}
var mainQueue = [];

/**
 * Enqueue a task. If the queue is not currently scheduled to be
 * drained, schedule it.
 * @param {function} task
 */
catiline.nextTick = function(task) {
  if (mainQueue.push(task) === 1) {
    nextTick();
  }
};

/**
 * Drain the handler queue entirely, being careful to allow the
 * queue to be extended while it is being processed, and to continue
 * processing until it is truly empty.
 */
function drainQueue() {
  var i = 0;
  var task;
  var innerQueue = mainQueue;
  mainQueue = [];
  /*jslint boss: true */
  while (task = innerQueue[i++]) {
    task();
  }

}

var func = 'function';
// Creates a deferred: an object with a promise and corresponding resolve/reject methods
function Deferred() {
  // The `handler` variable points to the function that will
  // 1) handle a .then(onFulfilled, onRejected) call
  // 2) handle a .resolve or .reject call (if not fulfilled)
  // Before 2), `handler` holds a queue of callbacks.
  // After 2), `handler` is a simple .then handler.
  // We use only one function to save memory and complexity.
  var handler = function(onFulfilled, onRejected, value) {
    // Case 1) handle a .then(onFulfilled, onRejected) call
    if (onFulfilled !== handler) {
      var createdDeffered = createDeferred();
      handler.queue.push({
        deferred: createdDeffered,
        resolve: onFulfilled,
        reject: onRejected
      });
      return createdDeffered.promise;
    }

    // Case 2) handle a .resolve or .reject call
    // (`onFulfilled` acts as a sentinel)
    // The actual function signature is
    // .re[ject|solve](sentinel, success, value)
    var action = onRejected ? 'resolve' : 'reject';
    for (var i = 0, l = handler.queue.length; i < l; i++) {
      var queue = handler.queue[i];
      var deferred = queue.deferred;
      var callback = queue[action];
      if (typeof callback !== func) {
        deferred[action](value);
      }
      else {
        execute(callback, value, deferred);
      }
    }
    // Replace this handler with a simple resolved or rejected handler
    handler = createHandler(promise, value, onRejected);
  };

  function Promise() {
    this.then = function(onFulfilled, onRejected) {
      return handler(onFulfilled, onRejected);
    };
  }
  var promise = new Promise();
  this.promise = promise;
  // The queue of deferreds
  handler.queue = [];

  this.resolve = function(value) {
    if (handler.queue) {
      handler(handler, true, value);
    }
  };

  this.fulfill = this.resolve;

  this.reject = function(reason) {
    if (handler.queue) {
      handler(handler, false, reason);
    }
  };
}

function createDeferred() {
  return new Deferred();
}

// Creates a fulfilled or rejected .then function
function createHandler(promise, value, success) {
  return function(onFulfilled, onRejected) {
    var callback = success ? onFulfilled : onRejected;
    if (typeof callback !== func) {
      return promise;
    }
    var result = createDeferred();
    execute(callback, value, result);
    return result.promise;
  };
}

// Executes the callback with the specified value,
// resolving or rejecting the deferred
function execute(callback, value, deferred) {
  catiline.nextTick(function() {
    try {
      var result = callback(value);
      if (result && typeof result.then === func) {
        result.then(deferred.resolve, deferred.reject);
      }
      else {
        deferred.resolve(result);
      }
    }
    catch (error) {
      deferred.reject(error);
    }
  });
}
catiline.deferred = createDeferred;
// Returns a resolved promise
catiline.resolve = function(value) {
  var promise = {};
  promise.then = createHandler(promise, value, true);
  return promise;
};
// Returns a rejected promise
catiline.reject = function(reason) {
  var promise = {};
  promise.then = createHandler(promise, reason, false);
  return promise;
};
// Returns a deferred

catiline.all = function(array) {
  var promise = createDeferred();
  var len = array.length;
  var resolved = 0;
  var out = [];
  var onSuccess = function(n) {
    return function(v) {
      out[n] = v;
      resolved++;
      if (resolved === len) {
        promise.resolve(out);
      }
    };
  };
  array.forEach(function(v, i) {
    v.then(onSuccess(i), function(a) {
      promise.reject(a);
    });
  });
  return promise.promise;
};
catiline._hasWorker = typeof Worker !== 'undefined'&&typeof fakeLegacy === 'undefined';
catiline.URL = window.URL || window.webkitURL;
catiline._noTransferable=!catiline.URL;
//regex out the importScript call and move it up to the top out of the function.
function regexImports(string){
  var rest=string;
  var match = true;
  var matches = {};
  var loopFunc = function(a,b){
    if(b){
      'importScripts('+b.split(',').forEach(function(cc){
        matches[catiline.makeUrl(cc.match(/\s*[\'\"](\S*)[\'\"]\s*/)[1])]=true; // trim whitespace, add to matches
      })+');\n';
    }
  };
  while(match){
    match = rest.match(/(importScripts\(.*?\);?)/);
    rest = rest.replace(/(importScripts\(\s*(?:[\'\"].*?[\'\"])?\s*\);?)/,'\n');
    if(match){
      match[0].replace(/importScripts\(\s*([\'\"].*?[\'\"])?\s*\);?/g,loopFunc);
    }
  }
  matches = Object.keys(matches);
  return [matches,rest];
}

function moveImports(string,after){
  var str = regexImports(string);
  var matches = str[0];
  var rest = str[1];
  if(matches.length>0){
    return 'importScripts(\''+matches.join('\',\'')+after+rest;
  }else{
    return rest;
  }
}
function getPath(){
  if(typeof SHIM_WORKER_PATH !== 'undefined'){
    return SHIM_WORKER_PATH;
  }else if('SHIM_WORKER_PATH' in catiline){
    return catiline.SHIM_WORKER_PATH;
  }
  var scripts = document.getElementsByTagName('script');
  var len = scripts.length;
  var i = 0;
  while(i<len){
    if(/catiline(\.min)?\.js/.test(scripts[i].src)){
      return scripts[i].src;
    }
    i++;
  }
}
function appendScript(iDoc,text){
  var iScript = iDoc.createElement('script');
  if (typeof iScript.text !== 'undefined') {
    iScript.text = text;
  } else {
    iScript.innerHTML = text;
  }
  if(iDoc.readyState==='complete'){
    iDoc.documentElement.appendChild(iScript);
  }else{
    iDoc.onreadystatechange=function(){
      if(iDoc.readyState==='complete'){
        iDoc.documentElement.appendChild(iScript);
      }
    };
  }
}
//much of the iframe stuff inspired by https://github.com/padolsey/operative
//most things besides the names have since been changed
function actualMakeI(script,codeword){
  var iFrame = document.createElement('iframe');
  iFrame.style.display = 'none';
  document.body.appendChild(iFrame);
  var iDoc = iFrame.contentWindow.document;
  var text=['try{ ',
  'var __scripts__=\'\';function importScripts(scripts){',
  ' if(Array.isArray(scripts)&&scripts.length>0){',
  '   scripts.forEach(function(url){',
  '     var ajax = new XMLHttpRequest();',
  '     ajax.open(\'GET\',url,false);',
  '     ajax.send();__scripts__+=ajax.responseText;',
  '     __scripts__+=\'\\n;\';',
  '   });',
  ' }',
  '};',
  script,
  '}catch(e){',
  ' window.parent.postMessage([\''+codeword+'\',\'error\'],\'*\')',
  '}'].join('\n');
  appendScript(iDoc,text);
  return iFrame;
}
function makeIframe(script,codeword){
  var promise = catiline.deferred();
  if(document.readyState==='complete'){
    promise.resolve(actualMakeI(script,codeword));
  }else{
    window.addEventListener('load',function(){
      promise.resolve(actualMakeI(script,codeword));
    },false);
  }
  return promise.promise;
}
catiline.makeIWorker = function (strings,codeword){
  var script =moveImports(strings.join(''),'\');eval(__scripts__);\n');
  var worker = {onmessage:function(){}};
  var ipromise = makeIframe(script,codeword);
  window.addEventListener('message',function(e){
    if(e.data.slice && e.data.slice(0,codeword.length) === codeword){
      worker.onmessage({data:JSON.parse(e.data.slice(codeword.length))});
    }
  });
  worker.postMessage=function(data){
    ipromise.then(function(iFrame){
      iFrame.contentWindow.postMessage(JSON.stringify(data),'*');
    });
  };
  worker.terminate=function(){
    ipromise.then(function(iFrame){
      document.body.removeChild(iFrame);
    });
  };
  return worker;
  
};

function makeFallbackWorker(script){
  catiline._noTransferable=true;
  var worker = new Worker(getPath());
  worker.postMessage(script);
  return worker;
}
//accepts an array of strings, joins them, and turns them into a worker.
catiline.makeWorker = function (strings, codeword){
  if(!catiline._hasWorker){
    return catiline.makeIWorker(strings,codeword);
  }
  var worker;
  var script = moveImports(strings.join('\n'),'\');\n');
  if(catiline._noTransferable){
    return makeFallbackWorker(script);
  }
  try{
    worker= new Worker(catiline.URL.createObjectURL(new Blob([script],{type: 'text/javascript'})));
  }catch(e){
    try{
      worker=makeFallbackWorker(script);
    }catch(ee){
      worker = catiline.makeIWorker(strings,codeword);
    }
  }finally{
    return worker;
  }
};

catiline.makeUrl = function (fileName) {
  var link = document.createElement('link');
  link.href = fileName;
  return link.href;
};

function stringifyObject(obj){
  var out = '{';
  var first = true;
  for(var key in obj){
    if(first){
      first = false;
    }else{
      out+=',';
    }
    out += key;
    out += ':';
    out += catiline.stringify(obj[key]);
  }
  out += '}';
  return out;
}
function stringifyArray(array){
  if(array.length){
    var out = '[';
    out += catiline.stringify(array[0]);
    var i = 0;
    var len = array.length;
    while(++i<len){
      out += ',';
      out += catiline.stringify(array[i]);
    }
    out += ']';
    return out;
  }else{
    return '[]';
  }
}
catiline.stringify = function(thing){
  if(Array.isArray(thing)){
    return stringifyArray(thing);
  }else if(typeof thing === 'function'||typeof thing === 'number'||typeof thing === 'boolean'){
    return thing.toString();
  }else if(typeof thing === 'string'){
    return '"' + thing + '"';
  }else if(thing.toString() === '[object Object]'){
    return stringifyObject(thing);
  }
};

var workerSetup = function(context) {
  self.__iFrame__ = typeof document !== 'undefined';
  self.__self__ = {
    onmessage: function(e) {
      context.trigger('messege', e.data[1]);
      if (e.data[0][0] === context.__codeWord__) {
        return regMsg(e);
      }
      else {
        context.trigger(e.data[0][0], e.data[1]);
      }
    }
  };
  if (__iFrame__) {
    window.onmessage = function(e) {
      if (typeof e.data === 'string') {
        e = {
          data: JSON.parse(e.data)
        };
      }
      __self__.onmessage(e);
    };
  }
  else {
    self.onmessage = __self__.onmessage;
  }
  __self__.postMessage = function(rawData, transfer) {
    if (!self._noTransferable && !__iFrame__) {
      self.postMessage(rawData, transfer);
    }
    else if (__iFrame__) {
      var data = context.__codeWord__ + JSON.stringify(rawData);
      window.parent.postMessage(data, '*');
    }
    else if (self._noTransferable) {
      self.postMessage(rawData);
    }
  };
  self.console = {};
  var regMsg = function(e) {
    var cb = function(data, transfer) {
      __self__.postMessage([e.data[0], data], transfer);
    };
    var result;
    if (__iFrame__) {
      try {
        result = context[e.data[1]](e.data[2], cb, context);
      }
      catch (ee) {
        context.fire('error', JSON.stringify(ee));
      }
    }
    else {
      result = context[e.data[1]](e.data[2], cb, context);
    }
    if (typeof result !== 'undefined') {
      cb(result);
    }
  };
};
function addEvents(context, msg) {
  var listeners = {};
  var sendMessage;
  if(typeof __self__ !== 'undefined'){
    sendMessage = __self__.postMessage;
  }else if (msg) {
    sendMessage = msg;
  }
  context.on = function(eventName, func, scope) {
    scope = scope || context;
    if (eventName.indexOf(' ') > 0) {
      eventName.split(' ').map(function(v) {
        return context.on(v, func, scope);
      }, this);
      return context;
    }
    if (!(eventName in listeners)) {
      listeners[eventName] = [];
    }
    var newFunc = function(a) {
      func.call(scope, a, scope);
    };
    newFunc.orig = func;
    listeners[eventName].push(newFunc);
    return context;
  };
  context.one = function(eventName, func, scope) {
    scope = scope || context;

    function ourFunc(a) {
      context.off(eventName, ourFunc);
      func.call(scope, a, scope);
    }
    return context.on(eventName, ourFunc);
  };

  context.trigger = function(eventName, data) {
    if (eventName.indexOf(' ') > 0) {
      eventName.split(' ').forEach(function(v) {
        context.trigger(v, data);
      });
      return context;
    }
    if (!(eventName in listeners)) {
      return context;
    }
    listeners[eventName].forEach(function(v) {
      v(data);
    });
    return context;
  };
  context.fire = function(eventName, data, transfer) {
    sendMessage([[eventName],data],transfer);
    return context;
  };
  context.off = function(eventName, func) {
    if (eventName.indexOf(' ') > 0) {
      eventName.split(' ').map(function(v) {
        return context.off(v, func);
      });
      return context;
    }
    if (!(eventName in listeners)) {
      return context;
    }
    else {
      if (func) {
        listeners[eventName] = listeners[eventName].map(function(a) {
          if (a.orig === func) {
            return false;
          }
          else {
            return a;
          }
        }).filter(function(a) {
          return a;
        });
      }
      else {
        delete listeners[eventName];
      }
    }
    return context;
  };
}
function makeConsole(msg) {
  if (typeof console !== 'undefined') {
    var method = console[msg[0]] ? msg[0] : 'log';
    if (typeof console[method].apply === 'undefined') {
      console[method](msg[1].join(' '));
    }
    else {
      console[method].apply(console, msg[1]);
    }
  }
}
function makeWorkerConsole(context){
  function makeConsole(method) {
    return function() {
      var len = arguments.length;
      var out = [];
      var i = 0;
      while (i < len) {
        out.push(arguments[i]);
        i++;
      }
      context.fire('console', [method, out]);
    };
  }
  ['log', 'debug', 'error', 'info', 'warn', 'time', 'timeEnd'].forEach(function(v) {
    console[v] = makeConsole(v);
  });
}
function Catiline(obj) {
  if (typeof obj === 'function') {
    obj = {
      data: obj
    };
  }
  var codeWord = 'com.catilinejs.' + (Catiline._hasWorker ? 'iframe' : 'worker') + Math.random();
  var self = this;
  var promises = [];
  addEvents(self, function(data, transfer) {
    if (catiline._noTransferable) {
      worker.postMessage(data);
    }
    else {
      worker.postMessage(data, transfer);
    }
  });
  var rejectPromises = function(msg) {
    if (typeof msg !== 'string' && 'preventDefault' in msg) {
      msg.preventDefault();
      msg = msg.message;
    }
    promises.forEach(function(p) {
      if (p) {
        p.reject(msg);
      }
    });
  };
  obj.__codeWord__ = codeWord;
  obj.__initialize__ = [workerSetup, addEvents, makeWorkerConsole];
  if (!('initialize' in obj)) {
    if ('init' in obj) {
      obj.__initialize__.push(obj.init);
    }
  }
  else {
    obj.__initialize__.push(obj.initialize);
  }

  if (!('events' in obj)) {
    obj.events = {};
  }
  if ('listners' in obj && typeof obj.listners !== 'function') {
    for (var key in obj.listners) {
      self.on(key, obj.listners[key]);
    }
  }
  var fObj = 'var _db = {\n\t';
  var keyFunc = function(key) {
    var out = function(data, transfer) {
      var i = promises.length;
      promises[i] = catiline.deferred();
      if (catiline._noTransferable) {
        worker.postMessage([
          [codeWord, i], key, data]);
      }
      else {
        worker.postMessage([
          [codeWord, i], key, data], transfer);
      }
      return promises[i].promise;
    };
    return out;
  };
  var i = false;
  for (var key$0 in obj) {
    if(['listners','initialize','init'].indexOf(key$0)>-1){
      continue;
    }
    if (i) {
      fObj += ',\n\t';
    }
    else {
      i = true;
    }
    if (typeof obj[key$0] === 'function') {
      fObj = fObj + key$0 + ':' + obj[key$0].toString();
      self[key$0] = keyFunc(key$0);
    }
    else {
      var outThing = catiline.stringify(obj[key$0]);
      if (typeof outThing !== 'undefined') {
        fObj = fObj + key$0 + ':' + outThing;
      }
    }
  }
  fObj = fObj + '};';
  var worker = catiline.makeWorker(['\'use strict\';', '',
  fObj, '_db.__initialize__.forEach(function(f){', '  f.call(_db,_db);', '});', 'for(var key in _db.events){', '  _db.on(key,_db.events[key]);', '}'], codeWord);
  worker.onmessage = function(e) {
    self.trigger('message', e.data[1]);
    if (e.data[0][0] === codeWord) {
      promises[e.data[0][1]].resolve(e.data[1]);
      promises[e.data[0][1]] = 0;
    }
    else {
      self.trigger(e.data[0][0], e.data[1]);
    }
  };
  self.on('error', rejectPromises);
  worker.onerror = function(e) {
    self.trigger('error', e);
  };
  self.on('console', makeConsole);
  self._close = function() {
    worker.terminate();
    rejectPromises('closed');
    return catiline.resolve();
  };
  if (!('close' in self)) {
    self.close = self._close;
  }
}
catiline.Worker = Catiline;

catiline.worker = function(obj){
    return new Catiline(obj);
};
function makeActualKeyFuncs(resolvePromises, self) {
  return {
    keyFunc: function(k) {
      return function(data, transfer) {
        return resolvePromises(k, data, transfer);
      };
    },
    keyFuncBatch: function(k) {
      return function(array) {
        return catiline.all(array.map(function(data) {
          return resolvePromises(k, data);
        }));
      };
    },
    keyFuncBatchCB: function(k) {
      return function(array) {
        return catiline.all(array.map(function(data) {
          return resolvePromises(k, data).then(self.__cb__);
        }));
      };
    },
    keyFuncBatchTransfer: function(k) {
      return function(array) {
        return catiline.all(array.map(function(data) {
          return resolvePromises(k, data[0], data[1]);
        }));
      };
    },
    keyFuncBatchTransferCB: function(k) {
      return function(array) {
        return catiline.all(array.map(function(data) {
          return resolvePromises(k, data[0], data[1]).then(self.__cb__);
        }));
      };
    }
  };
}
function makeKeyFuncs(resolvePromises, self, obj){
  var funcs = makeActualKeyFuncs(resolvePromises, self);
  for (var key in obj) {
    self[key] = funcs.keyFunc(key);
    self.batch[key] = funcs.keyFuncBatch(key);
    self.__batchcb__[key] = funcs.keyFuncBatchCB(key);
    self.batchTransfer[key] = funcs.keyFuncBatchTransfer(key);
    self.__batchtcb__[key] = funcs.keyFuncBatchTransferCB(key);
  }
}
function addBatchEvents(self, workers, n){
  self.on = function (eventName, func, context) {
    workers.forEach(function (worker) {
      worker.on(eventName, func, context);
    });
    return self;
  };
  self.off = function (eventName, func, context) {
    workers.forEach(function (worker) {
      worker.off(eventName, func, context);
    });
    return self;
  };
  self.fire = function (eventName, data) {
    workers[~~ (Math.random() * n)].fire(eventName, data);
    return self;
  };
}
function makeUnmanaged(workers, n){
  return function(key, data, transfer, promise){
    promise.promise.cancel = function(reason){
      return promise.reject(reason);
    };
    workers[~~ (Math.random() * n)][key](data, transfer).then(function(v){
      return promise.resolve(v);
    },function(v){
      return promise.reject(v);
    });
    return promise.promise;
  };
}
function makeQueueWorkers(n,idle,obj){
  var workers = [];
  var numIdle = -1;
  while (++numIdle < n) {
    workers[numIdle] = new catiline.Worker(obj);
    idle.push(numIdle);
  }
  return workers;
}
function CatilineQueue(obj, n, dumb) {
  var self = this;
  var numIdle = n;
  var idle = [];
  var que = [];
  var queueLen = 0;
  var workers = makeQueueWorkers(n,idle,obj);
  addBatchEvents(self, workers, n);
  var batchFire = function (eventName, data) {
    workers.forEach(function (worker) {
      worker.fire(eventName, data);
    });
    return self;
  };
  
  self.batch.fire = batchFire;
  self.batchTransfer.fire = batchFire;

  function clearQueue(mgs) {
    mgs = mgs || 'canceled';
    queueLen = 0;
    var oQ = que;
    que = [];
    oQ.forEach(function (p) {
      p[3].reject(mgs);
    });
    return self;
  }
  self.clearQueue = clearQueue;
  makeKeyFuncs(resolvePromises, self, obj);
  

  function done(num) {
    if (queueLen) {
      var data = que.shift();
      queueLen--;
      workers[num][data[0]](data[1], data[2]).then(function (d) {
        done(num);
        data[3].resolve(d);
      }, function (d) {
        done(num);
        data[3].reject(d);
      });
    }
    else {
      numIdle++;
      idle.push(num);
    }
  }
  var resolveUnmanagedPromises;
  if(dumb){
    resolveUnmanagedPromises = makeUnmanaged(workers, n);
  }
  function resolvePromises(key, data, transfer) { //srsly better name!
    var promise = catiline.deferred();
    if (dumb) {
      return resolveUnmanagedPromises(key, data, transfer,promise);
    }
    if (!queueLen && numIdle) {
      var num = idle.pop();
      numIdle--;
      promise.promise.cancel = function(reason){
        return promise.reject(reason);
      };
      workers[num][key](data, transfer).then(function (d) {
        done(num);
        promise.resolve(d);
      }, function (d) {
        done(num);
        promise.reject(d);
      });
    } else if (queueLen || !numIdle) {
      var queueItem = [key, data, transfer, promise];
      promise.promise.cancel = function(reason){
        var loc = que.indexOf(queueItem);
        if(loc>-1){
          que.splice(loc,1);
          queueLen--;
        }
        return promise.reject(reason);
      };
      queueLen = que.push(queueItem);
    }
    return promise.promise;
  }
  self._close = function () {
    return catiline.all(workers.map(function (w) {
      return w._close();
    }));
  };
  if (!('close' in self)) {
    self.close = self._close;
  }
}
CatilineQueue.prototype.__batchcb__ = {};
CatilineQueue.prototype.__batchtcb__ = {};
CatilineQueue.prototype.batch = function (cb) {
  if (typeof cb === 'function') {
    this.__cb__ = cb;
    return this.__batchcb__;
  }
  else {
    return this.clearQueue(cb);
  }
};
CatilineQueue.prototype.batchTransfer = function (cb) {
  if (typeof cb === 'function') {
    this.__batchtcb__.__cb__ = cb;
    return this.__batchtcb__;
  }
  else {
    return this.clearQueue(cb);
  }
};
catiline.Queue = CatilineQueue;
catiline.queue = function (obj, n, dumb) {
  return new catiline.Queue(obj, n, dumb);
};

function catiline(object,queueLength,unmanaged){
  if(arguments.length === 1 || !queueLength || queueLength <= 1){
    return new catiline.Worker(object);
  }else{
    return new catiline.Queue(object,queueLength,unmanaged);
  }
}
//will be removed in v3
catiline.setImmediate = catiline.nextTick;
function initBrowser(catiline){
  var origCW = global.cw;
  catiline.noConflict=function(newName){
    global.cw = origCW;
    if(newName){
      global[newName]=catiline;
    }
  };
  global.catiline = catiline;
  global.cw = catiline;
  if(!('communist' in global)){
    global.communist=catiline;
  }

}

if(typeof define === 'function'){
  define(function(require){
    catiline.SHIM_WORKER_PATH=require.toUrl('./catiline.js');
    return catiline;
  });
}else if(typeof module === 'undefined' || !('exports' in module)){
  initBrowser(catiline);
} else {
  module.exports=catiline;
}catiline.version = '2.9.3';
})(this);}
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);
/*!
 * FPSMeter 0.3.1 - 9th May 2013
 * https://github.com/Darsain/fpsmeter
 *
 * Licensed under the MIT license.
 * http://opensource.org/licenses/MIT
 */
;(function (w, undefined) {
  'use strict';

  /**
   * Create a new element.
   *
   * @param  {String} name Element type name.
   *
   * @return {Element}
   */
  function newEl(name) {
    return document.createElement(name);
  }

  /**
   * Apply theme CSS properties to element.
   *
   * @param  {Element} element DOM element.
   * @param  {Object}  theme   Theme object.
   *
   * @return {Element}
   */
  function applyTheme(element, theme) {
    for (var name in theme) {
      try {
        element.style[name] = theme[name];
      } catch (e) {}
    }
    return element;
  }

  /**
   * Return type of the value.
   *
   * @param  {Mixed} value
   *
   * @return {String}
   */
  function type(value) {
    if (value == null) {
      return String(value);
    }

    if (typeof value === 'object' || typeof value === 'function') {
      return Object.prototype.toString.call(value).match(/\s([a-z]+)/i)[1].toLowerCase() || 'object';
    }

    return typeof value;
  }

  /**
   * Check whether the value is in an array.
   *
   * @param  {Mixed} value
   * @param  {Array} array
   *
   * @return {Integer} Array index or -1 when not found.
   */
  function inArray(value, array) {
    if (type(array) !== 'array') {
      return -1;
    }
    if (array.indexOf) {
      return array.indexOf(value);
    }
    for (var i = 0, l = array.length; i < l; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Poor man's deep object extend.
   *
   * Example:
   *   extend({}, defaults, options);
   *
   * @return {Void}
   */
  function extend() {
    var args = arguments;
    for (var key in args[1]) {
      if (args[1].hasOwnProperty(key)) {
        switch (type(args[1][key])) {
          case 'object':
            args[0][key] = extend({}, args[0][key], args[1][key]);
            break;

          case 'array':
            args[0][key] = args[1][key].slice(0);
            break;

          default:
            args[0][key] = args[1][key];
        }
      }
    }
    return args.length > 2 ?
      extend.apply(null, [args[0]].concat(Array.prototype.slice.call(args, 2))) :
      args[0];
  }

  /**
   * Convert HSL color to HEX string.
   *
   * @param  {Array} hsl Array with [hue, saturation, lightness].
   *
   * @return {Array} Array with [red, green, blue].
   */
  function hslToHex(h, s, l) {
    var r, g, b;
    var v, min, sv, sextant, fract, vsf;

    if (l <= 0.5) {
      v = l * (1 + s);
    } else {
      v = l + s - l * s;
    }

    if (v === 0) {
      return '#000';
    } else {
      min = 2 * l - v;
      sv = (v - min) / v;
      h = 6 * h;
      sextant = Math.floor(h);
      fract = h - sextant;
      vsf = v * sv * fract;
      if (sextant === 0 || sextant === 6) {
        r = v;
        g = min + vsf;
        b = min;
      } else if (sextant === 1) {
        r = v - vsf;
        g = v;
        b = min;
      } else if (sextant === 2) {
        r = min;
        g = v;
        b = min + vsf;
      } else if (sextant === 3) {
        r = min;
        g = v - vsf;
        b = v;
      } else if (sextant === 4) {
        r = min + vsf;
        g = min;
        b = v;
      } else {
        r = v;
        g = min;
        b = v - vsf;
      }
      return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
    }
  }

  /**
   * Helper function for hslToHex.
   */
  function componentToHex(c) {
    c = Math.round(c * 255).toString(16);
    return c.length === 1 ? '0' + c : c;
  }

  /**
   * Manage element event listeners.
   *
   * @param  {Node}     element
   * @param  {Event}    eventName
   * @param  {Function} handler
   * @param  {Bool}     remove
   *
   * @return {Void}
   */
  function listener(element, eventName, handler, remove) {
    if (element.addEventListener) {
      element[remove ? 'removeEventListener' : 'addEventListener'](eventName, handler, false);
    } else if (element.attachEvent) {
      element[remove ? 'detachEvent' : 'attachEvent']('on' + eventName, handler);
    }
  }

  // Preferred timing funtion
  var getTime;
  (function () {
    var perf = w.performance;
    if (perf && (perf.now || perf.webkitNow)) {
      var perfNow = perf.now ? 'now' : 'webkitNow';
      getTime = perf[perfNow].bind(perf);
    } else {
      getTime = function () {
        return +new Date();
      };
    }
  }());

  // Local WindowAnimationTiming interface polyfill
  var cAF = w.cancelAnimationFrame || w.cancelRequestAnimationFrame;
  var rAF = w.requestAnimationFrame;
  (function () {
    var vendors = ['moz', 'webkit', 'o'];
    var lastTime = 0;

    // For a more accurate WindowAnimationTiming interface implementation, ditch the native
    // requestAnimationFrame when cancelAnimationFrame is not present (older versions of Firefox)
    for (var i = 0, l = vendors.length; i < l && !cAF; ++i) {
      cAF = w[vendors[i]+'CancelAnimationFrame'] || w[vendors[i]+'CancelRequestAnimationFrame'];
      rAF = cAF && w[vendors[i]+'RequestAnimationFrame'];
    }

    if (!cAF) {
      rAF = function (callback) {
        var currTime = getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        lastTime = currTime + timeToCall;
        return w.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall);
      };

      cAF = function (id) {
        clearTimeout(id);
      };
    }
  }());

  // Property name for assigning element text content
  var textProp = type(document.createElement('div').textContent) === 'string' ? 'textContent' : 'innerText';

  /**
   * FPSMeter class.
   *
   * @param {Element} anchor  Element to append the meter to. Default is document.body.
   * @param {Object}  options Object with options.
   */
  function FPSMeter(anchor, options) {
    // Optional arguments
    if (type(anchor) === 'object' && anchor.nodeType === undefined) {
      options = anchor;
      anchor = document.body;
    }
    if (!anchor) {
      anchor = document.body;
    }

    // Private properties
    var self = this;
    var o = extend({}, FPSMeter.defaults, options || {});

    var el = {};
    var cols = [];
    var theme, heatmaps;
    var heatDepth = 100;
    var heating = [];

    var thisFrameTime = 0;
    var frameTime = o.threshold;
    var frameStart = 0;
    var lastLoop = getTime() - frameTime;
    var time;

    var fpsHistory = [];
    var durationHistory = [];

    var frameID, renderID;
    var showFps = o.show === 'fps';
    var graphHeight, count, i, j;

    // Exposed properties
    self.options = o;
    self.fps = 0;
    self.duration = 0;
    self.isPaused = 0;

    /**
     * Tick start for measuring the actual rendering duration.
     *
     * @return {Void}
     */
    self.tickStart = function () {
      frameStart = getTime();
    };

    /**
     * FPS tick.
     *
     * @return {Void}
     */
    self.tick = function () {
      time = getTime();
      thisFrameTime = time - lastLoop;
      frameTime += (thisFrameTime - frameTime) / o.smoothing;
      self.fps = 1000 / frameTime;
      self.duration = frameStart < lastLoop ? frameTime : time - frameStart;
      lastLoop = time;
    };

    /**
     * Pause display rendering.
     *
     * @return {Object} FPSMeter instance.
     */
    self.pause = function () {
      if (frameID) {
        self.isPaused = 1;
        clearTimeout(frameID);
        cAF(frameID);
        cAF(renderID);
        frameID = renderID = 0;
      }
      return self;
    };

    /**
     * Resume display rendering.
     *
     * @return {Object} FPSMeter instance.
     */
    self.resume = function () {
      if (!frameID) {
        self.isPaused = 0;
        requestRender();
      }
      return self;
    };

    /**
     * Update options.
     *
     * @param {String} name  Option name.
     * @param {Mixed}  value New value.
     *
     * @return {Object} FPSMeter instance.
     */
    self.set = function (name, value) {
      o[name] = value;
      showFps = o.show === 'fps';

      // Rebuild or reposition elements when specific option has been updated
      if (inArray(name, rebuilders) !== -1) {
        createMeter();
      }
      if (inArray(name, repositioners) !== -1) {
        positionMeter();
      }
      return self;
    };

    /**
     * Change meter into rendering duration mode.
     *
     * @return {Object} FPSMeter instance.
     */
    self.showDuration = function () {
      self.set('show', 'ms');
      return self;
    };

    /**
     * Change meter into FPS mode.
     *
     * @return {Object} FPSMeter instance.
     */
    self.showFps = function () {
      self.set('show', 'fps');
      return self;
    };

    /**
     * Toggles between show: 'fps' and show: 'duration'.
     *
     * @return {Object} FPSMeter instance.
     */
    self.toggle = function () {
      self.set('show', showFps ? 'ms' : 'fps');
      return self;
    };

    /**
     * Hide the FPSMeter. Also pauses the rendering.
     *
     * @return {Object} FPSMeter instance.
     */
    self.hide = function () {
      self.pause();
      el.container.style.display = 'none';
      return self;
    };

    /**
     * Show the FPSMeter. Also resumes the rendering.
     *
     * @return {Object} FPSMeter instance.
     */
    self.show = function () {
      self.resume();
      el.container.style.display = 'block';
      return self;
    };

    /**
     * Check the current FPS and save it in history.
     *
     * @return {Void}
     */
    function historyTick() {
      for (i = o.history; i--;) {
        fpsHistory[i] = i === 0 ? self.fps : fpsHistory[i-1];
        durationHistory[i] = i === 0 ? self.duration : durationHistory[i-1];
      }
    }

    /**
     * Returns heat hex color based on values passed.
     *
     * @param  {Integer} heatmap
     * @param  {Integer} value
     * @param  {Integer} min
     * @param  {Integer} max
     *
     * @return {Integer}
     */
    function getHeat(heatmap, value, min, max) {
      return heatmaps[0|heatmap][Math.round(Math.min((value - min) / (max - min) * heatDepth, heatDepth))];
    }

    /**
     * Update counter number and legend.
     *
     * @return {Void}
     */
    function updateCounter() {
      // Update legend only when changed
      if (el.legend.fps !== showFps) {
        el.legend.fps = showFps;
        el.legend[textProp] = showFps ? 'FPS' : 'ms';
      }
      // Update counter with a nicely formated & readable number
      count = showFps ? self.fps : self.duration;
      el.count[textProp] = count > 999 ? '999+' : count.toFixed(count > 99 ? 0 : o.decimals);
    }

    /**
     * Render current FPS state.
     *
     * @return {Void}
     */
    function render() {
      time = getTime();
      // If renderer stopped reporting, do a simulated drop to 0 fps
      if (lastLoop < time - o.threshold) {
        self.fps -= self.fps / Math.max(1, o.smoothing * 60 / o.interval);
        self.duration = 1000 / self.fps;
      }

      historyTick();
      updateCounter();

      // Apply heat to elements
      if (o.heat) {
        if (heating.length) {
          for (i = heating.length; i--;) {
            heating[i].el.style[theme[heating[i].name].heatOn] = showFps ?
              getHeat(theme[heating[i].name].heatmap, self.fps, 0, o.maxFps) :
              getHeat(theme[heating[i].name].heatmap, self.duration, o.threshold, 0);
          }
        }

        if (el.graph && theme.column.heatOn) {
          for (i = cols.length; i--;) {
            cols[i].style[theme.column.heatOn] = showFps ?
              getHeat(theme.column.heatmap, fpsHistory[i], 0, o.maxFps) :
              getHeat(theme.column.heatmap, durationHistory[i], o.threshold, 0);
          }
        }
      }

      // Update graph columns height
      if (el.graph) {
        for (j = 0; j < o.history; j++) {
          cols[j].style.height = (showFps ?
            (fpsHistory[j] ? Math.round(graphHeight / o.maxFps * Math.min(fpsHistory[j], o.maxFps)) : 0) :
            (durationHistory[j] ? Math.round(graphHeight / o.threshold * Math.min(durationHistory[j], o.threshold)) : 0)
          ) + 'px';
        }
      }
    }

    /**
     * Request rendering loop.
     *
     * @return {Int} Animation frame index.
     */
    function requestRender() {
      if (o.interval < 20) {
        frameID = rAF(requestRender);
        render();
      } else {
        frameID = setTimeout(requestRender, o.interval);
        renderID = rAF(render);
      }
    }

    /**
     * Meter events handler.
     *
     * @return {Void}
     */
    function eventHandler(event) {
      event = event || window.event;
      if (event.preventDefault) {
        event.preventDefault();
        event.stopPropagation();
      } else {
        event.returnValue = false;
        event.cancelBubble = true;
      }
      self.toggle();
    }

    /**
     * Destroys the current FPSMeter instance.
     *
     * @return {Void}
     */
    self.destroy = function () {
      // Stop rendering
      self.pause();
      // Remove elements
      removeMeter();
      // Stop listening
      self.tick = self.tickStart = function () {};
    };

    /**
     * Remove meter element.
     *
     * @return {Void}
     */
    function removeMeter() {
      // Unbind listeners
      if (o.toggleOn) {
        listener(el.container, o.toggleOn, eventHandler, 1);
      }
      // Detach element
      anchor.removeChild(el.container);
    }

    /**
     * Sets the theme, and generates heatmaps when needed.
     */
    function setTheme() {
      theme = FPSMeter.theme[o.theme];

      // Generate heatmaps
      heatmaps = theme.compiledHeatmaps || [];
      if (!heatmaps.length && theme.heatmaps.length) {
        for (j = 0; j < theme.heatmaps.length; j++) {
          heatmaps[j] = [];
          for (i = 0; i <= heatDepth; i++) {
            heatmaps[j][i] = hslToHex(0.33 / heatDepth * i, theme.heatmaps[j].saturation, theme.heatmaps[j].lightness);
          }
        }
        theme.compiledHeatmaps = heatmaps;
      }
    }

    /**
     * Creates and attaches the meter element.
     *
     * @return {Void}
     */
    function createMeter() {
      // Remove old meter if present
      if (el.container) {
        removeMeter();
      }

      // Set theme
      setTheme();

      // Create elements
      el.container = applyTheme(newEl('div'), theme.container);
      el.count = el.container.appendChild(applyTheme(newEl('div'), theme.count));
      el.legend = el.container.appendChild(applyTheme(newEl('div'), theme.legend));
      el.graph = o.graph ? el.container.appendChild(applyTheme(newEl('div'), theme.graph)) : 0;

      // Add elements to heating array
      heating.length = 0;
      for (var key in el) {
        if (el[key] && theme[key].heatOn) {
          heating.push({
            name: key,
            el: el[key]
          });
        }
      }

      // Graph
      cols.length = 0;
      if (el.graph) {
        // Create graph
        el.graph.style.width = (o.history * theme.column.width + (o.history - 1) * theme.column.spacing) + 'px';

        // Add columns
        for (i = 0; i < o.history; i++) {
          cols[i] = el.graph.appendChild(applyTheme(newEl('div'), theme.column));
          cols[i].style.position = 'absolute';
          cols[i].style.bottom = 0;
          cols[i].style.right = (i * theme.column.width + i * theme.column.spacing) + 'px';
          cols[i].style.width = theme.column.width + 'px';
          cols[i].style.height = '0px';
        }
      }

      // Set the initial state
      positionMeter();
      updateCounter();

      // Append container to anchor
      anchor.appendChild(el.container);

      // Retrieve graph height after it was appended to DOM
      if (el.graph) {
        graphHeight = el.graph.clientHeight;
      }

      // Add event listeners
      if (o.toggleOn) {
        if (o.toggleOn === 'click') {
          el.container.style.cursor = 'pointer';
        }
        listener(el.container, o.toggleOn, eventHandler);
      }
    }

    /**
     * Positions the meter based on options.
     *
     * @return {Void}
     */
    function positionMeter() {
      applyTheme(el.container, o);
    }

    /**
     * Construct.
     */
    (function () {
      // Create meter element
      createMeter();
      // Start rendering
      requestRender();
    }());
  }

  // Expose the extend function
  FPSMeter.extend = extend;

  // Expose the FPSMeter class
  window.FPSMeter = FPSMeter;

  // Default options
  FPSMeter.defaults = {
    interval:  100,     // Update interval in milliseconds.
    smoothing: 10,      // Spike smoothing strength. 1 means no smoothing.
    show:      'fps',   // Whether to show 'fps', or 'ms' = frame duration in milliseconds.
    toggleOn:  'click', // Toggle between show 'fps' and 'ms' on this event.
    decimals:  1,       // Number of decimals in FPS number. 1 = 59.9, 2 = 59.94, ...
    maxFps:    60,      // Max expected FPS value.
    threshold: 100,     // Minimal tick reporting interval in milliseconds.

    // Meter position
    position: 'absolute', // Meter position.
    zIndex:   10,         // Meter Z index.
    left:     '5px',      // Meter left offset.
    top:      '5px',      // Meter top offset.
    right:    'auto',     // Meter right offset.
    bottom:   'auto',     // Meter bottom offset.
    margin:   '0 0 0 0',  // Meter margin. Helps with centering the counter when left: 50%;

    // Theme
    theme: 'dark', // Meter theme. Build in: 'dark', 'light', 'transparent', 'colorful'.
    heat:  0,      // Allow themes to use coloring by FPS heat. 0 FPS = red, maxFps = green.

    // Graph
    graph:   0, // Whether to show history graph.
    history: 20 // How many history states to show in a graph.
  };

  // Option names that trigger FPSMeter rebuild or reposition when modified
  var rebuilders = [
    'toggleOn',
    'theme',
    'heat',
    'graph',
    'history'
  ];
  var repositioners = [
    'position',
    'zIndex',
    'left',
    'top',
    'right',
    'bottom',
    'margin'
  ];
}(window));
;(function (w, FPSMeter, undefined) {
  'use strict';

  // Themes object
  FPSMeter.theme = {};

  // Base theme with layout, no colors
  var base = FPSMeter.theme.base = {
    heatmaps: [],
    container: {
      // Settings
      heatOn: null,
      heatmap: null,

      // Styles
      padding: '5px',
      minWidth: '95px',
      height: '30px',
      lineHeight: '30px',
      textAlign: 'right',
      textShadow: 'none'
    },
    count: {
      // Settings
      heatOn: null,
      heatmap: null,

      // Styles
      position: 'absolute',
      top: 0,
      right: 0,
      padding: '5px 10px',
      height: '30px',
      fontSize: '24px',
      fontFamily: 'Consolas, Andale Mono, monospace',
      zIndex: 2
    },
    legend: {
      // Settings
      heatOn: null,
      heatmap: null,

      // Styles
      position: 'absolute',
      top: 0,
      left: 0,
      padding: '5px 10px',
      height: '30px',
      fontSize: '12px',
      lineHeight: '32px',
      fontFamily: 'sans-serif',
      textAlign: 'left',
      zIndex: 2
    },
    graph: {
      // Settings
      heatOn: null,
      heatmap: null,

      // Styles
      position: 'relative',
      boxSizing: 'padding-box',
      MozBoxSizing: 'padding-box',
      height: '100%',
      zIndex: 1
    },
    column: {
      // Settings
      width: 4,
      spacing: 1,
      heatOn: null,
      heatmap: null
    }
  };

  // Dark theme
  FPSMeter.theme.dark = FPSMeter.extend({}, base, {
    heatmaps: [{
      saturation: 0.8,
      lightness: 0.8
    }],
    container: {
      background: '#222',
      color: '#fff',
      border: '1px solid #1a1a1a',
      textShadow: '1px 1px 0 #222'
    },
    count: {
      heatOn: 'color'
    },
    column: {
      background: '#3f3f3f'
    }
  });

  // Light theme
  FPSMeter.theme.light = FPSMeter.extend({}, base, {
    heatmaps: [{
      saturation: 0.5,
      lightness: 0.5
    }],
    container: {
      color: '#666',
      background: '#fff',
      textShadow: '1px 1px 0 rgba(255,255,255,.5), -1px -1px 0 rgba(255,255,255,.5)',
      boxShadow: '0 0 0 1px rgba(0,0,0,.1)'
    },
    count: {
      heatOn: 'color'
    },
    column: {
      background: '#eaeaea'
    }
  });

  // Colorful theme
  FPSMeter.theme.colorful = FPSMeter.extend({}, base, {
    heatmaps: [{
      saturation: 0.5,
      lightness: 0.6
    }],
    container: {
      heatOn: 'backgroundColor',
      background: '#888',
      color: '#fff',
      textShadow: '1px 1px 0 rgba(0,0,0,.2)',
      boxShadow: '0 0 0 1px rgba(0,0,0,.1)'
    },
    column: {
      background: '#777',
      backgroundColor: 'rgba(0,0,0,.2)'
    }
  });

  // Transparent theme
  FPSMeter.theme.transparent = FPSMeter.extend({}, base, {
    heatmaps: [{
      saturation: 0.8,
      lightness: 0.5
    }],
    container: {
      padding: 0,
      color: '#fff',
      textShadow: '1px 1px 0 rgba(0,0,0,.5)'
    },
    count: {
      padding: '0 5px',
      height: '40px',
      lineHeight: '40px'
    },
    legend: {
      padding: '0 5px',
      height: '40px',
      lineHeight: '42px'
    },
    graph: {
      height: '40px'
    },
    column: {
      width: 5,
      background: '#999',
      heatOn: 'backgroundColor',
      opacity: 0.5
    }
  });
}(window, FPSMeter));
//! moment.js
//! version : 2.4.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.4.0",
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO seperator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        // preliminary iso regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000)
        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d:?\d\d|Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            'YYYY-MM-DD',
            'GGGG-[W]WW',
            'GGGG-[W]WW-E',
            'YYYY-DDD'
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return this.weekYear();
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return this.isoWeekYear();
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(10 * a / 6), 4);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // store reference to input for deterministic cloning
        this._input = duration;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength) {
        var output = number + '';
        while (output.length < targetLength) {
            output = '0' + output;
        }
        return output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months,
            minutes,
            hours;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop,
            index;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function initializeParsingFlags(config) {
        config._pf = {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a;
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return parseTokenFourDigits;
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return parseTokenSixDigits;
        case 'S':
        case 'SS':
        case 'SSS':
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        var tzchunk = (parseTokenTimezone.exec(string) || [])[0],
            parts = (tzchunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            break;
        case 'YYYY' :
        case 'YYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gg':
        case 'gggg':
        case 'GG':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                return val ?
                  (val.length < 3 ? (parseInt(val, 10) > 68 ? '19' + val : '20' + val) : val) :
                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            initializeParsingFlags(tempConfig);
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 4; i > 0; i--) {
                if (match[i]) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i - 1] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (parseTokenTimezone.exec(string)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            config._d = new Date(string);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else {
            config._d = new Date(input);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = new Date(Date.UTC(year, 0)).getUTCDay(),
            daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (typeof config._pf === 'undefined') {
            initializeParsingFlags(config);
        }

        if (input === null) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = extend({}, input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        return makeMoment({
            _i : input,
            _f : format,
            _l : lang,
            _strict : strict,
            _isUTC : false
        });
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var m;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        m = makeMoment({
            _useUTC : true,
            _isUTC : true,
            _l : lang,
            _i : input,
            _f : format,
            _strict : strict
        }).utc();

        return m;
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var isDuration = moment.isDuration(input),
            isNumber = (typeof input === 'number'),
            duration = (isDuration ? input._input : (isNumber ? {} : input)),
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            timeEmpty,
            dateTimeEmpty;

        if (isNumber) {
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (isDuration && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function (input) {
        return moment(input).parseZone();
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            return formatMoment(moment(this).utc(), 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = this._isUTC ? moment(input).zone(this._offset || 0) : moment(input).local(),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            var diff = this.diff(moment().zone(this.zone()).startOf('day'), 'days', true),
                format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : function (input) {
            var utc = this._isUTC ? 'UTC' : '',
                dayOfMonth;

            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }

                dayOfMonth = this.date();
                this.date(1);
                this._d['set' + utc + 'Month'](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));

                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + 'Month']();
            }
        },

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) === +moment(input).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        zone : function (input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + 's'] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(deprecate) {
        var warned = false, local_moment = moment;
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        if (deprecate) {
            this.moment = function () {
                if (!warned && console && console.warn) {
                    warned = true;
                    console.warn(
                            "Accessing Moment through the global scope is " +
                            "deprecated, and will be removed in an upcoming " +
                            "release.");
                }
                return local_moment.apply(null, arguments);
            };
        } else {
            this['moment'] = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
        makeGlobal(true);
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config().noGlobal !== true) {
                // If user provided noGlobal, he is aware of global
                makeGlobal(module.config().noGlobal === undefined);
            }

            return moment;
        });
    } else {
        makeGlobal();
    }
}).call(this);

/*
 (c) 2013, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { "use strict";

// to suit your point format, run search/replace for '[0]' and '[1]';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) {
        newPoints.push(point);
    }

    return newPoints;
}

// simplification using optimized Douglas-Peucker algorithm with recursion elimination
function simplifyDouglasPeucker(points, sqTolerance) {

    var len = points.length,
        MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
        markers = new MarkerArray(len),
        first = 0,
        last = len - 1,
        stack = [],
        newPoints = [],
        i, maxSqDist, sqDist, index;

    markers[first] = markers[last] = 1;

    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;
            stack.push(first, index, index, last);
        }

        last = stack.pop();
        first = stack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) {
            newPoints.push(points[i]);
        }
    }

    return newPoints;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser variable
if (typeof define === 'function' && define.amd) {
    define(function() {
        return simplify;
    });
} else if (typeof module !== 'undefined') {
    module.exports = simplify;
} else {
    window.simplify = simplify;
}

})();

!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.throat=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict'

var Promise = _dereq_('promise')

module.exports = throat
function throat(size, fn) {
  var queue = []
  function run(fn, self, args) {
    if (size) {
      size--
      var result = new Promise(function (resolve) {
        resolve(fn.apply(self, args))
      })
      result.done(release, release)
      return result
    } else {
      return new Promise(function (resolve) {
        queue.push(new Delayed(resolve, fn, self, args))
      })
    }
  }
  function release() {
    size++
    if (queue.length) {
      var next = queue.shift()
      next.resolve(run(next.fn, next.self, next.args))
    }
  }
  if (typeof fn === 'function') {
    return function () {
      var args = arguments
      return run(fn, this, arguments)
    }
  } else {
    return function (fn) {
      return run(fn, this, Array.prototype.slice.call(arguments, 1))
    }
  }
}

function Delayed(resolve, fn, self, args) {
  this.resolve = resolve
  this.fn = fn
  this.self = self || null
  this.args = args || null
}
},{"promise":3}],2:[function(_dereq_,module,exports){
'use strict'

var nextTick = _dereq_('./lib/next-tick')

module.exports = Promise
function Promise(fn) {
  if (!(this instanceof Promise)) return new Promise(fn)
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var delegating = false
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new Promise(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    nextTick(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    if (delegating)
      return
    resolve_(newValue)
  }

  function resolve_(newValue) {
    if (state !== null)
      return
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          delegating = true
          then.call(newValue, resolve_, reject_)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject_(e) }
  }

  function reject(newValue) {
    if (delegating)
      return
    reject_(newValue)
  }

  function reject_(newValue) {
    if (state !== null)
      return
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  try { fn(resolve, reject) }
  catch(e) { reject(e) }
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

},{"./lib/next-tick":4}],3:[function(_dereq_,module,exports){
'use strict'

//This file contains then/promise specific extensions to the core promise API

var Promise = _dereq_('./core.js')
var nextTick = _dereq_('./lib/next-tick')

module.exports = Promise

/* Static Functions */

Promise.from = function (value) {
  if (value instanceof Promise) return value
  return new Promise(function (resolve) { resolve(value) })
}
Promise.denodeify = function (fn) {
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      fn.apply(self, args)
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    try {
      return fn.apply(this, arguments).nodeify(callback)
    } catch (ex) {
      if (callback == null) {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        nextTick(function () {
          callback(ex)
        })
      }
    }
  }
}

Promise.all = function () {
  var args = Array.prototype.slice.call(arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : arguments)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

/* Prototype Methods */

Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    nextTick(function () {
      throw err
    })
  })
}
Promise.prototype.nodeify = function (callback) {
  if (callback == null) return this

  this.then(function (value) {
    nextTick(function () {
      callback(null, value)
    })
  }, function (err) {
    nextTick(function () {
      callback(err)
    })
  })
}
},{"./core.js":2,"./lib/next-tick":4}],4:[function(_dereq_,module,exports){
(function (process){
'use strict'

if (typeof setImmediate === 'function') { // IE >= 10 & node.js >= 0.10
  module.exports = function(fn){ setImmediate(fn) }
} else if (typeof process !== 'undefined' && process && typeof process.nextTick === 'function') { // node.js before 0.10
  module.exports = function(fn){ process.nextTick(fn) }
} else {
  module.exports = function(fn){ setTimeout(fn, 0) }
}

}).call(this,_dereq_("/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":5}],5:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
(1)
});
/* globals window, _ */
(function() {
  "use strict";

  var VIZI = {
    VERSION: 1.0,
    DEBUG: false
  };

  // Output ASCII logo
  console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\r\nâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•\r\nâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\r\nâ•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘\r\n â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\r\n  â•šâ•â•â•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â• â•šâ•â•â•â•â•â•â•šâ•â•   â•šâ•â•   â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•\r\n\r\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 0.1.0 â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  // List any constants or helper functions here, like:
  // https://github.com/mrdoob/three.js/blob/master/src/Three.js

  // Expose VIZI to the window
  window.VIZI = VIZI;
}());
/* globals window, _, VIZI, moment */
(function() {
  "use strict";

  // http://addyosmani.com/resources/essentialjsdesignpatterns/book/#mediatorpatternjavascript
  // http://www.paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/
  // http://benalman.com/projects/javascript-debug-console-log/

  // TODO: Fix line numbers

  // TODO: Update to use formatted output (colour, tables, style, etc)
  //       - https://coderwall.com/p/fskzdw
  //       - https://github.com/adamschwartz/log

  VIZI.Log = function() {
    if (!VIZI.DEBUG) {
      return;
    }
    
    var args = Array.prototype.slice.call(arguments);

    var timestamp = "[" + moment().format("HH:mm:ss.SSS") + "]";
    args.unshift(timestamp);

    if (console) {
      console.log.apply(console, args);
    }
  };
}());
/* globals window, _, VIZI */
(function() {
  "use strict";

  // http://addyosmani.com/resources/essentialjsdesignpatterns/book/#mediatorpatternjavascript
  // Apply to other objects using _.extend(newObj, VIZI.Mediator);
  VIZI.Mediator = (function() {
    // Storage for topics that can be broadcast or listened to
    var topics = {};

    // Subscribe to a topic, supply a callback to be executed
    // when that topic is broadcast to
    var subscribe = function( topic, fn ){

      if ( !topics[topic] ){ 
        topics[topic] = [];
      }

      topics[topic].push( { context: this, callback: fn } );

      return this;
    };

    // Publish/broadcast an event to the rest of the application
    var publish = function( topic ){

      var args;

      if ( !topics[topic] ){
        return false;
      } 

      args = Array.prototype.slice.call( arguments, 1 );
      for ( var i = 0, l = topics[topic].length; i < l; i++ ) {

        var subscription = topics[topic][i];
        subscription.callback.apply( subscription.context, args );
      }
      return this;
    };

    return {
      publish: publish,
      subscribe: subscribe
    };
  }());
}());
/* globals window, _, VIZI */
(function() {
  "use strict";

  // Animation methods and logic
  VIZI.Animation = (function() {
    // Easing formulas based on:
    // http://joshondesign.com/2013/03/01/improvedEasingEquations
    var easing = {
      cubicIn: function(t) {
        return Math.pow(t,3);
      },
      cubicInOut: function(t) {
        if(t < 0.5) return easing.cubicIn(t*2.0)/2.0;
        return 1-easing.cubicIn((1-t)*2)/2;                
      }
    };

    return {
      easing: easing
    };
  }());
}());
/* globals window, _, VIZI, dat */
(function() {
  "use strict";

  VIZI.Dat = function() {
    VIZI.Log("Inititialising dat.GUI");

    _.extend(this, VIZI.Mediator);

    this.gui = this.createGUI();

    this.subscribe("addToDat", this.addToDat);
  };

  VIZI.Dat.prototype.createGUI = function() {
    VIZI.Log("Creating dat.GUI");
    var gui = new dat.GUI();
    gui.close();
    return gui;
  };

  VIZI.Dat.prototype.addToDat = function(object, options) {
    VIZI.Log("Adding " + options.name + " to dat.GUI");

    // Create folder
    var folder = this.gui.addFolder(options.name);

    _.each(options.properties, function(property) {
      var controller = folder.add(object, property).listen();

      if (object.datChange) {
        controller.onChange(function() {
          object.datChange();
        });
      }
    });
  };
}());
/* globals window, _, VIZI, FPSMeter */
(function() {
  "use strict";

  VIZI.FPS = function() {
    VIZI.Log("Inititialising FPS meter");

    _.extend(this, VIZI.Mediator);

    this.domContainer = this.createDOMContainer();
    this.meters = {};

    this.subscribe("fpsTickStart", this.tickStart);
    this.subscribe("fpsTickEnd", this.tickEnd);
  };

  VIZI.FPS.prototype.createDOMContainer = function() {
    VIZI.Log("Creating FPS meter DOM container");

    var container = document.createElement("div");
    container.id = "fps-container";
    container.style.position = "absolute";
    container.style.left = 0;
    container.style.top = 0;

    document.body.appendChild(container);

    return container;
  };

  VIZI.FPS.prototype.createDOMElement = function() {
    VIZI.Log("Creating FPS meter DOM element");

    var element = document.createElement("div");
    element.style.float = "left";

    this.domContainer.appendChild(element);

    return element;
  };

  VIZI.FPS.prototype.createDOMTitle = function(name) {
    var title = document.createElement("p");

    // Style copied from FPSMeter
    title.style.color = "#999";
    title.style.fontFamily = "sans-serif";
    title.style.fontSize = "10px";
    title.style.fontWeight = "bold";
    title.style.margin = "0 5px 5px 5px";
    title.style.textAlign = "left";
    title.style.textTransform = "uppercase";
    
    title.innerHTML = name;

    return title;
  };  

  VIZI.FPS.prototype.createMeter = function(name) {
    VIZI.Log("Creating FPS meter: " + name);

    var domElement = this.createDOMElement(name);

    var meter = new FPSMeter(domElement, {
      theme: "colorful",
      decimals: 0,
      heat: 1,
      graph: 1,
      history: 20,
      position: "relative",
      left: 0,
      top: 0,
      margin: "5px 0 5px 5px"
    });

    domElement.appendChild(this.createDOMTitle(name));

    this.meters[name] = meter;

    return meter;
  };

  VIZI.FPS.prototype.tickStart = function(name) {
    var meter = (this.meters[name]) ? this.meters[name] : this.createMeter(name);
    meter.tickStart();
  };

  VIZI.FPS.prototype.tickEnd = function(name) {
    var meter = (this.meters[name]) ? this.meters[name] : this.createMeter(name);
    meter.tick();
  };
}());
/* globals window, _, VIZI */
(function() {
  "use strict";

  VIZI.RendererInfo = function() {
    VIZI.Log("Inititialising renderer info");

    _.extend(this, VIZI.Mediator);

    this.domContainer = this.createDOMContainer();
    this.domRender = this.createDOMElement();
    this.domMemory = this.createDOMElement();

    this.subscribe("updateRendererInfo", this.update);
  };

  VIZI.RendererInfo.prototype.createDOMContainer = function() {
    VIZI.Log("Creating renderer info DOM container");

    var container = document.createElement("div");
    container.id = "renderer-info-container";
    container.style.position = "absolute";
    container.style.left = 0;
    container.style.bottom = 0;

    document.body.appendChild(container);

    return container;
  };

  VIZI.RendererInfo.prototype.createDOMElement = function() {
    VIZI.Log("Creating renderer info DOM element");

    var element = document.createElement("div");
    element.style.float = "left";
    element.style.color = "#999";
    element.style.fontFamily = "sans-serif";
    element.style.fontSize = "10px";
    element.style.fontWeight = "bold";
    element.style.lineHeight = "1.2em";
    element.style.margin = "5px";
    element.style.textAlign = "left";
    element.style.textTransform = "uppercase";
    element.style.width = "100px";

    this.domContainer.appendChild(element);

    return element;
  };

  VIZI.RendererInfo.prototype.createInfoStrings = function(info) {
    var memoryString = "";
    memoryString += "Programs: " + info.memory.programs + "<br>";
    memoryString += "Geometries: " + info.memory.geometries + "<br>";
    memoryString += "Textures: " + info.memory.textures + "<br>";

    var renderString = "";
    renderString += "Calls: " + info.render.calls + "<br>";
    renderString += "Vertices: " + info.render.vertices + "<br>";
    renderString += "Faces: " + info.render.faces + "<br>";
    renderString += "Points: " + info.render.points + "<br>";

    return [renderString, memoryString];
  };

  VIZI.RendererInfo.prototype.update = function(info) {
    var infoStrings = this.createInfoStrings(info);
    this.domRender.innerHTML = infoStrings[0];
    this.domMemory.innerHTML = infoStrings[1];
  };
}());
/* globals window, _, VIZI, Q */
(function() {
  "use strict";

  VIZI.Loading = function() {
    VIZI.Log("Initialising loading UI");

    _.extend(this, VIZI.Mediator);

    this.domContainer = undefined;
    this.domTimer = undefined;
    this.domIndicator = undefined;
  };

  VIZI.Loading.prototype.init = function(domElement) {
    this.domContainer = this.createDOMContainer(domElement);
    this.domTimer = this.createDOMTimer();
    this.domIndicator = this.createDOMIndicator();

    this.subscribe("loadingProgress", this.progress);
    this.subscribe("loadingComplete", function() {
      this.remove(domElement);
    });

    return Q.fcall(function() {});
  };

  VIZI.Loading.prototype.createDOMContainer = function(domElement) {
    VIZI.Log("Creating loading UI DOM container");

    var container = document.createElement("div");
    container.id = "ui-loading-container";

    container.style.background = "#666";
    container.style.left = 0;
    container.style.height = "100%";
    container.style.position = "absolute";
    container.style.top = 0;
    container.style.width = "100%";
    container.style.zIndex = 9999;

    domElement.appendChild(container);

    return container;
  };

  // Eventually use a nice animated spinning 3D city loading thing
  // Or CSS loading bars, like:
  // http://codepen.io/collection/HtAne
  // http://codepen.io/SLembas/pen/kotcg
  VIZI.Loading.prototype.createDOMTimer = function() {
    VIZI.Log("Creating loading UI timer DOM");

    var timerContainerDOM = document.createElement("div");
    timerContainerDOM.classList.add("ui-loading-timer-container");

    var timerDOM = document.createElement("div");
    timerDOM.classList.add("ui-loading-timer");

    var handDOM = document.createElement("div");
    handDOM.classList.add("ui-loading-hand");

    timerDOM.appendChild(handDOM);
    timerContainerDOM.appendChild(timerDOM);
    this.domContainer.appendChild(timerContainerDOM);

    return timerContainerDOM;
  };

  VIZI.Loading.prototype.createDOMIndicator = function() {
    VIZI.Log("Creating loading UI indicator DOM");

    var indicatorContainerDOM = document.createElement("div");
    indicatorContainerDOM.classList.add("ui-loading-indicator-container");

    var indicatorBarDOM = document.createElement("div");
    indicatorBarDOM.classList.add("ui-loading-indicator-bar");

    indicatorContainerDOM.appendChild(indicatorBarDOM);
    this.domContainer.appendChild(indicatorContainerDOM);

    return indicatorBarDOM;
  };

  VIZI.Loading.prototype.progress = function(fraction) {
    var position = (-100 + (100 * fraction)) + "%";

    this.domIndicator.style.WebkitTransform = "translate3d(" + position + ", 0, 0)";
    this.domIndicator.style.MozTransform = "translate3d(" + position + ", 0, 0)";
    this.domIndicator.style.transform = "translate3d(" + position + ", 0, 0)";
  };

  VIZI.Loading.prototype.remove = function(domElement) {
    var self = this;

    setTimeout(function() {
      self.domContainer.classList.add("inactive");
    }, 800);

    setTimeout(function() {
      VIZI.Log("Removing loading UI DOM container");
      domElement.removeChild(self.domContainer);
    }, 2000);
  };
}());
/* globals window, _, VIZI, Q */
(function() {
  "use strict";

  VIZI.Attribution = function() {
    VIZI.Log("Initialising attribution UI");

    _.extend(this, VIZI.Mediator);

    this.domContainer = undefined;
    this.domAttribution = undefined;
  };

  VIZI.Attribution.prototype.init = function() {
    this.domContainer = this.createDOMContainer();
    this.domAttribution = this.createDOMAttribution();

    return Q.fcall(function() {});
  };

  // TODO: Decide if CSS should be here or all in the CSS file
  VIZI.Attribution.prototype.createDOMContainer = function() {
    VIZI.Log("Creating attribution UI DOM container");

    var container = document.createElement("div");
    container.id = "ui-attribution-container";

    container.style.bottom = "0";
    container.style.fontFamily = "Arial, Verdana, sans-serif";
    container.style.fontSize = "10px";
    container.style.position = "absolute";
    container.style.right = "0";
    container.style.zIndex = "9998";

    document.body.appendChild(container);

    return container;
  };

  VIZI.Attribution.prototype.createDOMAttribution = function() {
    VIZI.Log("Creating attribution UI ViziCities DOM");

    var attributionDOM = document.createElement("p");
    attributionDOM.classList.add("ui-attribution");

    attributionDOM.innerHTML = "<a href='https://www.openstreetmap.org/copyright'>Data &copy; OpenStreetMap contributors</a> | <a href='http://github.com/robhawkes/vizicities'>Powered by ViziCities</a>";

    attributionDOM.style.background = "rgba(255, 255, 255, 0.6)";
    attributionDOM.style.borderRadius = "3px 0 0";
    attributionDOM.style.padding = "3px 5px";

    this.domContainer.appendChild(attributionDOM);

    return attributionDOM;
  };
}());
/* globals window, _, VIZI, Q */
(function() {
  "use strict";

  VIZI.OSMEdit = function() {
    VIZI.Log("Initialising OSM edit UI");

    _.extend(this, VIZI.Mediator);

    this.domContainer = undefined;
    this.domOSMEdit = undefined;

    this.subscribe("centerPositionChanged", function(centerPixels, center) {
      this.updatePosition(center);
    });
  };

  VIZI.OSMEdit.prototype.init = function() {
    this.domContainer = this.createDOMContainer();
    this.domOSMEdit = this.createDOMOSMEdit();

    return Q.fcall(function() {});
  };

  // TODO: Decide if CSS should be here or all in the CSS file
  VIZI.OSMEdit.prototype.createDOMContainer = function() {
    VIZI.Log("Creating OSM edit UI DOM container");

    var container = document.createElement("div");
    container.id = "ui-osm-edit-container";

    container.style.bottom = "0";
    container.style.fontFamily = "Arial, Verdana, sans-serif";
    container.style.fontSize = "10px";
    container.style.position = "absolute";
    container.style.left = "0";
    container.style.zIndex = "9998";

    document.body.appendChild(container);

    return container;
  };

  VIZI.OSMEdit.prototype.createDOMOSMEdit = function() {
    VIZI.Log("Creating OSM edit UI ViziCities DOM");

    var osmEditDOM = document.createElement("p");
    osmEditDOM.classList.add("ui-osm-edit");

    osmEditDOM.innerHTML = "<a href='http://www.openstreetmap.org/edit'>Does this area look wrong? Edit it in OpenStreetMap</a>";

    osmEditDOM.style.background = "rgba(255, 255, 255, 0.6)";
    osmEditDOM.style.borderRadius = "0 3px 0 0";
    osmEditDOM.style.padding = "3px 5px";

    this.domContainer.appendChild(osmEditDOM);

    return osmEditDOM;
  };

  VIZI.OSMEdit.prototype.updatePosition = function(center) {
    this.domOSMEdit.firstChild.href = "http://www.openstreetmap.org/edit#map=16/" + center[1] + "/" + center[0];
  };
}());
/* globals window, _, VIZI, d3 */
(function() {
  "use strict";

  VIZI.Geo = (function() {
    var Geo = function(options) {
      _.extend(this, VIZI.Mediator);

      // Meters per degree latitude
      // Given radius of earth is 6378137 meters
      // (2 * Math.PI / 360) * 6378137 = 111319.49079327357
      // From: http://stackoverflow.com/a/7478827/997339
      this.metersPerLat = 111319.49;

      this.tileSize = 256;
      this.tileZoom = 15;

      this.projection = this.setProjection(options.center);

      // Center of view
      this.center = options.center || [0, 0];
      this.centerPixels = this.projection(this.center);
      this.bounds = this.getBounds(this.center);

      this.pixelsPerMeter = this.setPixelsPerMeter();

      this.subscribe("targetPositionChanged", this.onTargetChanged);
    };

    Geo.prototype.setProjection = function(coords) {
      return d3.geo.mercator()
        .center(coords) // Geographic coordinates of map centre
        .translate([0, 0]) // Pixel coordinates of .center()
        // Scale is the pixel width of the entire world when projected using the mercator projection.
        // So, if your json data had outlines for the whole world â€“ spanning from lat/lng -180,90 to 
        // latLng 180,-90 â€“ and if someScale was 1024, then the world would be drawn such that it exactly 
        // fits within a 1024x1024-pixel square.
        // http://stackoverflow.com/a/13277197/997339
        //.scale(256 * Math.pow(2, 14)); // Map width = tileSize * Math.pow(2, zoom)
        // Bitwise method
        // "Bitwise shifting any number x to the left by y bits yields x * 2^y."
        // From: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#<<_(Left_shift)
        // Map width (scale) = tilesize << zoom
        .scale(this.tileSize << this.tileZoom);
    };

    // TODO: Stop using London as a base for this
    // Pixel-per-meter: http://wiki.openstreetmap.org/wiki/Zoom_levels
    Geo.prototype.setPixelsPerMeter = function() {
      var pixelsPerLat = this.projection([0, 50])[1] - this.projection([0, 51])[1];
      // var pixelsPerLat = 6378137 * Math.cos(this.center[1])/Math.pow((this.tileZoom + 8), 2);
      return pixelsPerLat / this.metersPerLat;
    };

    // Return geographic boundary around given coordindate
    Geo.prototype.getBounds = function(coords, distance) {
      // Distance in degrees to calculate bounds from center
      // Default is around 1km each direction
      var distanceLat = distance || 0.009;
      var distanceLon = distanceLat * 2;

      var bounds = {
        n: this.decimalPlaces(coords[1] + distanceLat),
        e: this.decimalPlaces(coords[0] + distanceLon),
        s: this.decimalPlaces(coords[1] - distanceLat),
        w: this.decimalPlaces(coords[0] - distanceLat)
      };

      return bounds;
    };

    Geo.prototype.onTargetChanged = function(pos3d) {
      this.centerPixels = [pos3d.x, pos3d.z];
      this.center = this.projection.invert(this.centerPixels);
      this.bounds = this.getBounds(this.center);

      this.publish("centerPositionChanged", this.centerPixels, this.center, this.bounds);
    };

    Geo.prototype.decimalPlaces = function(num, places) {
      places = places || 5;
      return parseFloat(num).toFixed(places);
    };

    var instance;

    // an emulation of static variables and methods
    var _static = {   
      name: "VIZI.Geo",

      // Method for getting an instance. It returns 
      // a singleton instance of a singleton object
      getInstance: function( options ) {
        if ( instance  ===  undefined )  {
          instance = new Geo( options );
        }

        return instance;
      }
    };

    return _static;
  }());
}());
/* globals window, _, VIZI, Q */
(function() {
  "use strict";

  VIZI.City = function() {
    VIZI.Log("Inititialising city");

    _.extend(this, VIZI.Mediator);

    // Debug tools
    this.dat = undefined;
    this.fps = undefined;
    this.rendererInfo = undefined;

    // Options
    this.options = undefined;

    // UI
    this.ui = {};
    this.ui.loading = undefined;
    this.ui.attribution = undefined;
    this.ui.osmEdit = undefined;

    // Geo methods
    this.geo = undefined;

    // Grid manager
    this.grid = undefined;

    // Data gathering and processing
    this.data = undefined;
      
    // Basic WebGL components (scene, camera, renderer, lights, etc)
    this.webgl = undefined;

    // DOM - elements and events (window resize, etc)
    this.domElement = undefined;
    this.domEvents = undefined;

    // Controls (mouse, keyboard, Leap, etc)
    this.controls = undefined;

    // Core city-scene objects (floor, skybox, etc)
    this.floor = undefined;

    // Main application loop
    this.loop = undefined;

    this.publish("addToDat", this, {name: "City", properties: ["init"]});

    this.subscribe("hashchange", this.onHashchange);
  };

  VIZI.City.prototype.init = function(options) {
    VIZI.Log("Loading city");

    var startTime = Date.now();
    var self = this;

    var deferred = Q.defer();

    if (!options) {
      options = {};
    }

    self.options = options;

    var hash = window.location.hash.replace('#', '');
    var coordCheck = /^(\-?\d+(\.\d+)?),(\-?\d+(\.\d+)?)$/;
    if (coordCheck.test(hash)) {
      options.coords = hash.split(',').reverse();
    }

    _.defaults(options, {
      coords: [-0.01924, 51.50358],
      capZoom: true,
      capOrbit: true,
      overpass: true,
      overpassGridUpdate: true,
      overpassWayIntersect: false,
      controls: { enable: true }
    });

    // Output city options
    VIZI.Log(options);

    // Set up geo methods
    self.geo = VIZI.Geo.getInstance({
      center: options.coords
    });

    // Store DOM reference
    self.domElement = self.options.domElement;

    // Load city using promises

    self.publish("loadingProgress", 0);

    // Initialise loading UI
    self.initLoadingUI().then(function() {
      self.publish("loadingProgress", 0.1);

      // Initialise debug tools
      return self.initDebug();
    }).then(function() {
      self.publish("loadingProgress", 0.15);

      // Initialise attribution and OSM edit UI
      var promises = [];

      // Initialise DOM events
      promises.push(self.initAttributionUI());

      // Initialise controls
      promises.push(self.initOSMEditUI());

      return Q.allSettled(promises);
    }).then(function() {
      self.publish("loadingProgress", 0.25);

      // Initialise WebGL
      return self.initWebGL(options);
    }).then(function() {
      self.publish("loadingProgress", 0.3);

      var promises = [];

      // Initialise DOM events
      promises.push(self.initDOMEvents());

      // Initialise controls
      promises.push(self.initControls());

      return Q.allSettled(promises);
    }).then(function() {
      self.publish("loadingProgress", 0.4);

      // Initialise grid manager
      return self.initGrid();
    }).then(function() {
      self.publish("loadingProgress", 0.5);

      // TODO: Work out a way to use progress event of each promises to increment loading progress
      // Perhaps by looping through each promises individually and working out progress fraction by num. of promises / amount processed

      // Load objects using promises
      var promises = [];

      // Load core city objects
      promises.push(self.loadCoreObjects());

      // Load data from the OSM Overpass API
      // Set up data loader
      if (options.overpass) {
        self.data = new VIZI.DataOverpass({
          gridUpdate: options.overpassGridUpdate
        });
        promises.push(self.loadOverpass(options.overpassWayIntersect));
      }

      return Q.allSettled(promises);
    }).then(function (results) {
      // Set up and start application loop
      self.loop = new VIZI.Loop();

      self.publish("loadingProgress", 1);
      self.publish("loadingComplete");

      VIZI.Log("Finished loading city in " + (Date.now() - startTime) + "ms");

      deferred.resolve();
    });

    return deferred.promise;
  };

  VIZI.City.prototype.initAttributionUI = function() {
    var startTime = Date.now();

    var deferred = Q.defer();

    this.ui.attribution = new VIZI.Attribution();

    this.ui.attribution.init().then(function(result) {
      VIZI.Log("Finished intialising attribution UI in " + (Date.now() - startTime) + "ms");

      deferred.resolve();
    });

    return deferred.promise;
  };

  VIZI.City.prototype.initOSMEditUI = function() {
    var startTime = Date.now();

    var deferred = Q.defer();

    this.ui.osmEdit = new VIZI.OSMEdit();

    this.ui.osmEdit.init().then(function(result) {
      VIZI.Log("Finished intialising OSM edit UI in " + (Date.now() - startTime) + "ms");

      deferred.resolve();
    });

    return deferred.promise;
  };

  VIZI.City.prototype.initLoadingUI = function() {
    var startTime = Date.now();

    var deferred = Q.defer();

    this.ui.loading = new VIZI.Loading();

    this.ui.loading.init(this.domElement).then(function(result) {
      VIZI.Log("Finished intialising loading UI in " + (Date.now() - startTime) + "ms");

      deferred.resolve();
    });

    return deferred.promise;
  };

  VIZI.City.prototype.initDebug = function() {
    VIZI.Log("Intialising debug tools");

    var startTime = Date.now();

    if (VIZI.DEBUG) {
      this.dat = new VIZI.Dat();
      this.fps = new VIZI.FPS();
      this.rendererInfo = new VIZI.RendererInfo();
    }

    VIZI.Log("Finished intialising debug tools in " + (Date.now() - startTime) + "ms");

    return Q.fcall(function() {});
  };

  // TODO: Move set up of core objects out to somewhere else
  VIZI.City.prototype.initWebGL = function(options) {
    var startTime = Date.now();

    var deferred = Q.defer();
    
    this.webgl = new VIZI.WebGL();

    this.webgl.init(this.domElement, this.geo.centerPixels, options.capZoom, options.capOrbit).then(function(result) {
      VIZI.Log("Finished intialising WebGL in " + (Date.now() - startTime) + "ms");

      deferred.resolve();
    });

    return deferred.promise;
  };

  VIZI.City.prototype.initDOMEvents = function() {
    var startTime = Date.now();

    var deferred = Q.defer();

    this.domEvents = new VIZI.DOMEvents();

    this.domEvents.init().then(function(result) {
      VIZI.Log("Finished intialising DOM events in " + (Date.now() - startTime) + "ms");

      deferred.resolve();
    });

    return deferred.promise;
  };

  VIZI.City.prototype.initControls = function() {
    var startTime = Date.now();

    var deferred = Q.defer();

    this.controls = VIZI.Controls.getInstance();

    this.controls.init(this.domElement, this.webgl.camera, this.options.controls).then(function(result) {
      VIZI.Log("Finished intialising controls in " + (Date.now() - startTime) + "ms");

      deferred.resolve();
    });

    return deferred.promise;
  };

  VIZI.City.prototype.initGrid = function() {
    var startTime = Date.now();

    var deferred = Q.defer();

    // Set up grid manager
    this.grid = VIZI.Grid.getInstance();

    this.grid.init(this.geo.center).then(function(result) {
      VIZI.Log("Finished intialising grid manager in " + (Date.now() - startTime) + "ms");

      deferred.resolve();
    });

    return deferred.promise;
  };

  VIZI.City.prototype.loadCoreObjects = function() {
    VIZI.Log("Loading core objects");

    var startTime = Date.now();

    // Set up core components
    this.floor = new VIZI.Floor();

    VIZI.Log("Finished loading core objects in " + (Date.now() - startTime) + "ms");

    return Q.fcall(function() {});
  };

  VIZI.City.prototype.loadOverpass = function(wayIntersect) {
    VIZI.Log("Loading data from OSM Overpass API");

    var startTime = Date.now();

    // var deferred = Q.defer();

    if (wayIntersect) {
      this.data.updateByWayIntersect(wayIntersect).done(function() {
        VIZI.Log("Finished loading Overpass data using way intersection in " + (Date.now() - startTime) + "ms");
      });
    } else {
      this.data.update().done(function() {
        VIZI.Log("Finished loading Overpass data in " + (Date.now() - startTime) + "ms");
        // deferred.resolve();
      });
    }

    // return deferred.promise;
    return Q.fcall(function() {});
  };

  VIZI.City.prototype.onHashchange = function(){
    window.location.reload();
  };

}());
/* globals window, _, VIZI */
(function() {
  "use strict";

  VIZI.Loop = function() {
    VIZI.Log("Inititialising application loop");

    _.extend(this, VIZI.Mediator);

    // High resolution time
    this.startTime = 0;
    this.lastTickTime = 0;

    this.stopLoop = false;

    this.publish("addToDat", this, {name: "Loop", properties: ["start", "stop"]});

    this.start();
  };

  VIZI.Loop.prototype.start = function() {
    VIZI.Log("Starting application loop");
    this.stopLoop = false;
    this.startTime = (window.performance && window.performance.now) ? (window.performance.now() + window.performance.timing.navigationStart) : Date.now();
    this.tick();
  };

  VIZI.Loop.prototype.stop = function() {
    VIZI.Log("Stopping application loop");
    this.stopLoop = true;
  };

  VIZI.Loop.prototype.tick = function(timestamp) {
    this.publish("fpsTickStart", "Main Loop");

    var delta = timestamp - this.lastTickTime;

    // if (timestamp < 1e12){
    // // .. high resolution timer
    // } else {
    // // integer milliseconds since unix epoch
    // }

    this.lastTickTime = timestamp;
    
    this.publish("update", delta, this.lastTickTime);
    this.publish("render", delta, this.lastTickTime);

    if (!this.stopLoop) {
      // Should probably be a bit more obvious that this comes from Three.js
      // http://stackoverflow.com/questions/6065169/requestanimationframe-with-this-keyword
      window.requestAnimationFrame( this.tick.bind(this) );
    }

    this.publish("fpsTickEnd", "Main Loop");
  };
}());
/* globals window, _, VIZI, Q */
(function() {
  "use strict";

  // TODO: Work out if a DOMEvents class is needed
  // - What else would go in here aside from resize?
  // - Would resize be better suited elsewhere (like mouse and keyboard controls)?
  VIZI.DOMEvents = function() {
    VIZI.Log("Inititialising DOM events");

    _.extend(this, VIZI.Mediator);
  };

  VIZI.DOMEvents.prototype.init = function() {
    var self = this;
    
    // Window resize
    window.addEventListener( "resize", function(event) {
      self.publish("resize", event);
    }, false );

    // Hash change
    window.addEventListener( "hashchange", function(event) {
      self.publish("hashchange", event);
    }, false );

    return Q.fcall(function() {});
  };
}());
/* globals window, _, VIZI, Q, THREE */
(function() {
  "use strict";

  VIZI.WebGL = function() {
    VIZI.Log("Initialising WebGL");

    _.extend(this, VIZI.Mediator);

    this.domContainer = undefined;
    this.scene = undefined;
    this.camera = undefined;
    this.renderer = undefined;

    this.lights = [];
  };

  VIZI.WebGL.prototype.init = function(domElement, cameraTargetPos, capZoom, capOrbit) {
    this.domContainer = this.createDOMContainer(domElement);
    this.scene = new VIZI.Scene();
    this.camera = new VIZI.Camera(cameraTargetPos, capZoom, capOrbit);
    this.renderer = new VIZI.Renderer(this.scene, this.camera, this.domContainer);

    this.lights = [];
    this.addLights();

    return Q.fcall(function() {});
  };

  VIZI.WebGL.prototype.createDOMContainer = function(domElement) {
    VIZI.Log("Creating WebGL DOM container");

    var container = document.createElement("div");
    container.classList.add("vizicities-webgl-container");

    domElement.appendChild(container);

    return container;
  };

  // TODO: Split lights out into classes
  VIZI.WebGL.prototype.addLights = function() {
    VIZI.Log("Adding lights to scene");

    // var ambientLight = new THREE.AmbientLight( 0xeeeeee );
    // THREE.ColorConverter.setHSV( ambientLight.color, 0.1, 0.1, 0.4 );

    // this.lights.push(ambientLight);
    // this.publish("addToScene", ambientLight);

    var directionalLight = new THREE.DirectionalLight( 0x999999 );
    directionalLight.intesity = 0.1;
    // THREE.ColorConverter.setHSV( directionalLight.color, 0.1, 0.1, 0.55 );
    directionalLight.position.x = 1;
    directionalLight.position.y = 1;
    directionalLight.position.z = 1;
    // directionalLight.position.normalize();

    this.lights.push(directionalLight);
    this.publish("addToScene", directionalLight);

    // var helper1 = new THREE.DirectionalLightHelper(directionalLight, 50);
    // this.publish("addToScene", helper1);

    var directionalLight2 = new THREE.DirectionalLight( 0x999999 );
    directionalLight2.intesity = 0.1;
    // THREE.ColorConverter.setHSV( directionalLight2.color, 0.1, 0.1, 0.5 );
    directionalLight2.position.x = -1;
    directionalLight2.position.y = 1;
    directionalLight2.position.z = -1;
    // directionalLight2.position.normalize();

    this.lights.push(directionalLight2);
    this.publish("addToScene", directionalLight2);

    // var helper2 = new THREE.DirectionalLightHelper(directionalLight2, 50);
    // this.publish("addToScene", helper2);

    // var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.65 );
    // THREE.ColorConverter.setHSV( hemiLight.color, 0.6, 0.35, 0.7 );
    // THREE.ColorConverter.setHSV( hemiLight.groundColor, 0.095, 0.5, 0.6 );
    // hemiLight.position.set( 0, 600, 0 );

    // this.lights.push(hemiLight);
    // this.publish("addToScene", hemiLight);
  };

  // Global helpers (move elsewhere?)
  VIZI.applyVertexColors = function( g, c ) {
    g.faces.forEach( function( f ) {
      var n = ( f instanceof THREE.Face3 ) ? 3 : 4;
      for( var j = 0; j < n; j ++ ) {
        f.vertexColors[ j ] = c;
      }
    } );
  };
}());
/* globals window, _, VIZI, THREE */
(function() {
  "use strict";

  VIZI.Scene = function() {
    VIZI.Log("Inititialising WebGL scene");

    _.extend(this, VIZI.Mediator);

    this.scene = this.createScene();
    this.objects = [];

    // Listeners
    this.subscribe("addToScene", function(object) {
      VIZI.Log("Scene add object handler");
      VIZI.Log(object);
      this.addToScene(object);
    });

    this.subscribe("removeFromScene", function(object) {
      VIZI.Log("Scene remove object handler");
      VIZI.Log(object);
      this.removeFromScene(object);
    });
  };

  VIZI.Scene.prototype.createScene = function() {
    VIZI.Log("Creating WebGL scene");

    var scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xffffff, 1, 40000);

    return scene;
  };

  VIZI.Scene.prototype.addToScene = function(object) {
    this.scene.add(object);
    this.objects.push(object);
  };

  VIZI.Scene.prototype.removeFromScene = function(object) {
    this.scene.remove(object);

    // Clean up
    // http://mrdoob.github.io/three.js/examples/webgl_test_memory.html
    if (object.geometry) {
      object.geometry.dispose();
    }

    if (object.material) {
      object.material.dispose();
    }

    if (object.texture) {
      object.texture.dispose();
    }

    // Remove object from objects array
    var index = _.indexOf(this.objects, object);
    if (index > -1) {
      this.objects.splice(index, 1);
    }
  };
}());
/* globals window, _, VIZI, THREE */
(function() {
  "use strict";

  VIZI.Camera = function(pos, capZoom, capOrbit) {
    VIZI.Log("Inititialising WebGL camera");

    _.extend(this, VIZI.Mediator);

    this.cameraRadius = 1500;
    this.theta = 45; // Horizontal orbit
    this.phi = 80; // Vertical oribt

    this.capZoom = (capZoom === false) ? false : true;
    this.capOrbit = (capOrbit === false) ? false : true;

    this.target = new THREE.Object3D();
    this.updateTargetPositon(pos);

    this.camera = this.createCamera();
    this.lookAtTarget();

    this.publish("addToScene", this.camera);
    this.publish("addToDat", this, {name: "Camera", properties: ["cameraRadius", "theta", "phi"]});

    this.subscribe("resize", this.resize);
    this.subscribe("zoomControl", this.zoom);
    this.subscribe("panControl", this.pan);
    this.subscribe("orbitControl", this.orbit);
  };

  VIZI.Camera.prototype.createCamera = function() {
    VIZI.Log("Creating WebGL camera");

    var camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 2, 40000 );
    this.updatePosition(camera);

    return camera;
  };

  // TODO: Why is a camera object being passed in?
  VIZI.Camera.prototype.updatePosition = function(camera) {
    camera = (camera) ? camera : this.camera;
    camera.position.x = this.target.position.x + this.cameraRadius * Math.sin( this.theta * Math.PI / 360 ) * Math.cos( this.phi * Math.PI / 360 );
    camera.position.y = this.target.position.y + this.cameraRadius * Math.sin( this.phi * Math.PI / 360 );
    camera.position.z = this.target.position.z + this.cameraRadius * Math.cos( this.theta * Math.PI / 360 ) * Math.cos( this.phi * Math.PI / 360 );
    camera.updateMatrix();

    this.publish("targetPositionChanged", this.target.position);
  };

  VIZI.Camera.prototype.updateTargetPositon = function(pos) {
    this.target.position.x = pos[0];
    this.target.position.z = pos[1];
  };

  VIZI.Camera.prototype.lookAtTarget = function() {
    this.camera.lookAt(this.target.position);
  };

  VIZI.Camera.prototype.resize = function() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
  };

  VIZI.Camera.prototype.zoom = function(delta) {
    var oldcameraRadius = this.cameraRadius;

    this.cameraRadius += delta;

    var cameraRadiusDiff = this.cameraRadius - oldcameraRadius;

    if (this.capZoom) {
    // Cap zoom to bounds
      var zoomCapLow = 250;
      if (this.cameraRadius < zoomCapLow) {
        this.cameraRadius = zoomCapLow;
        cameraRadiusDiff = zoomCapLow - oldcameraRadius;
      }

      var zoomCapHigh = 2000;
      if (this.cameraRadius > zoomCapHigh) {
        this.cameraRadius = zoomCapHigh;
        cameraRadiusDiff = zoomCapHigh - oldcameraRadius;
      }
    }
    
    this.camera.translateZ( cameraRadiusDiff );

    this.updatePosition();

    this.publish("render");
  };

  VIZI.Camera.prototype.pan = function(delta3d) {
    this.target.position.x += delta3d.x;
    this.target.position.z += delta3d.z;

    this.updatePosition();

    // Forced render prevents annoying glitch when panning
    // TODO: Stop this causing twice as many frames being rendered while panning
    // - Perhaps aspects of .render() can be performed without updating the display
    // - https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js#L3199
    // TODO: If unavoidable, think about ways to reduce the performance impact of double-rendering
    // - Removing post-processing during pan
    // - Lowering quality / upscaling during pan
    // - Enabling lower LOD during pan
    // - Removing high-detailed objects during pan (buildings)
    // - Pausing animations during pan (AI, live data, etc)
    this.publish("render");
  };

  VIZI.Camera.prototype.orbit = function(delta2d, theta, phi) {
    // Round delta to next highest pixel to prevent jerkiness
    this.theta = - ( delta2d.x * 0.5 ) + theta;
    this.phi = ( delta2d.y * 0.5 ) + phi;

    if (this.capOrbit) {
      // Cap orbit to bounds
      this.phi = Math.min( 175, Math.max( 65, this.phi ) );

      // Let controls know that the cap has been hit
      if (this.phi === 175 || this.phi === 65) {
        this.publish("orbitControlCap");
      }
    }

    this.updatePosition();
    this.lookAtTarget();

    this.publish("render");
  };

  VIZI.Camera.prototype.datChange = function() {
    this.updatePosition();
    this.lookAtTarget();
  };
}());
/* globals window, _, VIZI, THREE */
(function() {
  "use strict";

  VIZI.Renderer = function(scene, camera, domContainer) {
    VIZI.Log("Inititialising WebGL renderer");

    _.extend(this, VIZI.Mediator);

    this.scene = scene.scene;
    this.camera = camera.camera;
    this.domContainer = domContainer;

    this.renderer = this.createRenderer();

    // Listeners
    this.subscribe("render", this.render);
    this.subscribe("resize", this.resize);
  };

  VIZI.Renderer.prototype.createRenderer = function() {
    var renderer = new THREE.WebGLRenderer({
      antialias: false
    });

    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setClearColor( this.scene.fog.color, 1 );

    // Gamma settings make things look 'nicer' for some reason
    renderer.gammaInput = true;
    renderer.gammaOutput = true;

    renderer.physicallyBasedShading = true;

    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;

    this.domContainer.appendChild(renderer.domElement);

    return renderer;
  };

  VIZI.Renderer.prototype.render = function() {
    this.publish("fpsTickStart", "render");
    this.renderer.render( this.scene, this.camera );
    this.publish("updateRendererInfo", this.renderer.info);
    this.publish("fpsTickEnd", "render");
  };

  VIZI.Renderer.prototype.resize = function() {
    this.renderer.setSize( window.innerWidth, window.innerHeight );
  };
}());
/* globals window, _, VIZI, THREE, Q, d3, cw */
(function() {
  "use strict";

  VIZI.ObjectManager = function() {
    _.extend(this, VIZI.Mediator);

    this.combinedMaterial = new THREE.MeshLambertMaterial({vertexColors: THREE.VertexColors});
    this.combinedObjects = undefined;
  };

  // TODO: Convert to a promise
  VIZI.ObjectManager.prototype.processFeatures = function(features) {
    var startTime = Date.now();

    var objects = _.map(features, this.processFeature);

    VIZI.Log(Date.now() - startTime);

    this.combinedObjects = this.combineObjects(objects);

    this.publish("addToScene", this.combinedObjects);
  };

  VIZI.ObjectManager.prototype.workerPromise = function(worker, features, pixelsPerMeter) {
    var deferred = Q.defer();

    var startTime = Date.now();
    worker.process([features, pixelsPerMeter]).then(function(data) {
      var timeToSend = data.startTime - startTime;
      var timeToArrive = Date.now() - data.timeSent;
      deferred.resolve({data: data, timeToArrive: timeToArrive, timeToSend: timeToSend});
    });
    return deferred.promise;
  };

  VIZI.ObjectManager.prototype.processFeaturesWorker = function(features) {};
  VIZI.ObjectManager.prototype.processFeature = function(feature) {};

  VIZI.ObjectManager.prototype.combineObjects = function(objects) {
    var combinedGeom = new THREE.Geometry();

    _.each(objects, function(object) {
      if (!object.object) {
        return;
      }

      THREE.GeometryUtils.merge(combinedGeom, object.object);
    });

    combinedGeom.computeFaceNormals();

    return new THREE.Mesh( combinedGeom, this.combinedMaterial );
  };
}());

/* globals window, _, VIZI, THREE, Q, d3, cw */
(function() {
  "use strict";

  VIZI.ObjectManagerOverpass = function() {
    _.extend(this, VIZI.Mediator);

    VIZI.ObjectManager.call(this);

    this.combinedMaterial = new THREE.MeshLambertMaterial({vertexColors: THREE.VertexColors});
    this.combinedObjects = undefined;

    this.objectAnimations = {};

    // Listeners
    this.subscribe("update", this.animate);
  };

  VIZI.ObjectManagerOverpass.prototype = Object.create( VIZI.ObjectManager.prototype );

  // ##########################################
  // Web Worker Loader
  // ##########################################
  // - Features (as JSON) are passed to worker manager
  // - Worker manager splits features into batches and passes each worker a batch
  // - Each worker processes features and passes a reference back using transferable objects
  // - Features are added to scene for each completed worker promise

  // TODO: Move feature definition and render options into separate class (eg. BuildingManager and Building)
  //       - Right now, the generation of Three.js objects in this file is based on buildings
  // TODO: Should be possible if geo functionality can be performed before / after the worker task
  // TODO: Try and get rid of lock-up that occurs at beginning and end of worker process (possibly due to size of data being sent back and forth)
  // TODO: Build objects as BufferGeometry for very easy export and messaging out of worker
  // http://stackoverflow.com/questions/18262868/transforming-geometry-to-buffergeometry
  // https://github.com/mrdoob/three.js/blob/f396baf5876eb41bcd2ee34eb65b1f97bb92d530/examples/js/exporters/BufferGeometryExporter.js

  VIZI.ObjectManagerOverpass.prototype.processFeaturesWorker = function(features, pixelsPerMeter) {
    VIZI.Log("Processing features using worker");

    var deferred = Q.defer();

    // TODO: See if initialising this before calling processFeaturesWorker speeds things up
    var worker = cw({
      process: function(input, callback) {
        importScripts("worker/three.min.js", "worker/GeometryExporter.js", "worker/underscore.min.js");

        var features = input[0];
        var pixelsPerMeter = input[1];

        var inputSize = JSON.stringify(features).length;

        var startTime = Date.now();

        var exporter = new THREE.GeometryExporter();

        var applyVertexColors = function( g, c ) {
          g.faces.forEach( function( f ) {
            var n = ( f instanceof THREE.Face3 ) ? 3 : 4;
            for( var j = 0; j < n; j ++ ) {
              f.vertexColors[ j ] = c;
            }
          } );
        };

        var createExtrudedObject = function(feature) {
          var properties = feature.properties;

          // var area = properties["vizicities:area"];

          // // Skip if building area is too small
          // if (area < 200) {
          // return;
          // }

          var offset = [];
          var coords = feature.coordinates;
          var shape = new THREE.Shape();
          _.each(coords, function(coord, index) {
            if (offset.length === 0) {
              offset[0] = -1 * coord[0];
              offset[1] = -1 * coord[1];
            }

            // Move if first coordinate
            if (index === 0) {
              shape.moveTo( coord[0] + offset[0], coord[1] + offset[1] );
            } else {
              shape.lineTo( coord[0] + offset[0], coord[1] + offset[1] );
            }
          });

          // Add holes
          if (feature.holes && feature.holes.length > 0) {
            _.each(feature.holes, function(hole, index) {
              var holePath = new THREE.Path();
              _.each(hole, function(coord, index) {
                // Move if first coordinate
                if (index === 0) {
                  holePath.moveTo( coord[0] + offset[0], coord[1] + offset[1] );
                } else {
                  holePath.lineTo( coord[0] + offset[0], coord[1] + offset[1] );
                }
              });
              shape.holes.push(holePath);
            });
          }

          // Height value is in meters
          var height = properties.height;

          var minHeight = 0;
          if (properties.minHeight) {
            minHeight = properties.minHeight;
          }

          var extrudeSettings = { amount: height - minHeight, bevelEnabled: false };
          var geom = new THREE.ExtrudeGeometry( shape, extrudeSettings );

          // Check if this shape only has four points, allowing us
          // to do roof shortcuts
          if (shape.curves.length === 4) {

            // Check if it's a gabled roof
            if (properties.roof.shape === "gabled") {

              // Roof geometry
              var roof = new THREE.Geometry();

              // Grab the points from the shape
              var points = shape.extractPoints();

              // Figure out the roof height
              var roofHeight = -(height / 2);

              // Figure out the center points
              var center1 = points.shape[0].clone().lerp(points.shape[1], 0.5);
              var center2 = points.shape[2].clone().lerp(points.shape[3], 0.5);

              // Create the vertices
              var vertices = [
                new THREE.Vector3(points.shape[0].x, points.shape[0].y, 0),
                new THREE.Vector3(center1.x,         center1.y,         roofHeight),
                new THREE.Vector3(points.shape[1].x, points.shape[1].y, 0),
                new THREE.Vector3(points.shape[2].x, points.shape[2].y, 0),
                new THREE.Vector3(center2.x,         center2.y,         roofHeight),
                new THREE.Vector3(points.shape[3].x, points.shape[3].y, 0),
              ];

              // Ensure the points are clockwise
              var clockwise = THREE.Shape.Utils.isClockWise(vertices);
              if (!clockwise) {
                vertices = vertices.reverse();
              }

              roof.vertices = vertices;

              // Side 1
              roof.faces.push(new THREE.Face3(3, 4, 1));
              roof.faces.push(new THREE.Face3(3, 1, 2));

              // Front/Back
              roof.faces.push(new THREE.Face3(4, 3, 5));
              roof.faces.push(new THREE.Face3(1, 0, 2));

              // Side 2
              roof.faces.push(new THREE.Face3(0, 1, 4));
              roof.faces.push(new THREE.Face3(0, 4, 5));

              // We aren't generating actual UVs, but the exporter needs
              // some placeholder points
              _.each(roof.faces, function() {
                roof.faceVertexUvs[0].push([false, false, false]);
              });

              // Add to the building geometry
              THREE.GeometryUtils.merge(geom, roof);
            }
          }

          var elementColour = (properties.colour) ? new THREE.Color(properties.colour) : colour;
          applyVertexColors( geom, elementColour );

          geom.computeFaceNormals();
          var mesh = new THREE.Mesh(geom);

          mesh.position.y = height;

          // Offset building
          mesh.position.x = -1 * offset[0];
          mesh.position.z = -1 * offset[1];

          // Flip buildings as they are up-side down
          mesh.rotation.x = 90 * Math.PI / 180;

          return mesh;
        };

        // START: http://bai.dev.supcrit.com/scripts/engine/things/road.js

        var thickness = 0.01 * pixelsPerMeter;
        var width = 4 * pixelsPerMeter;

        // var thickness = 1;
        // var width = 10;
        
        var roadpoints = [
          new THREE.Vector2(-thickness, width/2),
          new THREE.Vector2(-thickness, -width/2),
          new THREE.Vector2(thickness, -width/2),
          new THREE.Vector2(thickness, width/2),
          new THREE.Vector2(-thickness, width/2)
        ];

        var roadshape = new THREE.Shape(roadpoints);

        // END: http://bai.dev.supcrit.com/scripts/engine/things/road.js

        var createRoadObject = function(feature) {
          var properties = feature.properties;

          // Skip non-roads for simplicity
          var type = properties.highway;
          if (type === "footway" || type === "pedestrian" || type === "steps" || type === "cycleway") {
            return;
          }

          var layer = Number(properties.layer);
          
          var featureColour = new THREE.Color(0xc1c1c1);
          // switch (layer) {
          //   case -1:
          //     featureColour = new THREE.Color(0xFF0000);
          //     break;
          //   case 0:
          //     featureColour = new THREE.Color(0x00FF00);
          //     break;
          //   case 1:
          //     featureColour = new THREE.Color(0x0000FF);
          //     break;
          // }

          var offset = [];
          var splinePoints = [];
          var coords = feature.coordinates;
          _.each(coords, function(coord, index) {
            if (offset.length === 0) {
              offset[0] = -1 * coord[0];
              offset[1] = -1 * coord[1];
            }

            // splinePoints.push(new THREE.Vector3(coord[0] + offset[0], (layer) ? 5 + layer*10 : 5, coord[1] + offset[1]));
            splinePoints.push(new THREE.Vector3(coord[0] + offset[0], thickness/2, coord[1] + offset[1]));
          });

          var splinePath = new THREE.SplineCurve3(splinePoints);

          // START: http://bai.dev.supcrit.com/scripts/engine/things/road.js

          // Segments on each spline
          // console.log(Math.max(10, Math.floor(splinePath.getLength() * 0.05)));
          var steps = Math.max(10, Math.floor(splinePath.getLength() * 0.05));
          var frames = {tangents: [], normals: [], binormals: []};
          var normal = new THREE.Vector3(0,1,0);

          for ( var k = 0; k < steps + 1; k++ ) {
            var u = k / steps;
            var tangent = splinePath.getTangentAt( u ).normalize();
            frames.tangents[k] = tangent;
            frames.normals[k] = normal;
            frames.binormals[k] = tangent.clone().cross(normal);
          }

          var uvgenerator = {
            generateTopUV: THREE.ExtrudeGeometry.WorldUVGenerator.generateTopUV,
            generateBottomUV: THREE.ExtrudeGeometry.WorldUVGenerator.generateBottomUV,
            generateSideWallUV:  THREE.ExtrudeGeometry.WorldUVGenerator.generateSideWallUV,
            foo: function(geometry, extrudedShape, wallCountour, extrudeOptions, indexA, indexB, indexC, indexD, stepIndex, stepsLength, contourIndex1, contourIndex2) {
              var v2 = new THREE.Vector2(0,1);
              return [v2, v2, v2, v2];
            }
          };

          var geom = new THREE.ExtrudeGeometry(roadshape, { extrudePath: splinePath, frames: frames, steps: steps, closed: false, UVGenerator: uvgenerator});
          geom.computeVertexNormals();

          // var elementColour = (properties.colour) ? new THREE.Color(properties.colour) : colour;
          // applyVertexColors( geom, elementColour );

          applyVertexColors( geom, featureColour );

          // END: http://bai.dev.supcrit.com/scripts/engine/things/road.js

          geom.computeFaceNormals();
          var mesh = new THREE.Mesh(geom);

          // Offset
          mesh.position.x = -1 * offset[0];
          mesh.position.z = -1 * offset[1];

          return mesh;
        };

        // Default colour
        var colour = new THREE.Color(0xFF87FC);

        // Use random colour per worker to show grouping of objects
        // var colour = new THREE.Color(0xFFFFFF * Math.random());

        var combinedGeom = new THREE.Geometry();

        var count = 0;

        // TODO: Work out how to put feature-specific object generation in here
        //       - eg. Buildings, rivers, roads, etc.
        _.each(features, function(feature) {
          var properties = feature.properties;

          var mesh;

          // Building takes priority over highway
          // Avoids conflicts with ways like 231879501
          if (properties["building"]) {
            mesh = createExtrudedObject(feature);
          } else if (properties["highway"]) {
            mesh = createRoadObject(feature);
          } else {
            mesh = createExtrudedObject(feature);
          }

          THREE.GeometryUtils.merge(combinedGeom, mesh);

          count++;
        });

        // Move merged geom to 0,0 and return offset
        var offset = THREE.GeometryUtils.center( combinedGeom );

        var timeTaken = Date.now() - startTime;
        var exportedGeom = exporter.parse(combinedGeom);

        // The size of this seems to be the problem
        // Work out how to reduce it
        var outputSize = JSON.stringify(exportedGeom).length;

        // Convert exported geom into a typed array
        var verticesArray = new Float64Array( exportedGeom.vertices );
        var normalsArray = new Float64Array( exportedGeom.normals );
        // var colorsArray = new Float64Array( exportedGeom.colors );
        // Seems to be manually set to have 1 array in the uvs array
        // https://github.com/mrdoob/three.js/blob/master/examples/js/exporters/GeometryExporter.js#L231
        var uvsArray = new Float64Array( exportedGeom.uvs[0] );
        var facesArray = new Float64Array( exportedGeom.faces );

        // Store geom typed array as Three.js model object
        var model = {
          metadata: exportedGeom.metadata,
          colors: exportedGeom.colors,
          vertices: verticesArray,
          normals: normalsArray,
          uvs: uvsArray,
          faces: facesArray
        };

        var timeSent = Date.now();

        var data = {model: model, offset: offset, outputSize: outputSize, inputSize: inputSize, count: count, startTime: startTime, timeTaken: timeTaken, timeSent: timeSent};

        // Send exported geom back to worker manager
        // Second parameter contains reference to typed arrays as transferable objects
        callback(data, [model.vertices.buffer, model.normals.buffer, model.uvs.buffer, model.faces.buffer]);
      }
    });

    var startTime = Date.now();

    // TODO: Work out why this still locks up the browser (amount of data being transferred back from the worker? Is it quicker to create objects in the browser?)
    // Solution: https://speakerdeck.com/mourner/high-performance-data-visualizations?slide=51
    // TODO: See if simply batching objects and creating them in the browser is less sluggish for the browser
    // TODO: Work out why not every feature is being returned in the promises (about 10â€“20 less than expected)
    // TODO: Come up with a method of chosing enough batches to avoid call stack exceeded errors (too many things to render)
    //       while not using too many batches to cause problems with small numbers of features (eg. a single feature)
    //  - Manhattan is a good test for this

    // Batch features
    // 4 batches or below seems to stop the model.faces typed array from converting to a normal array
    // Ideal 8 batches, if odd then subtract difference to make featuresPerBatch division clean
    var batchCount = (features.length < 100) ? 6 : 12;
    var batchDiff = features.length % batchCount;
    var batches = (features.length < batchCount) ? features.length : batchCount;

    var featuresPerBatch = Math.floor(features.length / batches);

    var batchPromises = [];

    for (var i = 0; i < batches; i++) {
      var startIndex = i * featuresPerBatch;
      var endIndex = startIndex + featuresPerBatch;

      // Add diff if at end of batch
      if (i === batches - 1) {
        endIndex += batchDiff;
      }

      var featuresBatch = features.slice(startIndex, endIndex);

      batchPromises.push(this.workerPromise(worker, featuresBatch, pixelsPerMeter));
    }

    var loader = new THREE.JSONLoader();
    var material = new THREE.MeshLambertMaterial({
      vertexColors: THREE.VertexColors,
      ambient: 0xffffff,
      emissive: 0xcccccc,
      shading: THREE.FlatShading,
      transparent: true
    });

    var self = this;

    var combinedMesh;
    Q.allSettled(batchPromises).then(function (promises) {
      var totalReceivedTime = 0;

      var combinedGeom = new THREE.Geometry();

      _.each(promises, function (promise) {
        if (promise.state === "fulfilled") {
          var value = promise.value;
          var data = value.data;

          // Not sure how reliable the send time is
          var timeToSend = value.timeToSend;
          var timeToArrive = value.timeToArrive;
          var timeTaken = data.timeTaken;
          var inputSize = data.inputSize;
          var outputSize = data.outputSize;
          var count = data.count;
          var model = data.model;
          var offset = data.offset;

          // Convert typed data back to arrays
          model.vertices = Array.apply( [], model.vertices );
          model.normals = Array.apply( [], model.normals );
          // Wrap UVs within an array
          // https://github.com/mrdoob/three.js/blob/master/examples/js/exporters/GeometryExporter.js#L231
          model.uvs = [ Array.apply( [], model.uvs ) ];
          
          // Keep getting a "Maximum call stack size exceeded" error here
          //model.faces = Array.apply( [], model.faces );
          var faces = [];
          _.each(model.faces, function(face) {
            faces.push(face);
          });

          model.faces = faces;

          totalReceivedTime += timeToArrive;

          VIZI.Log("Worker input sent in " + timeToSend + "ms");
          VIZI.Log("Worker input size is " + inputSize);
          VIZI.Log("Worker output received in " + timeToArrive + "ms");
          VIZI.Log("Worker output size is " + outputSize);
          VIZI.Log("Processed " + count + " features in " + timeTaken + "ms");

          // TODO: Stop this locking up the browser
          // No visible lock up at all when removed
          var geom = loader.parse(model);

          // var mesh = new THREE.Mesh(geom.geometry, material);
          var mesh = new THREE.Mesh(geom.geometry);

          // Use previously calculated offset to return merged mesh to correct position
          // This allows frustum culling to work correctly
          mesh.position.x = -1 * offset.x;
          mesh.position.y = -1 * offset.y;
          mesh.position.z = -1 * offset.z;

          THREE.GeometryUtils.merge(combinedGeom, mesh);

          // self.publish("addToScene", mesh);
        }
      });

      var offset = THREE.GeometryUtils.center( combinedGeom );

      combinedGeom.applyMatrix( new THREE.Matrix4().makeTranslation(0, -1 * offset.y, 0) );

      combinedMesh = new THREE.Mesh(combinedGeom, material);

      // http://stackoverflow.com/questions/20153705/three-js-wireframe-material-all-polygons-vs-just-edges
      // TODO: Fix the performance drop that this causes (effectively double the objects in the scene)
      // - Looks like the outline counts as "points" in renderer.info
      // - Also looks like they aren't being frustum culled for some reason
      // https://github.com/mrdoob/three.js/blob/master/src/extras/helpers/EdgesHelper.js
      if (VIZI.ENABLE_OUTLINES) {
        var outline = new THREE.EdgesHelper( combinedMesh, 0x222222 );
        outline.material.linewidth = 1;
        combinedMesh.add(outline);
      }

      // Use previously calculated offset to return merged mesh to correct position
      // This allows frustum culling to work correctly
      combinedMesh.position.x = -1 * offset.x;

      // Removed for scale center to be correct
      // Offset with applyMatrix above
      // combinedMesh.position.y = -1 * offset.y;

      combinedMesh.position.z = -1 * offset.z;

      // Initial scale for animation
      // Negative valie prevents error:
      // Matrix3.getInverse(): can't invert matrix, determinant is 0
      combinedMesh.scale.y = -0.01;

      // Add to animation queue
      self.objectAnimations[combinedMesh.id] = {
        mesh: combinedMesh,
        startTime: null,
        duration: 2000,
        startValue: -0.01,
        endValue: 1,
        currentValue: -0.01
      };

      self.publish("addToScene", combinedMesh);

      VIZI.Log("Average output received time is " + (totalReceivedTime / batches) + "ms");
      VIZI.Log("Overall worker time is " + (Date.now() - startTime) + "ms");
    }).done(function() {
      worker.close();
      deferred.resolve(combinedMesh);
    });

    return deferred.promise;
  };

  VIZI.ObjectManagerOverpass.prototype.animate = function(delta, lastTickTime) {
    var self = this;

    // Percentage increase per second
    // var scaleValue = 2 * (delta / 1000);
    // var easedValue = VIZI.Animation.easing.cubicInOut();

    _.each(self.objectAnimations, function(animation, index) {
      // Set start time
      if (!animation.startTime) {
        animation.startTime = lastTickTime;
      }

      // t is the current time, starting at zero. d is the duration in time. b and c are the starting and ending values.
      var t = VIZI.Animation.easing.cubicInOut((lastTickTime - animation.startTime) / animation.duration);
      var easedValue = animation.startValue + t*(animation.endValue-animation.startValue);

      // console.log(easedValue);

      // Update mesh values
      var mesh = animation.mesh;
      
      mesh.scale.y = easedValue;
      mesh.material.opacity = easedValue;

      // Update animation
      animation.currentValue = easedValue;

      if (mesh.scale.y > animation.endValue) {
        // Cap mesh values
        mesh.scale.y = animation.endValue;
        mesh.material.opacity = animation.endValue;

        // Remove animation
        delete self.objectAnimations[index];
      }
    });
  };
}());

/* globals window, _, VIZI, THREE */
(function() {
  "use strict";

  VIZI.Object = function() {
    _.extend(this, VIZI.Mediator);

    this.geo = VIZI.Geo.getInstance();
    this.object = undefined;
  };

  VIZI.Object.prototype.createObject = function() {};
}());
/* globals window, _, VIZI, THREE */
(function() {
  "use strict";

  VIZI.Floor = function() {
    VIZI.Log("Inititialising floor object");

    VIZI.Object.call(this);

    this.object = this.createObject();
  };

  VIZI.Floor.prototype = Object.create( VIZI.Object.prototype );

  VIZI.Floor.prototype.createObject = function() {
    var floorContainer = new THREE.Object3D();

    // var floorWireGeom = new THREE.PlaneGeometry(5000, 5000, 200, 200);
    // var floorWireMat = new THREE.MeshBasicMaterial({color: 0xeeeeee, wireframe: true});
    // var floorWire = new THREE.Mesh(floorWireGeom, floorWireMat);
    // floorWire.position.y = -0.3;
    // floorWire.rotation.x = - 90 * Math.PI / 180;

    // floorContainer.add(floorWire);

    // var floorGeom = new THREE.PlaneGeometry(40000, 40000, 4, 4);
    var floorGeom = new THREE.CircleGeometry(20000, 32);
    var floorMat = new THREE.MeshBasicMaterial({color: 0xf8f8f8});
    var floor = new THREE.Mesh(floorGeom, floorMat);
    floor.position.y = -0.4;
    floor.rotation.x = - 90 * Math.PI / 180;

    floorContainer.add(floor);

    this.publish("addToScene", floorContainer);

    return floorContainer;
  };
}());
/* globals window, _, VIZI, THREE, Q, d3 */
(function() {
  "use strict";

  VIZI.Data = function() {
    _.extend(this, VIZI.Mediator);

    // Reference to geo class
    this.geo = VIZI.Geo.getInstance();

    // Reference to grid class
    this.grid = VIZI.Grid.getInstance();

    // Cache
    this.cache = new VIZI.Cache();

    // Objects
    this.objects = {};

    // Use IDs of processed features to prevent duplication on tile boundaries
    // TODO: Remove ids from here when they're manually removed from view
    this.processedIds = {};

    // URL of data source
    this.url = "";

    // Degrees latitude for boundary distance from current position
    // Default to roughly 1km
    this.dataBoundsDistance = 0.009;

    // Degrees latitude for each data tile
    // Default to roughly around 550m
    this.dataTileSize = 0.005;

    // Winding
    this.clockwise = "cw";
    this.counterClockwise = "ccw";

    // Distance constants
    this.YARD_TO_METER = 0.9144;
    this.FOOT_TO_METER = 0.3048;
    this.INCH_TO_METER = 0.0254;
    this.METERS_PER_LEVEL = 3;
  };

  VIZI.Data.prototype.load = function(url, parameters, cacheKey) {
    var self = this;
    var deferred = Q.defer();

    // Check cache
    // TODO: Work out why this causes a lock-up
    // - Might need to use typed arrays
    var cachedFeatures = this.cache.get(cacheKey);
    if (cachedFeatures) {
      VIZI.Log("Loading tile from cache:", cacheKey);
      self.loadProcess(cachedFeatures, cacheKey).done(function() {
        deferred.resolve();
      });
      return deferred.promise;
    }

    // Replace URL placeholders with parameter values
    url = url.replace(/\{([swne])\}/g, function(value, key) {
      // Replace with paramter, otherwise keep existing value
      return parameters[key];
    });

    VIZI.Log("Requesting URL", url);

    // Request data and fulfil promise
    d3.json(url, function(error, data) {
      VIZI.Log("Response for URL", url);
      if (error) {
        deferred.reject(new Error(error));
      } else {
        // No features
        if (data.elements.length === 0) {
          deferred.resolve();
          return;
        }

        var features = self.process(data, true);

        // Add data to cache (including dupes on boundaries)
        self.cache.add(cacheKey, features);
        VIZI.Log("Added data to cache:", cacheKey);

        self.loadProcess(features, cacheKey).done(function() {
          deferred.resolve();
        });
      }
    });

    return deferred.promise;
  };

  VIZI.Data.prototype.loadProcess = function(features, cacheKey) {
    var self = this;
    var deferred = Q.defer();

    var uniqueFeatures = [];

    // Skip duplicate features
    _.each(features, function(feature) {
      // Skip if feature is undefined
      if (!feature) {
        VIZI.Log("Skipping undefined feature");
        return;
      }

      var existingId = _.find(self.processedIds, function(featureIds) {
        return (_.indexOf(featureIds, feature.id) === -1) ? false : true;
      });

      // TODO: Double-check that this is 100% correct as there are a lot of duplicated feature messages showing up
      // TODO: Look into issue where this may prevent the promise from resolving
      if (existingId) {
        VIZI.Log("Skipping duplicated feature");
        return;
      }

      if (!self.processedIds[cacheKey]) {
        self.processedIds[cacheKey] = [];
      }

      self.processedIds[cacheKey].push(feature.id);
      uniqueFeatures.push(feature);
    });

    // End promise if no features left to render
    if (uniqueFeatures.length === 0) {
      VIZI.Log("No features left to pass to worker");
      deferred.resolve();
      return deferred.promise;
    }

    // TODO: Pass-through progress event
    self.generateFeatures(uniqueFeatures).then(function(mesh) {
      // Store reference to mesh for tile
      self.objects[cacheKey] = mesh;
      deferred.resolve();
    }, undefined, function(progress) {
      // Pass-through progress
      deferred.notify(progress);
    });

    return deferred.promise;
  };

  VIZI.Data.prototype.update = function() {};
  VIZI.Data.prototype.process = function(data) {};
  VIZI.Data.prototype.generateFeatures = function(uniqueFeatures) {};

  VIZI.Data.prototype.checkDuplicateCoords = function(prev, current) {
    var dupe = false;
    _.each(prev, function(coord) {
      if (coord[0] === current[0] && coord[1] === current[1]) {
        dupe = true;
      }
    });

    return dupe;
  };

  // Enforce a polygon winding direcetion. Needed for proper backface culling.
  VIZI.Data.prototype.makeWinding = function(points, direction) {
    var winding = THREE.Shape.Utils.isClockWise(points) ? this.clockwise : this.counterClockwise;
    if (winding === direction) {
      return points;
    } else {
      return points.reverse();
    }
  };

  // Convert string distance value into meters
  // From: https://github.com/kekscom/osmbuildings/blob/master/src/Import.js#L39
  VIZI.Data.prototype.toMeters = function(str) {
    str = '' + str;
    var value = parseFloat(str);
    if (value === str) {
      return value <<0;
    }
    if (~str.indexOf('m')) {
      return value <<0;
    }
    if (~str.indexOf('yd')) {
      return value*this.YARD_TO_METER <<0;
    }
    if (~str.indexOf('ft')) {
      return value*this.FOOT_TO_METER <<0;
    }
    if (~str.indexOf('\'')) {
      var parts = str.split('\'');
      var res = parts[0]*this.FOOT_TO_METER + parts[1]*this.INCH_TO_METER;
      return res <<0;
    }
    return value <<0;
  };
}());
/* globals window, _, VIZI, Q, d3, simplify, throat */
(function() {
  "use strict";

  VIZI.DataOverpass = function(options) {
    VIZI.Log("Inititialising Overpass API manager");

    VIZI.Data.call(this);

    _.defaults(options, {
      gridUpdate: true
    });

    this.objectManager = new VIZI.ObjectManagerOverpass();

    // TODO: It's entirely possible that these queries are picking up duplicate ways. Need to look into it.
    // TODO: Ways that cross over tile boundaries will likely get picked up by a query for each tile. Look into that.
    // OSM Buildings handles this by not rendering items with an id that it already knows about
    // https://github.com/kekscom/osmbuildings/blob/master/src/Data.js#L59
    // Good Overpass queries: https://raw2.github.com/bigr/map1/master/import_osm.eu1000
    this.queryHigh = "[out:json];" +
      "((" +
      "rel({s},{w},{n},{e})[%22building%22];" +
      "rel({s},{w},{n},{e})[type=%22building%22];" +
      ");(._;way(r););(._;node(w););(" +
      "way({s},{w},{n},{e})[%22building%22];" +
      "way({s},{w},{n},{e})[%22building:part%22];" +
      "way({s},{w},{n},{e})[aeroway~%22aerodrome|runway%22];" +
      "way({s},{w},{n},{e})[waterway~%22riverbank|dock%22];" +
      "way({s},{w},{n},{e})[waterway=%22canal%22][area=%22yes%22];" +
      "way({s},{w},{n},{e})[natural~%22water|scrub%22];" +
      "way({s},{w},{n},{e})[leisure~%22park|pitch%22];" +
      "way({s},{w},{n},{e})[landuse~%22grass|meadow|forest%22];" +
      ((VIZI.ENABLE_ROADS) ? "way({s},{w},{n},{e})[highway~%22motorway|trunk|primary|secondary|tertiary|motorway_link|primary_link|secondary_link|tertiary_link|road%22];" : "") +
      ");(._;node(w);););out;";

    this.queryLow = "[out:json];" +
      "((" +
      "rel({s},{w},{n},{e})[waterway~%22riverbank|dock%22];" +
      "rel({s},{w},{n},{e})[waterway=%22canal%22][area=%22yes%22];" +
      "rel({s},{w},{n},{e})[natural~%22water|scrub%22];" +
      "rel({s},{w},{n},{e})[leisure~%22park|pitch%22];" +
      "rel({s},{w},{n},{e})[landuse~%22grass|meadow|forest|commercial|retail|industrial|construction|brownfield%22];" +
      ");(._;way(r););(._;node(w););(" +
      "way({s},{w},{n},{e})[waterway~%22riverbank|dock%22];" +
      "way({s},{w},{n},{e})[waterway=%22canal%22][area=%22yes%22];" +
      "way({s},{w},{n},{e})[natural~%22water|scrub%22];" +
      "way({s},{w},{n},{e})[leisure~%22park|pitch%22];" +
      "way({s},{w},{n},{e})[landuse~%22grass|meadow|forest|commercial|retail|industrial|construction|brownfield%22];" +
      ");(._;node(w);););out;";

    // URL of data source
    this.urlBase = "http://overpass-api.de/api/interpreter?data=";
    // this.urlBase = "http://overpass.osm.rambler.ru/cgi/interpreter?data=";
    // this.urlBase = "http://api.openstreetmap.fr/oapi/interpreter?data=";
    this.urlHigh = this.urlBase + this.queryHigh;
    this.urlLow = this.urlBase + this.queryLow;

    if (options.gridUpdate) {
      this.subscribe("gridUpdated", this.update);
    }
  };

  VIZI.DataOverpass.prototype = Object.create( VIZI.Data.prototype );

  VIZI.DataOverpass.prototype.update = function() {
    var self = this;
    var deferred = Q.defer();

    // Clear tiles out of bounds
    self.clearTiles(self.grid.boundsLow);

    var promiseQueue = [];
    promiseQueue.push(self.updateByLevel(self.grid.boundsHigh, self.urlHigh));
    // TODO: Re-enable low queries when loading performance and optimisation is sorted
    // promiseQueue.push(self.updateByLevel(self.grid.boundsLow, self.urlLow));

    Q.all(promiseQueue).done(function() {
      deferred.resolve();
    }, function(error) {
      deferred.reject(error);
    });

    return deferred.promise;
  };

  // TODO: Send one big query for bounds and split into tiles on return
  //  - Seems like the sending and receiving of XHR requests are expensive, not the processing
  VIZI.DataOverpass.prototype.updateByLevel = function(bounds, url) {
    var self = this;
    var deferred = Q.defer();

    // Load objects using promises
    var promiseQueue = [];

    var tileCount = [bounds.e-bounds.w, bounds.s-bounds.n];
    // Rows
    for (var i = 0; i < tileCount[0]; i++) {
      // Columns
      for (var j = 0; j < tileCount[1]; j++) {
        var tileCoords = [bounds.w + j, bounds.n + i];
        var tileBounds = {
          n: bounds.n + i,
          e: 1 + bounds.w + j,
          s: 1 + bounds.n + i,
          w: bounds.w + j
        };

        var tileBoundsLonLat = self.grid.getBoundsLonLat(tileBounds);

        var cacheKey = tileCoords[0] + ":" + tileCoords[1];

        // Skip tiles already in view
        if (self.objects[cacheKey]) {
          VIZI.Log("Skipping tile already in view", cacheKey);
          continue;
        }

        promiseQueue.push([self.load, [url, tileBoundsLonLat, cacheKey]]);
      }
    }

    // Use throat to limit simultaneous Overpass requests
    // Without limitation the Overpass API will rate-limit
    Q.all(promiseQueue.map(throat(1, function(promiseFunc) {
      return promiseFunc[0].apply(self, promiseFunc[1]);
    }))).done(function() {
      deferred.resolve();
    }, function(error) {
      deferred.reject(error);
    });

    return deferred.promise;
  };

  // Clear tiles out of bounds
  VIZI.DataOverpass.prototype.clearTiles = function(bounds) {
    var self = this;

    _.each(self.objects, function(mesh, index) {
      // Split index
      var splitIndex = index.split(":");

      // Tile is out of bounds
      if (splitIndex[0] >= bounds.e || splitIndex[0] < bounds.w || splitIndex[1] >= bounds.s || splitIndex[1] < bounds.n) {
        // Remove mesh from scene
        VIZI.Log("Removing mesh from scene", index);
        self.publish("removeFromScene", mesh);
        delete self.objects[index];

        // Remove processed feature IDs
        delete self.processedIds[index];
      }
    });
  };

  VIZI.DataOverpass.prototype.updateByWayIntersect = function(wayId) {
    var self = this;
    var deferred = Q.defer();

    var url = this.urlBase + "[out:json];(way(" + wayId + "));(._;node(w););out;";

    // Get way to intersect with
    VIZI.Log("Requesting URL", url);

    d3.json(url, function(error, data) {
      VIZI.Log("Response for URL", url);
      if (error) {
        deferred.reject(new Error(error));
      } else {
        // No features
        if (data.elements.length === 0) {
          deferred.resolve();
          return;
        }

        var way = self.process(data, false, false)[0];

        VIZI.Log(way);
        var coordinates = way.coordinates;

        var tiles = {};

        // Find tiles that intersect way
        _.each(coordinates, function(coordinate) {
          var tile = self.grid.lonlat2tile(coordinate[0], coordinate[1], self.geo.tileZoom);

          if (!tiles[tile[1]]) {
            tiles[tile[1]] = [];
          }

          if (_.indexOf(tiles[tile[1]], tile[0]) === -1) {
            tiles[tile[1]].push(tile[0]);
          }
        });

        VIZI.Log(tiles);

        var promiseQueue = [];

        _.each(tiles, function(tilesX, tileY) {
          // Fill in gaps
          var minX = _.min(tilesX);
          var maxX = _.max(tilesX);

          var tilesXFilled = _.range(minX, maxX + 1);

          _.each(tilesXFilled, function(tileX) {
            var tileBounds = {
              n: Number(tileY),
              e: tileX + 1,
              s: Number(tileY) + 1,
              w: tileX
            };

            var tileBoundsLonLat = self.grid.getBoundsLonLat(tileBounds);

            // VIZI.Log(tileBoundsLonLat);

            var cacheKey = tileX + ":" + tileY;

            // TODO: Handle load promise without actually running the function
            // - At the moment, the load function is run in at this point
            promiseQueue.push([self.load, [self.urlHigh, tileBoundsLonLat, cacheKey]]);
          });
        });

        // Use throat to limit simultaneous Overpass requests
        // Without limitation the Overpass API will rate-limit
        Q.all(promiseQueue.map(throat(1, function(promiseFunc) {
          return promiseFunc[0].apply(self, promiseFunc[1]);
        }))).done(function() {
          // deferred.resolve();
        }, function(error) {
          // deferred.reject(error);
        });

        deferred.resolve();
      }
    });

    return deferred.promise;
  };

  // Process data (convert from Overpass format to a common ViziCities format)
  // http://wiki.openstreetmap.org/wiki/Talk:Overpass_API/Language_Guide#JSON_Syntax
  // Heavily based on the OSMBuildings approach
  // https://github.com/kekscom/osmbuildings/blob/c68e6d87e52de0260e6b2d2f6660d550b79b4915/src/import/OSMXAPI.js
  // TODO: Process relations before adding ways to output
  // Aims to avoid clashes like with way 139726525
  VIZI.DataOverpass.prototype.process = function(data, simple, project) {
    var self = this;

    var nodes = {};
    var ways = {};
    var result = [];

    var elements = data.elements;
    var way;
    _.each(elements, function(element) {
      // Find a way to do this without passing the node and way objects
      switch (element.type) {
        case "node":
          self.processNode(nodes, element, project);
          break;
        case "way":
          self.processWay(result, ways, nodes, element, simple);
          break;
        case "relation":
          self.processRelation(result, ways, nodes, element);
      }
    });

    return result;
  };

  VIZI.DataOverpass.prototype.processNode = function(nodes, element, project) {
    nodes[element.id] = (project === false) ? [element.lon, element.lat] : this.geo.projection([element.lon, element.lat]);
  };

  // TODO: Validate polygon to make sure it's renderable (eg. complete, and no cross-overs)
  // TODO: Don't peform unnecessary logic and tagging for non-building ways
  VIZI.DataOverpass.prototype.processWay = function(result, ways, nodes, element, simple) {
    var self = this;

    var tags = element.tags || {};

    var coordinates = self.createOutline(nodes, element.nodes);

    if (!coordinates) {
      VIZI.Log("Skipping feature as it has duplicate coordinates", element.id, coordinates);
      return;
    }

    // Not enough points to make an object
    // Ignore if a road
    if (!tags["highway"] && coordinates.length < 4) {
      VIZI.Log("Skipping feature as it hasn't enough coordinates", element.id, coordinates);
      return;
    }

    var area = self.processArea(coordinates);

    // Skip objects too small
    // if (area < 500) {
    // return;
    // }

    // Ignore if a road
    if (!tags["highway"] && simple) {
      // Simplify coordinates
      // TODO: Perform this in the worker thread
      var simplifyTolerance = 3; // Three.js units
      coordinates = simplify(coordinates, simplifyTolerance);

      // VIZI.Log("Original coord count:", coordinates.length);
      // VIZI.Log("Simplified coord count:", simplifiedCoords.length);

      // VIZI.Log("Original coord example:", coordinates[0], coordinates[1]);
      // VIZI.Log("Simplified coord example:", simplifiedCoords[0], simplifiedCoords[1]);

      // Not enough points to make an object
      if (coordinates.length < 4) {
        return;
      }
    }

    tags["vizicities:area"] = area;
    tags.height = this.processHeight(tags);

    if (tags["min_height"] || tags["building:min_height"] || tags["min_levels"] || tags["building:min_levels"]) {
      tags.minHeight = this.processMinHeight(tags);
    }

    tags.colour = this.processColour(tags);
    tags.roof = this.processRoof(tags);

    // TODO: Calculate area
    // getGeodesicArea from http://dev.openlayers.org/releases/OpenLayers-2.10/lib/OpenLayers/Geometry/LinearRing.js
    // More info: http://gis.stackexchange.com/a/8496/14967
    // tags.area;

    var way = {
      id: element.id,
      coordinates: coordinates,
      properties: tags
    };

    ways[way.id] = way;

    if (self.isResult(way)) {
      way.coordinates = self.makeWinding(way.coordinates, self.clockwise);
      result.push(way);
    }
  };

  VIZI.DataOverpass.prototype.processRelation = function(result, ways, nodes, element) {
    var self = this;

    if (element.tags.type !== "multipolygon" && element.tags.type !== "building") {
      return;
    }

    var relationWays = self.getRelationWays(element.members, ways);
    if (relationWays) {
      // relItem = filterItem(relation);
      var outerWay = relationWays.outer;
      outerWay.coordinates = self.makeWinding(outerWay.coordinates, self.clockwise);
      if (outerWay) {
        var holes = [];

        _.each(relationWays.inner, function(innerWay, index) {
          if (innerWay.coordinates) {
            // Simplify coordinates
            // TODO: Perform this in the worker thread
            var simplifyTolerance = 3; // Three.js units
            var coordinates = simplify(innerWay.coordinates, simplifyTolerance);

            // Not enough points to make an object
            if (coordinates.length < 4) {
              return;
            }

            // Adding to the beginning seems to result in better holes
            // Using push causes all sorts of problems
            // TODO: Fix problems on buildings like Houses of Parliament
            holes.unshift(self.makeWinding(coordinates, self.counterClockwise));
          }
        });

        if (holes.length) {
          outerWay.holes = holes;
        }

        _.extend(outerWay.properties, element.tags);

        // Remove old tags
        outerWay.properties.height = null;

        if (outerWay.properties.minHeight) {
          outerWay.properties.minHeight = null;
        }

        outerWay.properties.colour = null;
        outerWay.properties.roof = null;

        // Reprocess tags
        // TODO: Remove the need for this duplication
        outerWay.properties.height = self.processHeight(outerWay.properties);

        if (outerWay.properties.minHeight) {
          outerWay.properties.minHeight = self.processMinHeight(outerWay.properties);
        }

        outerWay.properties.colour = self.processColour(outerWay.properties);
        outerWay.properties.roof = self.processRoof(outerWay.properties);

        result.push(outerWay);
      }
    }
  };

  // From: https://github.com/kekscom/osmbuildings/blob/c68e6d87e52de0260e6b2d2f6660d550b79b4915/src/import/OSMXAPI.js#L39
  VIZI.DataOverpass.prototype.getRelationWays = function(members, ways) {
    var m, outer, inner = [];
    for (var i = 0, il = members.length; i < il; i++) {
      m = members[i];
      if (m.type !== 'way' || !ways[m.ref]) {
        continue;
      }
      if (!m.role || m.role === 'outer') {
        outer = ways[m.ref];
        continue;
      }
      if (m.role === 'inner' || m.role === 'enclave') {
        inner.push(ways[m.ref]);
        continue;
      }
    }

    // allows tags to be attached to relation - instead of outer way
    if (outer) {
      return { outer:outer, inner:inner };
    }
  };

  VIZI.DataOverpass.prototype.createOutline = function(nodes, elementNodes) {
    var self = this;
    
    var nodeCount = elementNodes.length;

    var coordinates = [];
    var dupe = false;
    _.each(elementNodes, function(node, index) {
      // Shouldn"t duplicate any points apart from first and last
      if (index < nodeCount-1 && self.checkDuplicateCoords(coordinates, nodes[node])) {
        dupe = true;
      }

      coordinates.push(nodes[node]);
    });

    if (dupe) {
      return false;
    }

    return coordinates;
  };

  // Not perfect but it's good enough for area-based logic
  // http://www.mathopenref.com/coordpolygonarea2.html
  VIZI.DataOverpass.prototype.processArea = function(points) {
    var self = this;
    var numPoints = points.length;
    var area = 0;         // Accumulates area in the loop
    var j = numPoints-1;  // The last vertex is the 'previous' one to the first

    for (var i = 0; i < numPoints; i++) {
      area = area + (points[j][0]+points[i][0]) * (points[j][1]-points[i][1]);
      j = i;  // j is previous vertex to i
    }

    return Math.abs((area/2) / self.geo.pixelsPerMeter);
  };

  VIZI.DataOverpass.prototype.processHeight = function(tags) {
    // Distance conversion
    // From: https://github.com/kekscom/osmbuildings/blob/master/src/Import.js#L39
    var height;
    var scalingFactor = (tags["building"] === "office") ? 1.45 : 1;
    if (tags.height) {
      height = this.toMeters(tags.height);
    } else if (!height && tags["building:height"]) {
      height = this.toMeters(tags["building:height"]);
    } else if (!height && tags.levels) {
      height = tags.levels * this.METERS_PER_LEVEL * scalingFactor <<0;
    } else if (!height && tags["building:levels"]) {
      height = tags["building:levels"] * this.METERS_PER_LEVEL * scalingFactor <<0;
    } else if (tags["building"]) {
      height = 10 + Math.random() * 10;
    } else if (tags["landuse"] === "forest") {
      height = 7;
    // } else if (tags["waterway"] || tags["natural"] && /water|scrub/.test(tags["natural"]) || tags["leisure"] && /park|pitch/.test(tags["leisure"]) || tags["landuse"] && /grass|meadow|commercial|retail|industrial|brownfield/.test(tags["landuse"])) {
    } else if (tags["waterway"] || tags["natural"] === "water") {
      height = 4;
    } else if (tags["natural"] === "scrub" || tags["leisure"] && /park|pitch/.test(tags["leisure"]) || tags["landuse"] && /grass|meadow/.test(tags["landuse"]) || tags["aeroway"] === "runway") {
      height = 3;
    } else {
      height = 1;
    }

    height *= this.geo.pixelsPerMeter;

    return height;
  };

  // TODO: Condense this into a single height method
  VIZI.DataOverpass.prototype.processMinHeight = function(tags) {
    // Distance conversion
    // From: https://github.com/kekscom/osmbuildings/blob/master/src/Import.js#L39
    var height;
    var scalingFactor = (tags["building"] === "office") ? 1.45 : 1;
    if (tags["min_height"]) {
      height = this.toMeters(tags["min_height"]);
    } else if (!height && tags["building:min_height"]) {
      height = this.toMeters(tags["building:min_height"]);
    } else if (!height && tags["min_levels"]) {
      height = tags["min_levels"] * this.METERS_PER_LEVEL * scalingFactor <<0;
    } else if (!height && tags["building:min_levels"]) {
      height = tags["building:min_levels"] * this.METERS_PER_LEVEL * scalingFactor <<0;
    }

    height *= this.geo.pixelsPerMeter;

    return height;
  };

  VIZI.DataOverpass.prototype.processRoof = function(tags) {
    var roof = {
      shape: "flat",
    };

    if (tags["roof:shape"] !== undefined) {
      roof.shape = tags["roof:shape"];
    }

    return roof;
  };

  VIZI.DataOverpass.prototype.processColour = function(tags) {
    var colour;
    if (tags["building"] || tags["building:part"]) {
      colour = (VIZI.ENABLE_OUTLINES) ? 0xffffff : 0xeeeeee;
    } else if (tags["waterway"] || tags["natural"] === "water") {
      colour = 0x6DCCFF;
    } else if (tags["landuse"] === "forest") {
      colour = 0x7ea410;
    } else if (tags["natural"] === "scrub" || tags["leisure"] && /park|pitch/.test(tags["leisure"]) || tags["landuse"] && /grass|meadow/.test(tags["landuse"])) {
      colour = 0xc0da75;
    } else if (tags["landuse"] && /industrial|construction|brownfield/.test(tags["landuse"])) {
      colour = 0xd8c7b5;
    } else if (tags["landuse"] && /commercial|retail/.test(tags["landuse"])) {
      colour = 0xa9bbd6;
    } else if (tags["aeroway"] === "aerodrome") {
      colour = 0xeeeeee;
    } else if (tags["aeroway"] === "runway") {
      colour = 0x666666;
    } else {
      VIZI.Log("Setting default colour for feaure", tags);
      colour = 0xFF0000;
    }

    return colour;
  };

  VIZI.DataOverpass.prototype.generateFeatures = function(features) {
    var self = this;
    var deferred = Q.defer();
    
    self.objectManager.processFeaturesWorker(features, self.geo.pixelsPerMeter).then(function(mesh) {
      deferred.resolve(mesh);
    }, undefined, function(progress) {
      // Pass-through progress
      deferred.notify(progress);
    });

    return deferred.promise;
  };

  // Is the element suitable to be outputted as a result?
  // Highway has area dependency to avoid trouble with closed ways they are described as highways (like 134405951)
  // TODO: Detect if it isn't a result, rather than checking all tags to see if it is
  VIZI.DataOverpass.prototype.isResult = function(element) {
    var tags = element.properties;
    
    return (
      tags && 
      (tags["building"] || tags["building:part"] || tags["waterway"] || tags["natural"] || tags["landuse"] || tags["leisure"] || tags["aeroway"] || (tags["highway"] && !tags["area"]))
    );
  };
}());

/* globals window, _, VIZI, Q, THREE */
(function() {
  "use strict";

  VIZI.Grid = (function() {
    var Grid = function() {
      VIZI.Log("Inititialising grid manager");

      _.extend(this, VIZI.Mediator);

      // Reference to geo class
      this.geo = VIZI.Geo.getInstance();

      // Location of grid center
      this.pos2d = new THREE.Vector2();
      this.centerTile = [];

      // Tile size and zoom level comes from VIZI.Geo

      // Tiles per direction for high detail
      this.tilesPerDirectionHigh = 1;

      // Tiles per direction for low detail
      // TODO: Make this lower when rivers and larger features are added to their own layer, otherwise they pop out of view when cleaning up
      this.tilesPerDirectionLow = 5;

      // Calculated pixel tile size
      this.tileSize = 0;

      // Grid bounds for high detail (in TMS values)
      this.boundsHigh = {};

      // Grid bounds for high detail (lon, lat)
      this.boundsHighLonLat = {};

      // Grid bounds for low detail (in TMS values)
      this.boundsLow = {};

      // Grid bounds for low detail (lon, lat)
      this.boundsLowLonLat = {};

      // Debug grid model
      this.gridModel = new THREE.Object3D();

      this.subscribe("centerPositionChanged", this.onCenterChanged);
    };

    Grid.prototype.init = function(coords) {
      var projCoords = this.geo.projection(coords);

      this.pos2d.x = projCoords[0];
      this.pos2d.y = projCoords[1];

      this.centerTile = this.lonlat2tile(coords[0], coords[1], this.geo.tileZoom, true);

      this.boundsHigh = this.getBounds(this.tilesPerDirectionHigh);
      this.boundsLow = this.getBounds(this.tilesPerDirectionLow);

      this.boundsHighLonLat = this.getBoundsLonLat(this.boundsHigh);
      this.boundsLowLonLat = this.getBoundsLonLat(this.boundsLow);

      if (VIZI.DEBUG) {
        // Create debug model for grid
        this.createDebug();
        this.publish("addToScene", this.gridModel);
      }

      return Q.fcall(function() {});
    };

    Grid.prototype.update = function() {
      // Store old position and bounds
      var oldPos2d = this.pos2d.clone();

      var oldBoundsHigh = {
        n: this.boundsHigh.n,
        e: this.boundsHigh.e,
        s: this.boundsHigh.s,
        w: this.boundsHigh.w
      };

      var oldBoundsLow = {
        n: this.boundsLow.n,
        e: this.boundsLow.e,
        s: this.boundsLow.s,
        w: this.boundsLow.w
      };
      // Update central position
      // Calculate bounds
    };

    Grid.prototype.getBounds = function(tileDistance) {
      var bounds = {
        n: Math.floor(this.centerTile[1]) - tileDistance,
        e: Math.ceil(this.centerTile[0]) + tileDistance,
        s: Math.ceil(this.centerTile[1]) + tileDistance,
        w: Math.floor(this.centerTile[0]) - tileDistance
      };

      return bounds;
    };

    Grid.prototype.getBoundsLonLat = function(bounds) {
      var max = this.tile2lonlat(bounds.e, bounds.n, this.geo.tileZoom);
      var min = this.tile2lonlat(bounds.w, bounds.s, this.geo.tileZoom);

      var boundsLonLat = {
        n: this.geo.decimalPlaces(max[1]),
        e: this.geo.decimalPlaces(max[0]),
        s: this.geo.decimalPlaces(min[1]),
        w: this.geo.decimalPlaces(min[0])
      };

      return boundsLonLat;
    };

    Grid.prototype.onCenterChanged = function(centerPixels, centerLonLat, bounds) {
      var centerTile = this.lonlat2tile(centerLonLat[0], centerLonLat[1], this.geo.tileZoom, true);

      var gridDiff = [
        Math.floor(centerTile[0]) - Math.floor(this.centerTile[0]),
        Math.floor(centerTile[1]) - Math.floor(this.centerTile[1])
      ];

      if (Math.abs(gridDiff[0]) > 0 || Math.abs(gridDiff[1]) > 0) {
        VIZI.Log("Update grid", gridDiff);

        this.pos2d.x = centerPixels[0];
        this.pos2d.y = centerPixels[1];

        this.centerTile = centerTile;

        this.boundsHigh = this.getBounds(this.tilesPerDirectionHigh);
        this.boundsLow = this.getBounds(this.tilesPerDirectionLow);

        this.boundsHighLonLat = this.getBoundsLonLat(this.boundsHigh);
        this.boundsLowLonLat = this.getBoundsLonLat(this.boundsLow);

        this.gridModel.position.x += this.tileSize * gridDiff[0];
        this.gridModel.position.z += this.tileSize * gridDiff[1];

        this.publish("gridUpdated");
      }
    };

    Grid.prototype.createDebug = function() {
      var lonLatMin = this.tile2lonlat(Math.floor(this.centerTile[0]), Math.floor(this.centerTile[1]), this.geo.tileZoom);
      var lonLatMax = this.tile2lonlat(Math.floor(this.centerTile[0])+1, Math.floor(this.centerTile[1])+1, this.geo.tileZoom);

      // Why is this tilesize so random?
      this.tileSize = this.geo.projection(lonLatMax)[0] - this.geo.projection(lonLatMin)[0];
      
      var tileLineMatHigh = new THREE.LineBasicMaterial( { color: 0xcc0000, linewidth: 6 } );
      var tileLineMatLow = new THREE.LineBasicMaterial( { color: 0x0000cc, linewidth: 6 } );
      
      var tileLineGeom = new THREE.Geometry();

      var vertices = tileLineGeom.vertices;
      vertices.push(new THREE.Vector3(0, 0, 0));
      vertices.push(new THREE.Vector3(this.tileSize, 0, 0));
      vertices.push(new THREE.Vector3(this.tileSize, 0, this.tileSize));
      vertices.push(new THREE.Vector3(0, 0, this.tileSize));
      vertices.push(new THREE.Vector3(0, 0, 0));

      tileLineGeom.computeLineDistances();

      var i, j, tileCoords, position, tileLine;

      // High
      var tileCountHigh = [this.boundsHigh.e-this.boundsHigh.w, this.boundsHigh.s-this.boundsHigh.n];
      // Rows
      for (i = 0; i < tileCountHigh[0]; i++) {
        // Columns
        for (j = 0; j < tileCountHigh[1]; j++) {
          tileCoords = [this.boundsHigh.w + j, this.boundsHigh.n + i];

          position = this.geo.projection(this.tile2lonlat(tileCoords[0], tileCoords[1], this.geo.tileZoom));

          tileLine = new THREE.Line(tileLineGeom, tileLineMatHigh);
          tileLine.position.y = 2;
          tileLine.position.x = position[0];
          tileLine.position.z = position[1];

          this.gridModel.add(tileLine);
        }
      }

      // Low
      var tileCountLow = [this.boundsLow.e-this.boundsLow.w, this.boundsLow.s-this.boundsLow.n];
      // Rows
      for (i = 0; i < tileCountLow[0]; i++) {
        // Columns
        for (j = 0; j < tileCountLow[1]; j++) {
          tileCoords = [this.boundsLow.w + j, this.boundsLow.n + i];

          position = this.geo.projection(this.tile2lonlat(tileCoords[0], tileCoords[1], this.geo.tileZoom));

          tileLine = new THREE.Line(tileLineGeom, tileLineMatLow);
          tileLine.position.y = 0.1;
          tileLine.position.x = position[0];
          tileLine.position.z = position[1];

          this.gridModel.add(tileLine);
        }
      }
    };

    Grid.prototype.lonlat2tile = function(lon, lat, zoom, float) {
      lon = Number(lon);

      var tx, ty;
      
      if (float) {
        tx = ((lon+180)/360*Math.pow(2,zoom));
        ty = ((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom));
      } else {
        tx = (Math.floor((lon+180)/360*Math.pow(2,zoom)));
        ty = (Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom)));
      }

      return [tx, ty];
    };

    Grid.prototype.tile2lonlat = function(x, y, z) {
      var lon = (x/Math.pow(2,z)*360-180);
      var n = Math.PI-2*Math.PI*y/Math.pow(2,z);
      var lat = (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));

      return [lon, lat];
    };

    var instance;

    // an emulation of static variables and methods
    var _static = {   
      name: "VIZI.Grid",

      // Method for getting an instance. It returns 
      // a singleton instance of a singleton object
      getInstance: function() {
        if ( instance  ===  undefined )  {
          instance = new Grid();
        }

        return instance;
      }
    };

    return _static;
  }());
}());
/* globals window, _, VIZI, THREE */
(function() {
  "use strict";

  VIZI.Mouse = (function() {
    var Mouse = function(domElement, camera) {
      VIZI.Log("Inititialising mouse manager");

      _.extend(this, VIZI.Mediator);

      // Reference to camera for 3D projection
      this.camera = camera;
      this.projector = new THREE.Projector();

      this.state = {
        buttons: {
          left: false,
          right: false,
          middle: false
        },
        pos2d: new THREE.Vector2(),
        downPos2d: new THREE.Vector2(),
        downPos2dDelta: new THREE.Vector2(),
        pos3d: new THREE.Vector3(),
        downPos3d: new THREE.Vector3(),
        pos2dDelta: new THREE.Vector2(),
        pos3dDelta: new THREE.Vector3(),
        wheelDelta: 0,
        camera: {
          startTheta: this.camera.theta,
          startPhi: this.camera.phi
        }
      };

      this.initDOMEvents(domElement);
    };

    Mouse.prototype.initDOMEvents = function(domElement) {
      var self = this;

      domElement.addEventListener("mousedown", function(event) {
        self.onMouseDown(event);
      }, false);

      domElement.addEventListener("mousemove", function(event) {
        self.onMouseMove(event);
      }, false);

      domElement.addEventListener("mouseup", function(event) {
        self.onMouseUp(event);
      }, false);

      // Prefer wheel event, but fallback to mousewheel event if necessary
      var wheel_event = "wheel"; 
      if (window.onwheel === undefined) {
        wheel_event = "mousewheel"; 
      }

      domElement.addEventListener(wheel_event, function(event) {
        self.onMouseWheel(event);
      }, false);

    };

    Mouse.prototype.onMouseDown = function(event) {
      event.preventDefault();

      var state = this.state;

      if (event.button === 0) {
        state.buttons.left = true;
      }

      if (event.button === 1) {
        state.buttons.middle = true;
      }

      if (event.button === 2) {
        state.buttons.right = true;
      }

      state.pos2d.x = event.clientX;
      state.pos2d.y = event.clientY;

      state.downPos2d.x = event.clientX;
      state.downPos2d.y = event.clientY;

      state.pos2dDelta.x = 0;
      state.pos2dDelta.y = 0;

      var pos3d = this.mouseIn3d(state.downPos2d);

      state.pos3d.x = pos3d.x;
      state.pos3d.y = pos3d.y;
      state.pos3d.z = pos3d.z;

      state.downPos3d.x = pos3d.x;
      state.downPos3d.y = pos3d.y;
      state.downPos3d.z = pos3d.z;

      state.pos3dDelta.x = 0;
      state.pos3dDelta.y = 0;
      state.pos3dDelta.z = 0;

      state.camera.startTheta = this.camera.theta;
      state.camera.startPhi = this.camera.phi;
    };

    Mouse.prototype.onMouseMove = function(event) {
      event.preventDefault();

      var state = this.state;

      state.pos2dDelta.x = event.clientX - state.pos2d.x;
      state.pos2dDelta.y = event.clientY - state.pos2d.y;

      state.pos2d.x = event.clientX;
      state.pos2d.y = event.clientY;

      var pos3d = this.mouseIn3d(state.pos2d);

      state.pos3d.x = pos3d.x;
      state.pos3d.y = pos3d.y;
      state.pos3d.z = pos3d.z;

      if (state.buttons.left || state.buttons.middle) {
        state.downPos2dDelta.x = event.clientX - state.downPos2d.x;
        state.downPos2dDelta.y = event.clientY - state.downPos2d.y;

        state.pos3dDelta.x = state.downPos3d.x - pos3d.x;
        state.pos3dDelta.y = state.downPos3d.y - pos3d.y;
        state.pos3dDelta.z = state.downPos3d.z - pos3d.z; 
      }
    };

    Mouse.prototype.onMouseUp = function(event) {
      event.preventDefault();

      var state = this.state;

      if (event.button === 0) {
        state.buttons.left = false;
      }

      if (event.button === 1) {
        state.buttons.middle = false;
      }

      if (event.button === 2) {
        state.buttons.right = false;
      }

      // Reset mouse down positions and deltas
      state.downPos2dDelta.x = 0;
      state.downPos2dDelta.y = 0;
    };

    Mouse.prototype.onMouseWheel = function(event) {
      event.preventDefault();

      var state = this.state;

      // Wheel event 
      if (event.deltaY !== undefined) {

        state.wheelDelta -= event.deltaY;
      
      // MouseWheel Event 
      } else {

        state.wheelDelta += event.wheelDeltaY;

      }

    };

    Mouse.prototype.resetDelta = function() {
      var state = this.state;

      state.pos2dDelta.x = 0;
      state.pos2dDelta.y = 0;

      state.pos3dDelta.x = 0;
      state.pos3dDelta.y = 0;
      state.pos3dDelta.z = 0;
      
      state.wheelDelta = 0;
    };

    Mouse.prototype.mouseIn3d = function(pos2d) {
      var camera = this.camera.camera;

      var vector = new THREE.Vector3(
        ( pos2d.x / window.innerWidth ) * 2 - 1,
        - ( pos2d.y / window.innerHeight ) * 2 + 1,
        0.5
      );

      this.projector.unprojectVector( vector, camera );

      var dir = vector.sub( camera.position ).normalize();

      var distance = - camera.position.y / dir.y;

      var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );

      return pos;
    };

    // TODO: Tidy this up
    Mouse.prototype.updateCamera = function() {
      var state = this.state;

      state.downPos2d.x = state.pos2d.x;
      state.downPos2d.y = state.pos2d.y;

      state.downPos2dDelta.x = 0;
      state.downPos2dDelta.y = 0;

      state.camera.startTheta = this.camera.theta;
      state.camera.startPhi = this.camera.phi;
    };

    var instance;

    // an emulation of static variables and methods
    var _static = {   
      name: "VIZI.Mouse",

      // Method for getting an instance. It returns 
      // a singleton instance of a singleton object
      getInstance: function(domElement, camera) {
        if ( instance  ===  undefined )  {
          instance = new Mouse(domElement, camera);
        }

        return instance;
      }
    };

    return _static;
  }());
}());
/* globals window, _, VIZI */
(function() {
  "use strict";

  VIZI.Keyboard = (function() {
    var Keyboard = function(domElement) {
      VIZI.Log("Inititialising mouse manager");

      _.extend(this, VIZI.Mediator);

      this.state = {
        keys: {}
      };

      this.initDOMEvents(domElement);
    };

    // TODO: Work out if domElement should be used instead of document
    Keyboard.prototype.initDOMEvents = function(domElement) {
      var self = this;

      document.addEventListener("keydown", function(event) {
        self.onKeyDown(event);
      }, false);

      document.addEventListener("keyup", function(event) {
        self.onKeyUp(event);
      }, false);
    };

    Keyboard.prototype.onKeyDown = function(event) {
      var key = this.keyCodeToString(event.keyCode);

      if (!key) {
        return;
      }

      this.state.keys[key] = true;
    };

    Keyboard.prototype.onKeyUp = function(event) {
      var key = this.keyCodeToString(event.keyCode);

      if (!key) {
        return;
      }

      this.state.keys[key] = false;
    };

    Keyboard.prototype.keyCodeToString = function(keyCode) {
      var key;

      switch (keyCode) {
        case 16:
          key = "shift";
          break;
        default:
          key = false;
      }

      return key;
    };

    var instance;

    // an emulation of static variables and methods
    var _static = {   
      name: "VIZI.Keyboard",

      // Method for getting an instance. It returns 
      // a singleton instance of a singleton object
      getInstance: function(domElement) {
        if ( instance  ===  undefined )  {
          instance = new Keyboard(domElement);
        }

        return instance;
      }
    };

    return _static;
  }());
}());
/* globals window, _, Q, VIZI */
(function() {
  "use strict";

  VIZI.Controls = (function() {
    var Controls = function() {
      VIZI.Log("Inititialising controls");

      _.extend(this, VIZI.Mediator);

      this.enabled = undefined;

      this.mouse = undefined;
      this.keyboard = undefined;
    };

    Controls.prototype.init = function(domElement, camera, options) {
      if (options.enable) {
        this.mouse = VIZI.Mouse.getInstance(domElement, camera);
        this.keyboard = VIZI.Keyboard.getInstance(domElement);

        this.subscribe("update", this.onUpdate);
        this.subscribe("orbitControlCap", this.orbitCapReset);
      }
      this.enabled = options.enable;

      return Q.fcall(function() {});
    };

    Controls.prototype.onUpdate = function() {
      var mouseState = this.mouse.state;
      var keyboardState = this.keyboard.state;

      // Zoom
      if (mouseState.wheelDelta !== 0) {
        this.publish("zoomControl", -1 * mouseState.wheelDelta);
      }

      // Pan
      if (mouseState.buttons.left && !keyboardState.keys.shift) {
        this.publish("panControl", mouseState.pos3dDelta);
      }

      // Orbit
      if ((mouseState.buttons.left && keyboardState.keys.shift) || mouseState.buttons.middle) {
        this.publish("orbitControl", mouseState.downPos2dDelta, mouseState.camera.startTheta, mouseState.camera.startPhi);
      }

      // Zero deltas
      this.mouse.resetDelta();
    };

    Controls.prototype.orbitCapReset = function() {
      this.mouse.updateCamera();
    };

    var instance;

    // an emulation of static variables and methods
    var _static = {   
      name: "VIZI.Controls",

      // Method for getting an instance. It returns 
      // a singleton instance of a singleton object
      getInstance: function() {
        if ( instance  ===  undefined )  {
          instance = new Controls();
        }

        return instance;
      }
    };

    return _static;
  }());
}());
/* globals window, _, VIZI, Q */
(function() {
  "use strict";

  VIZI.Cache = function() {
    _.extend(this, VIZI.Mediator);

    this.data = {};
  };

  VIZI.Cache.prototype.get = function(key) {
    return this.data[key];
  };
  
  VIZI.Cache.prototype.add = function(key, value) {
    this.data[key] = value;
  };
}());